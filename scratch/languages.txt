Example: C# vs Javascript/Node vs Clojure vs Erlang vs Haskell
==

**C# and .NET**

I make no secret that I was a .NET developer for a long while. There is very little I can say negatively about C# and .NET that hasn't been said before but as I built a lot of software in it it'd be a shame to miss it out in a post like this. The industry built up around it is probably my biggest hatred over the langauge and platform itself; the managers who are persuaded by salespeople that what they need is TFS and WCF and other TLAs and then development will be easy. The hordes of developers who blindly just use whatever Microsoft has provided because thinking for yourself is too hard. The tooling and environments that pretty much destroyed my wrists from crappy mouse-driven UIs (Visual Studio and Windows) and the developers who tried to persuade me every year that "things were changing or different now and it wasn't like that any more". Trying to step away from that environment and carry on using C# in a way that wasn't inside the box that Microsoft had made for us and tilting at windmills with esoteric combinations of OmniSharp and ctags. The language that seems to be the personal playground for Anders to just stick anything in that seems cool right now (How long until Scala and C# are the same language for example) .

And yet in small projects once you had indeed fought the system and got your mono based development environment up and running C# wasn't too bad providing you stayed away from dynamic and poorly designed frameworks and libraries with their layers of interfaces and either over-design based on IOC container magic or lack of it entirely.

The community and friends that I built up from my time in this pit has stayed with me ever since the beginning however; in the same way that being trapped in a broken elevator can bring people together or being held hostage forces you to make connections with those around you - working in the .NET environment forced you to find people around you with similar experiences so you could have a beer at the end of the day and talk about the pain you had all endured together.

The constant aches, pains and boredom also led to a lot of conversations about the basic act of software development (most of it bike-shedding) but the constant arguments about tests, SOLID, interface-use and framework adoption and the push to constantly be improving is what pushed me off into different pastures. This is all still going on at community events everywhere and these entry level discussions have their use in helping developers to learn to move beyond what they know.

Current position on the curve: *Bitter memories*.

**Javascript and Node**

I've always used JS and I've written some pretty cool things in it; for a while the cowboy in me relished the untamed nature of this dynamic and often quite foolish language and to this day the cowboy in me still does. Node is an hilarious technology choice in that as much as it has a nice ethos around modules and a tiny core it is still based on one of the worst languages to ever be unleashed on the masses.


It's funny because JS requires quite a lot of up-front effort to be anywhere near effective and this has led to the creation of a million and one frameworks all purporting to help with that problem by hiding you from the nitty gritty details so you don't have to worry about then. Of coure that then means you have to then expend a large amount of up-front effort to learn the framework or risk creating a whole other kind of abomination. (Not that this stops a lot of teams skipping that step and funding the consultancy gravy train).

If you're going to work with dung, you may as well build a house with it and that seems to the mentality of the people responsible for looking after the language. Instead of getting rid of the problem (JS itself), the designers are hell belt on adding "useful" features to it so it can catch up with all of the other grown up languages out there. Of course that now means the up-front effort mentioned earlier in this section is increased further because cowboys love new shiny toys to play with and those features are going to get used a lot.

If you're working outside of this minefield, sticking to the basic constructs in the language, using an explicit require system and only using libraries where they're provably going to save a lot of time then JS can be a very productive place to work providing you hold onto the awareness that either most of the code will be thrown away if anything needs changing in the future or you know that you're never going to have to touch the project again.

One of the great things about a language that is effectively a loaded gun with which to shoot yourself is that x


Current position on the curve: *An Unhealthy relationship*

**Clojure**


Current position on the curve: *Lots of things I like, would happily use for data processing*

**Erlang**

Current position on the curve: *Skipped the curve, moved straight to "Sigh, fine then"*

**Haskell**

Current position on the curve: *Very interested, not using it properly yet.*





