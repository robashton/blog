Example: C# vs Javascript/Node vs Clojure vs Erlang vs Haskell
==

**Javascript and Node**

I've always used JS and I've written some pretty cool things in it; for a while the cowboy in me relished the untamed nature of this dynamic and often quite foolish language and to this day the cowboy in me still does. Node is an hilarious technology choice in that as much as it has a nice ethos around modules and a tiny core it is still based on one of the worst languages to ever be unleashed on the masses.


It's funny because JS requires quite a lot of up-front effort to be anywhere near effective and this has led to the creation of a million and one frameworks all purporting to help with that problem by hiding you from the nitty gritty details so you don't have to worry about then. Of coure that then means you have to then expend a large amount of up-front effort to learn the framework or risk creating a whole other kind of abomination. (Not that this stops a lot of teams skipping that step and funding the consultancy gravy train).

If you're going to work with dung, you may as well build a house with it and that seems to the mentality of the people responsible for looking after the language. Instead of getting rid of the problem (JS itself), the designers are hell belt on adding "useful" features to it so it can catch up with all of the other grown up languages out there. Of course that now means the up-front effort mentioned earlier in this section is increased further because cowboys love new shiny toys to play with and those features are going to get used a lot.

If you're working outside of this minefield, sticking to the basic constructs in the language, using an explicit require system and only using libraries where they're provably going to save a lot of time then JS can be a very productive place to work providing you hold onto the awareness that either most of the code will be thrown away if anything needs changing in the future or you know that you're never going to have to touch the project again.

One of the great things about a language that is effectively a loaded gun with which to shoot yourself is that x


Current position on the curve: *An Unhealthy relationship*

**Clojure**


Current position on the curve: *Lots of things I like, would happily use for data processing*

**Erlang**

Current position on the curve: *Skipped the curve, moved straight to "Sigh, fine then"*

**Haskell**

Current position on the curve: *Very interested, not using it properly yet.*





