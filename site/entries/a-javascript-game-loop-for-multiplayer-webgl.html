<html>
  <head>
    <title id="title">A Javascript game loop for multiplayer WebGL</title>
    <link rel="stylesheet" type="text/css" href="/style.css"></link>
    <link href='http://fonts.googleapis.com/css?family=Libre+Baskerville' rel='stylesheet' type='text/css'>
    <link rel="alternate" type="application/atom+xml" href="http://feeds.feedblitz.com/robashton&x=1" title="Rob Ashton's blog" />
    <meta name="Description" content="Rob Ashton's blog and various other things. Javascript, C#, testing, whatever.">
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-11207442-1']);
      _gaq.push(['_setDomainName', 'codeofrob.com']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <a class="subscribe" href="http://feed.codeofrob.com/RobAshton">Subscribe to my blog</a>
    <div id="blog-entry">
      <h1 id="post-title">A Javascript game loop for multiplayer WebGL</h1>
      <h6>Published on <span class="date">2011-3-17</span></h6>
      <div id="post">
		<p>In an aim to build that simple multi-player game (Pong), one of the first things to do to drive the application, is to build a game loop that will drive the rendering and logic.</p>
<p>We <i>were</i> building this at a hack day, so getting this set up was integral so we could split up the work in the team between building a basic renderer, and building the engine for doing all the pong logic (ping, pong, collision, etc ;-))</p>

<h2>First up, a Naive game loop</h2>

<script src="https://gist.github.com/874177.js?file=gistfile1.js"></script>

<p>There is something immediately wrong with this, and if you have ever gone remotely near Javascript you'll see it straight away.

</p><p>Chiefly, this is that you can't have never-ending loops in JS and expect the rest of the page to carry on functioning correctly.</p>

<p>As far as I understand it, Javascript effectively executes on a single UI thread, long-running calls to web services are done asynchronously (with callbacks executing on that single UI thread), and in order to get a loop running we have to fall back to getting a callback executed every time we want the loop to execute.</p>

<h2>Second up, another naive game loop</h2>

<script src="https://gist.github.com/874187.js?file=gistfile1.js"></script>

<p>In this attempt, we are saying "Run this logic 30 times a second", which is much better - as it means we render the scene 30 times a second and effectively execute the logic 30 times a second.</p>

<p>We might choose to stop here, except this is also problematic - as what happens if for _some_ reason on one client renderScene takes longer than a 30th of a second, but on another client it does not?</p>

<p>Poorly performing clients will quickly get out of sync with other clients who haven't got any problems - and in fact if you have any other timers, they might cause these ones to be queued... and well you get the picture. You can't trust that the logic is actually going to be called every 30th of a second.</p>

<p>One solution is to work out how much time has elapsed since the last frame, and use that as a multiplier in the executing logic (distanceTraveled = speed * timeElapsed) - but we can easily see that this would get out of hand in any but the simplest of rendering demos.</p>

<p>Nay, I present to you the loop we actually used in our pong game, this is based pretty much entirely from a post found on the excellent <a href="http://altdevblogaday.org/2011/02/23/ginkgos-game-loop/">AltDevBlogADay site</a></p>

<p>Don't worry if you can't read it easily, as I have a nice simple version of what it sets out to achieve below, in my less naive game loop</p>

<h2>A less naive approach</h2>

<script src="https://gist.github.com/874223.js?file=gistfile1.js"></script>

<p>It's a little bit more complicated, but what's we're essentially doing is de-coupling the execution of our logic from the underlying timer mechanism, by calculating how much time has elapsed since we last tried to run the logic, and then optionally run the logic more than once (or even not at all) if necessary.</p>

<p>We also keep the left over time around, to add to the next tick, so rounding errors don't bother us at all.</p>

<p>What's cool about this, is that we can store how many ticks has elapsed in the entire game, and use this as a universal value for coordinating synchronisation between two player's game states (more about this in the coming entries).</p>

<h2>Game programming 101</h2>
<p>Okay, so what the hell eh? I'm a software developer, not a game programmer, what am I doing writing posts about the most basic of games development topics? </p>

<p>Truth be told, I don't really know yet - but documenting what I've learned as I go along seems natural these days, and it's more interesting than Active Directory, which is what I'm currently learning about in my work hours...</p>

<p>Disclaimer: I'm not a games developer, and the loop above may not be optimal (although it does work!) - use it at your own peril.</p>
	</div>
      <div id="links">
        <a href="/">Index</a>
        <a href="http://feed.codeofrob.com/RobAshton">Subscribe</a>
        <a href="http://twitter.com/robashton">Follow me</a>
      </div>
      <div id="inqob_job_postings"></div> 
      <script type="text/javascript" charset="utf-8">
        var __inqob_settings = {
          email_address:  'robashton@codeofrob.com', 
          token:          '',
          debug: false,
          items: [{
            keyword: 'codeofrob', 
            price: 100 
          }]
        };

        (function(is) {
          var sc = document.createElement('script'); sc.type = 'text/javascript'; sc.async = true;
          var src = (document.location.protocol == 'https:' ? 'https://' : 'http://') + 'inqob.com/get/script';
          var q = [];
          q.push('?t='+ new Date().getTime()); 
          q.push('token=' + is.token); 
          q.push('email_address=' + is.email_address); 
          q.push('href=' + encodeURIComponent(window.location.href));
          sc.src = src + q.join('&');
          var s = document.getElementsByTagName('script')[0]; 
          s.parentNode.insertBefore(sc, s);
        })(__inqob_settings);      
      </script>
      <div id="disqus">
        <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'codeofrob'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div id="post-comments"><div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=95e2b8ef6039d2668114cfb20cf45ae2&size=50&default=identicon"/>
<p>David Padbury</p></div>
<div class="comment-body">
<br/> 				paulirish.com/... ?
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"/>
<p>robashton</p></div>
<div class="comment-body">
<br/> 				Thanks Dave, I haven't seen that.For plain ol' animations that looks useful, but if you were in a multi-player environment (which is what I'm focusing on here), it wouldn't give you your ticks - and tabbing away would leave you in an invalid state on returning. (You'd have to rapidly run all the ticks and logic, or do a big state re-sync on returning to the tab).It could feasibly be used *alongside* a logic loop like this, and you could de-couple rendering and logic ticks even more by having completely separate timers for them both. Then you'd still be running some logic behind the scenes when tabbing away, but not rendering.
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=4a6ae4c1b1752bfc78cb06d3ae4f774b&size=50&default=identicon"/>
<p>Patrik Potocki</p></div>
<div class="comment-body">
<br/> 				Nothing about this post , but your code doesnt show up in ex. google reader
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"/>
<p>Rob Ashton</p></div>
<div class="comment-body">
<br/> 				Yeah - I've switched to using Gists from Github, and that'll unfortunately be a side effect of that. They're much nicer though.
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=2dfe31131d62b675b10d7b02284d5303&size=50&default=identicon"/>
<p>Frank Quednau</p></div>
<div class="comment-body">
<br/> 				www.shacknews.com/.../quake-3-132-source-codeAddmittedly, it's a long stretch from a javascript engine to Quake3, but if somebody knows one or two things about writing decent network code for games it should be idsoftware. As far as I know you are no complete stranger to C++..? :)
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"/>
<p>Rob Ashton</p></div>
<div class="comment-body">
<br/> 				Hah, I think by the time that kind of system gets to release, there is so much micro-optimisation that learning the fundamentals via the code might be a tad difficult.But yeah, I've got the code and I've even looked through it once or twice in the past :-)
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=4b138a56fa1e625a8b59a128519c7b64&size=50&default=identicon"/>
<p>Drew Petersen</p></div>
<div class="comment-body">
<br/> 				Rob, I'm glad to see someone else trying to tackle this extremely complex issue in JS!A few things:1) It might just be because it's a gist and out of context, but you've got some scoping issues in your less naive approach. The "this" inside of the tick method will point at the global scope, and thus this._leftover is really pointing at window._leftover, which is... bad. You're probably aware of this, but it might help others to be more clear, even if the only step is to put everything into a namespace.2) I am dying to know if this solves your problem. It seems to me, as an inexperienced network game-programmer, that this can't solve the synchronization problem on its own. For that, you have to rely on a central server broadcasting state changes, and only rely on the client for input and rendering (and effectively detach rendering from the world state). Otherwise, there's really no way to keep a much slower machine in sync. For example, a computer that can only do 20fps will always be behind in terms of the game's state. Think of that computer trying to shoot another player: it reports, "I shot him!" but when the server attempts to double check the result, the actual state of the world at that moment was further in time than what the slow client saw. You have to deal with computational lag as well at network lag!I've attempted my own version of a game loop (I call it the CGLM), which is in this gist: https://gist.github.com/879814. Maybe it will help, maybe it won't. One thing, my loop is geared towards use with a physics engine. I plan to integrate Paul Irish's snippet into the CGLM when I have some time.
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"/>
<p>robashton</p></div>
<div class="comment-body">
<br/> 				Oh yeah - I stole it from a properly name-spaced version in one of my other projects and didn't think that the code might not match up ;-) - I'll fix it when I get back.Your other question - of course it doesn't answer the whole question, you can't expect all game clients to magically "keep up", and you're going to have to sync the observables from time to time - but what you want is a common language of time from which they can communicate, so you can replay events at the right tick, and talk in terms of both state and actions :-)On the client that only does 20FPS, the logic above will ensure that the actual 'ticks' are still running at 30 ticks per second (catch-up frames), if of course you can't do the actual _logic_ at the desired 30 ticks per second then you can't play the game, at which point there is nothing you can do. That's why games have requirements after all :-)In reality, you'll have all the clients running their logic at 30 ticks per second, and the server running its logic at 30 ticks per second, and the server will distribute the state of observables, overriding the state of the clients (but allowing the clients to then add on any other events since the sync point (measured in ticks).TL;DR - ticks give you a common language for 'time elapsed', it's only half the story.
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="/images/IdenticonHandler.ashx?code=-1517229333"/>
<p>Drew Petersen</p></div>
<div class="comment-body">
<br/> 				But if the logic is too much for the client to handle at 30fps, then it will just spiral out of control for a 20fps client, trying to catch up. Each tick will require more and more catch up ticks and will just beachball the client for longer and longer periods until the browser's limit is reached.I look at a game like world of warcraft. On my old laptop, it would only get 20fps, but was still playable because the rendering and logic were disconnected.Like I said before, my experience has been in physics simulations that are pretty intense for the client, so this might not apply to most games.
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"/>
<p>robashton</p></div>
<div class="comment-body">
<br/> 				That's the point, rendering and logic ARE disconnected this with scenario - if your logic CAN'T be ran at the desired number of ticks per second, then your computer is not good enough.The bottleneck in your WoW game is most likely the rendering, and the logic is being ran using fixed time steps as above so everything remains sane when it does render.
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"/>
<p>robashton</p></div>
<div class="comment-body">
<br/> 				You only have one thread in Javascript, even if you put Rendering in a separate setInterval, you'd still potentially be taking longer than a 30th of a second before your logic was run.When it comes to the physics, and logic - some systems will only run those intensive operations say, 5-10 times a second, and then tween between the positions/logic results - stop talking about frames per second, and think about* The time it takes for a frame to render* The time it takes to run a single step of logicI hope this is clearer.
				</div></div>
</div>
  </body>
</html>
