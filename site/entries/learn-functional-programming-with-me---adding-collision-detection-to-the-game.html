<html>
  <head>
    <title id="title">Learn functional programming with me - adding collision detection to the game</title>
    <link rel="stylesheet" type="text/css" href="/style.css"></link>
    <link href='http://fonts.googleapis.com/css?family=Libre+Baskerville' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'>
    <link rel="alternate" type="application/atom+xml" href="http://feeds.feedblitz.com/robashton&x=1" title="Rob Ashton's blog" />
    <meta name="Description" content="Rob Ashton's blog and various other things. Javascript, C#, testing, whatever.">
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-11207442-1']);
      _gaq.push(['_setDomainName', 'codeofrob.com']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <a class="subscribe" href="http://feed.codeofrob.com/RobAshton">Subscribe to my blog</a>
    <div id="blog-entry">
      <h1 id="post-title">Learn functional programming with me - adding collision detection to the game</h1>
      <h6>Published on <span class="date">2013-5-31</span></h6>
      <div id="post"><p>Can't have a game without collision detection now can we? Let's see about getting our bullets to collide with the enemies and see what problems get in my way this time...</p>

<ul>
<li><a href="/entries/learn-functional-programming-with-me---a-mission-statement.html">Mission statement</a></li>
<li><a href="/entries/learn-functional-programming-with-me---drawing-a-square.html">Drawing a square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---moving-the-square.html">Moving the square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---attributes-and-vectors.html">Attributes and vectors</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-my-workflow.html">Improving my workflow</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-lots-more-state.html">Creating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---mutating-lots-of-state.html">Mutating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-our-data-structure-with-maps.html">Improving our data structure with maps</a></li>
<li><a href="/entries/learn-functional-programming-with-me---keyboard-input-for-our-red-square.html">Moving our red square with keyboard input</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-items-to-a-sequence.html">Adding items to a sequence and firing bullets</a></li>
<li><a href="/entries/learn-functional-programming-with-me---refactoring-my-state-transitions.html">Refactoring my state transitions</a></li>
<li><a href="/learn-functional-programming-with-me---more-idiomatic-clojure.html">More idiomatic clojure</a></li>
</ul>

<p><strong>The collision detection itself</strong></p>

<p>Well, collision is a nice easy pure function to write and because I have my rect primitive I can pretty use these.</p>

<p>My first stab looks like this</p>

<pre><code>(defn collides-with [one two]
  (let [one-left (:x one)
        one-right (+ (:x one) (:w one))
        one-top (:y one)
        one-bottom (+ (:y one) (:h one))
        two-left (:x two)
        two-right (+ (:x two) (:w two))
        two-top (:y two)
        two-bottom (+ (:y two) (:h two))]
    (cond (&lt; one-right two-left) false
          (&gt; one-left two-right) false
          (&lt; one-bottom two-top) false
          (&gt; one-top two-bottom) false
          :else true)))
</code></pre>

<p>I kinda feel as if this is over-doing the point a little though, and those extra variables I've gone and made could probably just be represented by functions.</p>

<pre><code>(defn rect-right [rect] (+ (:x rect) (:w rect)))
(defn rect-bottom [rect] (+ (:y rect) (:h rect)))

(defn collides-with [one two]
    (cond (&lt; (rect-right one) (:x two)) false
          (&gt; (:x one) (rect-right two)) false
          (&lt; (rect-bottom one) (:y two)) false
          (&gt; (:y one) (rect-bottom two)) false
          :else true))
</code></pre>

<p>It's a small change, but if I want to use these concepts elsewhere then I'll be able to far easier and this is far easier on the eyes.</p>

<p><strong>Using the collision detection</strong></p>

<p>Okay so I'm being quite lazy here, the efficient way to do collision detection across a scene is to use a linear hashmap and only test rects in adjacent cells. I only have a few space invaders though so I'll take the hit of a more brute force solution (although I think this would be quite fun to implement in a functional manner so I'll come back to it)</p>

<p>So, obviously I need to adjust my sequences based on whether bullets are intersecting with aliens.</p>

<p>This is probably the complicated bit, and I'll start off being really lazy about how I evaluate this.</p>

<ul>
<li>We need to remove bullets from the collection if they're intersecting</li>
<li>We need to remove aliens from the collection if they're intersecting</li>
<li><em>in the future we'd need to increase points</em></li>
<li><em>in the future we'd need to show some animation</em></li>
</ul>

<p>I'm getting the feeling that doing all of this with my ball of state is going to get un-wieldy and I might want to look into something more functional <a href="http://prog21.dadgum.com/23.html">like in this series</a>.</p>

<p>Nevertheless, I'll press forwards with my current solution because I want something that works.</p>

<p><strong>My first attempt</strong></p>

<p>My first attempt was a failure, I thought it'd be simple to just loop through several times and do something like</p>

<pre><code>(defn bullet-collides-with-enemy [bullet state]
  (not (not-any? 
     (fn [enemy] (collides-with enemy bullet)) 
     (:enemies state))))

(defn enemy-collides-with-bullet [enemy state]
  (not (not-any? 
     (fn [bullet] (collides-with bullet enemy)) 
     (get-in [:bullets :active] state))))
</code></pre>

<p>And filter out enemies/bullets in the seq for these things, this is an awful idea because of multiple iterations it's also an awful idea because written in this way it's hard to follow.</p>

<p><strong>Second attempt</strong></p>

<p>A better idea would be to iterate once, ask for all the colliisons that have taken place and then use this information to create a new version of the state without the affected enemies/bullets in it.</p>

<p>This moves me closer in the direction described by the article I linked above so I'll give it a go.</p>

<p>I can write a function that does this and returns a list of the collisions.</p>

<pre><code>(defn get-bullet-enemy-collisions [state]
  (for [bullet (active-bullets state)]
    { :bullet bullet
      :alien (first (enemies-colliding-with-bullet bullet state))}))
</code></pre>

<p>But this won't actually be effective I don't think, because I'm returning a map of maps which would need comparing against the other maps in order to remove them from the collection they're in.</p>

<p>By-reference comparison won't work, maps are (as I understand it) compared by value - and while this would work it's not "correct". Identity is what we want to compare against here and our bullets and aliens don't have identies.</p>

<p><strong>Third attempt</strong></p>

<p>I've found <a href="http://clojuredocs.org/clojure_core/clojure.core/map-indexed">map-indexed</a> and <a href="http://clojuredocs.org/clojure_core/clojure.core/keep-indexed">keep-indexed</a>, which will allow me to do pretty much the same as above but return a list of indexes into the collections which represent collisions.</p>

<pre><code>(defn get-bullet-enemy-collisions [state]
  (keep-indexed #({ :bullet %1
                    :alien (first (enemies-colliding-with-bullet bullet state))})
                (active-bullets state)))

(defn enemies-colliding-with-bullet [bullet state]
  (keep-indexed #(if (collides-with %2 bullet) %1) (:enemies state)))
</code></pre>

<p>I've also discovered that little # symbol, which appears to be shorthand for an anonymous function with a 1-indexed list of arguments.</p>

<p>Anyway, now I have a list of collisions that have taken place in my game world, I can filter out the items I don't want any more.</p>

<p>I couldn't figure out an easy way of using this data though, so back to</p>

<p><strong>Option one again</strong></p>

<pre><code>(defn collide-bullets [state]
  (assoc 
    (assoc-in state [:bullets :active]
      (remove #(collides-with-any % (:enemies state)) (active-bullets state)))
    :enemies
      (remove #(collides-with-any % (active-bullets state)) (:enemies state))))

(defn collides-with-any [one, others]
  (some #(collides-with % one) others))
</code></pre>

<p>Iterate through the list twice and just remove any affected entities.</p>

<p>Note I can use the old verson of the state when doing my <em>collides-with-any</em> calls, and stick the results into multiple calls on top of the new state. This is much easier to understand than my first attempt however so at least doesn't have the pitfall of being completely opaque.</p>

<p>I'm still really not liking this solution as it involves multiple iterations of the two collections:</p>

<ul>
<li>Compare each bullet against all the enemies</li>
<li>Compare each enemy against all the bullets</li>
</ul>

<p>I'll come back to this no doubt when it comes to adding scoring, explosions and sound, because I'm going to need to execute a lot more logic based on these collisions.</p>

<p>I'm going to press on and add some more gameplay though, as once I have an end-to-end game I'll hopefully have gained more understanding and be able to reason about all of this better.</p></div>
      <div id="links">
        <a href="/">Index</a>
        <a href="http://feed.codeofrob.com/RobAshton">Subscribe</a>
        <a href="http://twitter.com/robashton">Follow me</a>
      </div>
      <div id="disqus">
        <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'codeofrob'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div id="post-comments">

    </div>
  </body>
</html>
