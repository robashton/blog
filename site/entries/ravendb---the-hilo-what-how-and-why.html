<html>
  <head>
    <title id="title">RavenDB - The HiLo what how and why</title>
    <link rel="stylesheet" type="text/css" href="/style.css"></link>
    <link href='http://fonts.googleapis.com/css?family=Libre+Baskerville' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'>
    <link rel="alternate" type="application/atom+xml" href="http://feeds.feedblitz.com/robashton&x=1" title="Rob Ashton's blog" />
    <meta name="Description" content="Rob Ashton's blog and various other things. Javascript, C#, testing, whatever.">
    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="/post.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-11207442-1']);
      _gaq.push(['_setDomainName', 'codeofrob.com']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <a class="subscribe" href="http://feed.codeofrob.com/RobAshton">Subscribe to my blog</a>
    <div id="blog-entry">
      <h1 id="post-title">RavenDB - The HiLo what how and why</h1>
      <h6>Published on <span class="date">2010-5-16</span></h6>
      <div id="post">
		<p>One of the issues I touched on in with the <a href="http://codeofrob.com/archive/2010/05/12/ravendb-basic-usage-considerations.aspx">basic interaction with RavenDB</a> was the awkwardness of with having to call SaveChanges in order to get the ids of entities that had been saved across the unit of work. This is not a problem new to the document db space, nor is it a problem new to any system where the domain has been mapped to any id based data store (ORMs/RDBMS/etc).</p>  <p>I was going to cook a home brew solution specifically for my use within my projects and blog about it in order that other people could use it, but after posting my intentions in the <strong>RavenDB</strong> mailing list to create something like this, Oren suggested that making it the default behaviour and moving id generation to the Store would be a welcome move.</p>  <p>After posting on Twitter about this now being default, I got asked quite a few questions on what HiLo was, what the advantages were, and why it was a good thing that in the .NET client for RavenDB this was now going to be the default.</p>  <p><strong>The gist</strong></p>  <ul>   <li>Waiting until SaveChanges to get ids for saved entities makes writing logic against those entities troublesome</li>    <li>Calling SaveChanges every time a new entity is created makes transactions troublesome</li>    <li>Calling SaveChanges to get the entity id means a call across the wire just to get an entity id, which is expensive</li>    <li>Simply assigning a Guid to the Id makes accessing documents via REST an unpleasant experience</li>    <li>You can’t just assign a random integer, because you’d just get collisions as other clients did the same and tried to save their entities</li>    <li>HiLo provides a method of creating *<strong>incremental</strong>* integer based ids for entities in a fashion that is safe in concurrent environments</li> </ul>  <p><strong>The algorithm</strong></p>  <p>The basic premise, is that the server still controls the id generation, but effectively hands out a range of ids to each client, which the client can then hand out to objects as they are created, and when the client runs out of ids, it simply requests more.</p>  <p>Obviously, requesting a heap of Ids all at the same time would be expensive, so the idea is that the server provides a single id, a “Hi” value which controls the creation of the range on the client. (which provides the “Lo” value)</p>  <p>There are a number of ways this can be implemented, but the one I chose was probably the simplest, and credit goes to <a href="http://devlicio.us/blogs/tuna_toksoz/archive/2009/05/18/id-generation-for-db4o.aspx">Tuna Toksoz</a> for the blog entry which provided the means to implementing it myself.</p>  <ul>   <li>The data store needs only store the latest “Hi” value, which starts at 1, and increases by 1 every time a new “Hi” value is requested by a client</li>    <li>The clients all use the same number for a “Capacity”, that is – the range of numbers that each “Hi” value represents. For example 1000</li>    <li>Each client requests a “Hi” value and resets their “Lo” value to 0</li>    <li>Every time a new Id is requested from the generator, the Id is generated by combining the Hi and Lo numbers together:</li> </ul>  <div class="csharpcode">   <pre class="alt"><span class="lnum">   1:  </span>(currentHi - 1)*capacity + (++currentLo)</pre>
</div>

<div class="csharpcode">
  <ul>
    <li>
      <p>When currentLo reaches capacity, a new Hi is requested and the cycle starts over again</p>
    </li>
  </ul>
</div>

<p>In the actual implementation, there is some locking going on around this algorithm in order to make the client generator available across threads (web requests) and avoid having to create a new generator per session (defeating the point of having one if you only create a single object in a session).</p>

<p>Let’s look at a sample run through, with a small capacity of “3”, to keep the sample small!</p>

<table border="1" cellspacing="0" cellpadding="2" width="500"><tbody>
    <tr>
      <td valign="top" width="98"><strong>Description</strong></td>

      <td valign="top" width="127">currentLoBefore</td>

      <td valign="top" width="89">currentHi</td>

      <td valign="top" width="82"><strong>Created Id</strong></td>

      <td valign="top" width="102">currentLoAfter</td>
    </tr>

    <tr>
      <td valign="top" width="97">Hi Request</td>

      <td valign="top" width="126">0</td>

      <td valign="top" width="88">1</td>

      <td valign="top" width="81">1</td>

      <td valign="top" width="105">1</td>
    </tr>

    <tr>
      <td valign="top" width="97">&nbsp;</td>

      <td valign="top" width="126">1</td>

      <td valign="top" width="88">1</td>

      <td valign="top" width="81">2</td>

      <td valign="top" width="106">2</td>
    </tr>

    <tr>
      <td valign="top" width="97">&nbsp;</td>

      <td valign="top" width="126">2</td>

      <td valign="top" width="88">1</td>

      <td valign="top" width="81">3</td>

      <td valign="top" width="106">3 (capacity)</td>
    </tr>

    <tr>
      <td valign="top" width="97">Hi Request</td>

      <td valign="top" width="126">0</td>

      <td valign="top" width="88">2</td>

      <td valign="top" width="81">4</td>

      <td valign="top" width="106">1</td>
    </tr>

    <tr>
      <td valign="top" width="97">&nbsp;</td>

      <td valign="top" width="126">1</td>

      <td valign="top" width="88">2</td>

      <td valign="top" width="81">5</td>

      <td valign="top" width="106">2</td>
    </tr>

    <tr>
      <td valign="top" width="97">&nbsp;</td>

      <td valign="top" width="126">2</td>

      <td valign="top" width="88">2</td>

      <td valign="top" width="81">6</td>

      <td valign="top" width="106">3 (capacity)</td>
    </tr>
  </tbody></table>

<p>As we can see, if all the clients are using the same capacity, and they are given different “Hi” values, then they can’t generate duplicate keys, but by and large they’ll be sequential in nature.</p>

<p><strong>The implementation in RavenDB</strong></p>

<p>In RavenDB, the default function configured against the DocumentConvention is now HiLo, which means if a new document is saved against the session with its Id set to NULL, it will have an Id generated on the spot which contains the name of the document and the incremented Id. Obviously this can be overridden by changing the convention to leave the created id at some default value of your application’s choosing.</p>

<p>My original implementation was a bit poor, generating quite a bit of noise in the document database (it was inserting documents to get the ids), and the incremented Ids were being shared amongst objects – which meant if you created say, blogentry/1, saving a new user would mean having newuser/2. </p>

<p>Oren changed this to directly store a single object in the RavenDB for the generator, and to create a generator per-type – which means a lot less noise and more sensible ids being generated for each document.</p>

<p><strong>What it means</strong></p>

<p>What this essentially means, is if you’re using RavenDB out of the box without changing any of the conventions, documents will have a generated Id as soon as Store is called for that document. This means that SaveChanges does not have to be called until right at the very end of the Unit of Work, which means all changes can be efficiently batched in a single request and as a result applications should be easier to write and performance should be easier to maintain.</p>

<p>This is a .NET client specific feature and nothing was changed in the database itself to make this work.</p>

<p>What this <em>does</em> mean, is that if multiple clients from different platforms are going to be connecting to RavenDB and manipulating data, if you’re using the default HiLo implementation then a similar algorithm will need implementing for those other platforms, using the same capacity in order to prevent concurrency issues. This is not necessarily a downside, but is worth making a note of if you are going to be having this sort of set up.</p>

<p><strong>What I learned</strong></p>

<p>While I might contribute the odd bug fix to open source projects now and then, the idea of going in and changing the fundamental way the .NET RavenDB client worked was a bit daunting – not from a technical perspective, but from a taste perspective as I wasn’t sure how Oren wanted things done. As he later said, he’d prefer that code that has to then change be submitted, then no code at all be submitted. I’d like to raise that with anybody who wants to contribute to this project – if you’ve got a good idea then hit the mailing list and suggest it and maybe implement it – nothing to be lost if it’s something people want to use.</p>

<p>In the end, my implementation is barely visible in there, but I'm still pleased that this is in there, it makes *my* life easier :)</p>
	</div>
      <div id="links">
        <a href="/">Index</a>
        <a href="http://feed.codeofrob.com/RobAshton">Subscribe</a>
        <a href="http://twitter.com/robashton">Follow me</a>
      </div>
      <div id="disqus">
        <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'codeofrob'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </div>
    <div id="post-comments"><div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=1512a77d029f5a599b9b973ccd3cba35&size=50&default=identicon"/>
<p>Sean</p></div>
<div class="comment-body">
<br/> 				When using hilo myself, I found it worked better if I implimented the hi by eg 1000 and then getting a new id with (currentHi) + (++currentLo)That lets you change the capacity client side without problems.  It also simplified getting a new id inside sql server stored procs.
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"/>
<p>robashton</p></div>
<div class="comment-body">
<br/> 				Surely that means the client still needs to be aware of the capacity (because they'd still be able to go past capacity if it was changed on the server).Either way it's brittle if you're not in control of the whole system - but if you're writing a proper system then only one client will access the database (ideally), and everything else will go through that client so it doesn't matter.
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=1ce13c7f1c1396fcadc5de5bc390d066&size=50&default=identicon"/>
<p>Ken Egozi</p></div>
<div class="comment-body">
<br/> 				@rob: proper system =&rt; only one client?with large, complex systems, you can easily find a mix of technologies. Like RoR front-end, erlang based chat server, .NET logic engine, and Java based batch processing. One of the things that can make RavenDB appeal would be a consistent set of clients for major environments. For e.g., I like that with MongoDB you get official server build for every possible type of host (irrelevant with RavenDB as it is dependant on ESENT afaik), and a large list of consistent client APIs. 
				</div></div>
<div class="comment">
<div class="comment-author">
<img src="http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"/>
<p>robashton</p></div>
<div class="comment-body">
<br/> 				Sure - but most architects would balk at the idea of letting all those things go directly to the database. Instead, the main application would most likely expose services which these would go to.Even if you weren't to do that (Because let's face it, RavenDB exposes the ability to load logic directly into it *and* exposes REST services so why *not* go directly to it), the fact remains that with any client-id assignation system you're going to have to standardise how and when those clients generate those ids and it doesn't matter which variant of the HiLo algorithm you use :)
				</div></div>
</div>
  </body>
</html>
