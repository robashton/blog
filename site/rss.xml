<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>RSS for Node</generator><lastBuildDate>Wed, 01 Jul 2020 13:58:59 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><author><![CDATA[Rob Ashton]]></author><item><title><![CDATA[Purerl updates - Typed routes in Stetson]]></title><description><![CDATA[<p>A continuation of progress updates on Pinto/Stetson then..</p>
<h1 id="previous-purerl-posts">Previous Purerl posts</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="updates">Updates</h1>
<ul>
<li><a href="/entries/updates-to-pinto+stetson---purerl-in-progress.html">Nix overlays for Purerl/etc</a></li>
<li>Typed routing for Stetson</li>
<li>Emitter based messages for handle_info in Gen Server</li>
<li>Monitors for arbitrary pids from Gen servers + Stetson handlers</li>
<li>WebSocket handlers in Stetson</li>
<li>Streaming handlers in Stetson</li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<h1 id="how-it-was">How it was</h1>
<p>The initial blast of <a href="https://github.com/id3as/purescript-erl-stetson">Stetson</a> was thrown up around <a href="https://github.com/ninenines/cowboy">Cowboy</a> with the express goal of &quot;getting me started on our first client project written in Purerl&quot;. As such it wasn&#39;t fancy and routing/dispatch looked like this.</p>
<pre><code class="language-haskell">
<span class="hljs-type">Stetson</span>.configure
    # <span class="hljs-type">Stetson</span>.route <span class="hljs-string">"/api/books"</span> books
    # <span class="hljs-type">Stetson</span>.route <span class="hljs-string">"/api/books/:isbn"</span> book
    # <span class="hljs-type">Stetson</span>.static <span class="hljs-string">"/assets/[...]"</span> (<span class="hljs-type">PrivDir</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/assets"</span>)
    # <span class="hljs-type">Stetson</span>.static <span class="hljs-string">"/[...]"</span> (<span class="hljs-type">PrivFile</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/index.html"</span>)
</code></pre>
<p>Where a handler operating over  &#39;id&#39; to get a specific item might look like this</p>
<pre><code class="language-haskell">
<span class="hljs-title">book</span> :: <span class="hljs-type">StetsonHandler</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">book</span> = 
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-keyword">do</span>
                          <span class="hljs-keyword">let</span> id = binding (atom <span class="hljs-string">"isbn"</span>) req
                          book &lt;- maybe (pure <span class="hljs-type">Nothing</span>) <span class="hljs-type">BookLibrary</span>.findByIsbn id
                          <span class="hljs-type">Rest</span>.initResult req book)
    # <span class="hljs-type">Rest</span>.allowedMethods (\req state -&gt; <span class="hljs-type">Rest</span>.result (<span class="hljs-type">Stetson</span>.<span class="hljs-type">HEAD</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">PUT</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">DELETE</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">GET</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">OPTIONS</span> : nil) req state)
    # <span class="hljs-type">Rest</span>.resourceExists (\req state -&gt; 
                             <span class="hljs-type">Rest</span>.result (isJust state) 
                             (maybe (setBody <span class="hljs-string">"This book does not exist"</span> req) (\_ -&gt; req) state)
                             state)
    # <span class="hljs-type">Rest</span>.deleteResource (\req state -&gt; <span class="hljs-keyword">do</span>
                              _ &lt;- maybe (pure unit) (\book -&gt; <span class="hljs-type">BookLibrary</span>.delete book.isbn) state
                              <span class="hljs-type">Rest</span>.result true req state)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (jsonWriter : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesAccepted (\req state -&gt; <span class="hljs-type">Rest</span>.result ((tuple2 <span class="hljs-string">"application/json"</span> acceptJson) : nil) req state)
</code></pre>
<p>Urgh, so we&#39;ve got <em>:isbn</em> as a binding in our route, which we&#39;re pulling out as a <em>Maybe String</em> in our init handler, more hand waving here than at a Tory party conference. To compound matters, our client is building these urls like so</p>
<pre><code class="language-haskell">
<span class="hljs-title">getBook</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>
<span class="hljs-title">getBook</span> id = fetchJson <span class="hljs-string">"/api/books/"</span> &lt;&gt; id
</code></pre>
<p>This was fine for a year or so, but once you&#39;ve got a few real applications running on top of this stuff and a great many URLs indeed you start running into issues where typos, incorrect types, etc start rearing their head - especially if you&#39;re making changes. (Quiet down at the back if you mention rest, url discovery and client independence to me I&#39;ll throw something at you, this isn&#39;t that).</p>
<p>Thankfully, we have <a href="http://twitter.com/nwolverson">nwolverson</a> working with us and he&#39;s unafraid of the wonders of <a href="https://pursuit.purerl.fun/packages/typelevel-prelude/3.0.0/docs/Type.Data.Symbol">Data.Symbol.SProxy</a> and spent a chunk of time re-working <a href="https://github.com/natefaubion/purescript-routing-duplex">routing-duplex</a> from the client world so that it compiles/works/is-usable in the world of Purerl and Stetson.  Did I ever mention that the great thing about re-purposing an existing language/toolset for Erlang is that code already exists for most things you&#39;d want to do in that language? I&#39;ll mention it again here because it&#39;s pretty great.</p>
<p>Gone is the hand-waving, for our apps now have a shared module twixt client and server describing the routes available and the types they accept and no mistakes will be accepted by the compiler.</p>
<p><em>Our routes</em></p>
<p>Our routes exist as an ADT describing the various  options and the typed parameters they expect.</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Route</span></span>
  = <span class="hljs-type">Books</span>
  | <span class="hljs-type">Book</span> <span class="hljs-type">Isbn</span>
  | <span class="hljs-type">Assets</span> (<span class="hljs-type">Array</span> <span class="hljs-type">String</span>)
  | <span class="hljs-type">Index</span>
  | <span class="hljs-type">Index2</span> <span class="hljs-type">String</span> (<span class="hljs-type">Array</span> <span class="hljs-type">String</span>)
</code></pre>
<p><em>How the routes map to paths</em></p>
<p>Using the type RouteDuplex&#39; with this ADT, we are required  to fill out each of the options with a path with the args expected  in the ADT. None  of these  are optional and we&#39;ll get type errors (more on this in a bit) if we don&#39;t supply all of the args or routes expected.</p>
<pre><code>
-- | This combinator transforms <span class="hljs-literal">a</span> codec over `String` into one that operates on the `Isbn` type.
<span class="hljs-symbol">isbn ::</span> RouteDuplex' String -&gt; RouteDuplex' Isbn
isbn = asNewtype

<span class="hljs-symbol">apiRoute ::</span> RouteDuplex' Route
apiRoute = path <span class="hljs-string">""</span> $ sum
  { <span class="hljs-string">"Books"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"books"</span> / noArgs
  , <span class="hljs-string">"Book"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"books"</span> / isbn segment
  , <span class="hljs-string">"EventsWs"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"events"</span> / <span class="hljs-string">"ws"</span>
  , <span class="hljs-string">"EventsFirehose"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"events"</span> / <span class="hljs-string">"firehose"</span>
  , <span class="hljs-string">"Assets"</span> : <span class="hljs-string">"assets"</span> / rest
  , <span class="hljs-string">"Index"</span> : noArgs
  , <span class="hljs-string">"Index2"</span> : segment / rest
  }

</code></pre><p>Note that our Newtype &#39;isbn&#39; is an integrated part of both of these APIs, <em>Book</em> is a route that is available over <em>api/books/:isbn</em> where <em>:isbn</em> is of type <em>Isbn</em>. No messing around; yes it&#39;s just a newtype in this case, but there is nothing stopping us doing more elaborate parsing here into more complicated types. We can&#39;t accidentally miss any routes off, those strings are checked against the record at compile type thanks to the magic of SProxy and such.</p>
<p><em>On the server</em></p>
<p>Rather than try and make this stuff optional in Stetson, we decided to just lump it in as core code - why would you choose strings with more strings and hand waving when you&#39;ve got types at your disposal? We&#39;re not Javascript programmers after all - this means that these routes are accepted as a first class citizen in this world.</p>
<pre><code class="language-haskell">
<span class="hljs-title">_</span> &lt;- <span class="hljs-type">Stetson</span>.configure
    # <span class="hljs-type">Stetson</span>.routes
      <span class="hljs-type">Routes</span>.apiRoute {
          <span class="hljs-string">"Book"</span>: book
        , <span class="hljs-string">"Books"</span>: books
        , <span class="hljs-string">"EventsWs"</span>: eventsWs
        , <span class="hljs-string">"EventsFirehose"</span>: eventsFirehose
        , <span class="hljs-string">"Assets"</span>: <span class="hljs-type">PrivDir</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/assets"</span>
        , <span class="hljs-string">"Index"</span>: <span class="hljs-type">PrivFile</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/index.html"</span>
        , <span class="hljs-string">"Index2"</span>: (\(_ :: <span class="hljs-type">String</span>)  -&gt; <span class="hljs-type">PrivFile</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/index.html"</span>)
      }

</code></pre>
<p>We can see here that once again we are supplying a record with the names from the ADT and these are once again type-checked against that ADT so you can&#39;t miss any out or get the types wrong. What types you ask? Well this is the &#39;book&#39; handler from earlier. (If you&#39;re not familiar with Purescript you might see the strings in our record above and go &#39;whaaaaa??&#39;, don&#39;t worry about it; because of the ADT &#39;Route&#39; and the fact that our &#39;RoutingDuplex&#39; has that as a type parameter, these strings are checked at a compile time against that ADT - it&#39;s a neat feature that has great potential when API building.</p>
<pre><code class="language-haskell">

<span class="hljs-title">book</span> :: <span class="hljs-type">Isbn</span> -&gt; <span class="hljs-type">StetsonHandler</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">book</span> id =
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-keyword">do</span>
                          book &lt;- <span class="hljs-type">BookLibrary</span>.findByIsbn id
                          <span class="hljs-type">Rest</span>.initResult req book)
    # <span class="hljs-type">Rest</span>.allowedMethods (\req state -&gt; <span class="hljs-type">Rest</span>.result (<span class="hljs-type">Stetson</span>.<span class="hljs-type">HEAD</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">PUT</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">DELETE</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">GET</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">OPTIONS</span> : nil) req state)
    # <span class="hljs-type">Rest</span>.resourceExists (\req state -&gt;
                             <span class="hljs-type">Rest</span>.result (isJust state)
                             (maybe (setBody <span class="hljs-string">"This book does not exist"</span> req) (\_ -&gt; req) state)
                             state)
    # <span class="hljs-type">Rest</span>.deleteResource (\req state -&gt; <span class="hljs-keyword">do</span>
                              _ &lt;- maybe (pure unit) (\book -&gt; <span class="hljs-type">BookLibrary</span>.delete book.isbn) state
                              <span class="hljs-type">Rest</span>.result true req state)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (jsonWriter : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesAccepted (\req state -&gt; <span class="hljs-type">Rest</span>.result ((tuple2 <span class="hljs-string">"application/json"</span> acceptJson) : nil) req state)
</code></pre>
<p>Say what now? Because we define</p>
<pre><code class="language-haskell">
  | <span class="hljs-type">Book</span> <span class="hljs-type">Isbn</span>
</code></pre>
<p>in our Routes ADT, we have </p>
<pre><code class="language-haskell">
  , <span class="hljs-string">"Book"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"books"</span> / isbn segment
</code></pre>
<p>in our RouteDuplex definition, and we have</p>
<pre><code class="language-haskell">
  <span class="hljs-string">"Book"</span>: book
</code></pre>
<p>In our Stetson routes, the compiler knows that &#39;book&#39; needs to be a function that accepts an &#39;Isbn&#39; and returns a StetsonHandler. So what if I change the type of &#39;book&#39; to integer? to integer? to integer? to integer?</p>
<pre><code class="language-haskell">  book :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">StetsonHandler</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
  book id =</code></pre>
<pre><code><span class="hljs-builtin-name">Error</span> found:
<span class="hljs-keyword">in</span> module BookWeb
at src/BookWeb.purs:122:58 - 122:60 (line 122, column 58 - line 122, column 60)

  Could <span class="hljs-keyword">not</span> match<span class="hljs-built_in"> type
</span>
    Int

  with<span class="hljs-built_in"> type
</span>
    Isbn
</code></pre><p>hot damn yes, and what if I do a typo in my handlers?</p>
<pre><code class="language-haskell">
      <span class="hljs-type">Routes</span>.apiRoute {
          <span class="hljs-string">"B00k"</span>: book
        , <span class="hljs-string">"Books"</span>: books
        , <span class="hljs-string">"EventsWs"</span>: eventsWs
</code></pre>
<p>Well</p>
<pre><code>
  Could <span class="hljs-keyword">not</span> match<span class="hljs-built_in"> type
</span>
    ( <span class="hljs-string">"Book"</span> :: t0
    <span class="hljs-built_in">..</span>.
    | t1
    )

  with<span class="hljs-built_in"> type
</span>
    ( <span class="hljs-string">"Assets"</span> :: StaticAssetLocation
    , <span class="hljs-string">"B00k"</span> :: Isbn -&gt; StetsonHandler Unit (Maybe <span class="hljs-built_in">..</span>.)
</code></pre><p>You get the picture, by up-front defining the routes and the types they expect as input to the handler functions, we&#39;ve just done away with the handwaving and given ourselves a pile of safety.</p>
<p><em>On the client</em></p>
<p>Remember our <em>getBook :: String -&gt; Maybe Book</em>? </p>
<pre><code class="language-haskell">
<span class="hljs-title">routeUrl</span> :: <span class="hljs-type">Route</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">routeUrl</span> = <span class="hljs-type">RouteDuplex</span>.print apiRoute

<span class="hljs-title">getBook</span> :: <span class="hljs-type">Isbn</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>
<span class="hljs-title">getBook</span> id = fetchJson $ routeUrl (<span class="hljs-type">Book</span> id)
</code></pre>
<p>No more strings, no more guessing, thanks Nick!</p>
]]></description><link>http://codeofrob.com/entries/purerl-updates---typed-routes-in-stetson.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl-updates---typed-routes-in-stetson.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 30 Jun 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Updates to Pinto+Stetson - Purerl In Progress]]></title><description><![CDATA[<p>Whew, a lot of things have happened over the last year and nearly all of it in private Github repos for work as we carry on doing &quot;everything&quot; in Purerl.</p>
<p>These posts are a reminder of where we were last time we poked our heads over the parapet, although some of their content is now a tad out of date the demo code they link to is thankfully updated (I&#39;ve been busy).</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<p>So what has changed?  </p>
<ul>
<li>Nix overlays for Purerl/etc</li>
<li>Typed routing for Stetson</li>
<li>Emitter based messages for handle_info in Gen Server</li>
<li>Monitors for arbitrary pids from Gen servers + Stetson handlers</li>
<li>WebSocket handlers in Stetson</li>
<li>Streaming handlers in Stetson</li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<p>Some of these things existed in one form or another last year, indeed it is hard to write a substantial amount of Erlang without requiring them, however as we started building more and more critical functionality on top of Purerl, the warts in the existing implementations started becoming apparent and eventually needed dealing with.</p>
<p>The advantage to eating our own dog food is that we have a lot of mouths to feed and the dog food needs to taste good if we&#39;re to keep on going with it.</p>
<p>For those that are super keen, the updated demo code can be found <a href="https://github.com/id3as/demo-ps">here</a> for perusal, for those who want an explanation, the following blog posts will cover them, for now  I&#39;ll quickly cover the various nix packages that are available for us about the place and the tools we are currently using to do our builds.</p>
<h1 id="nix-packages--development-stack">Nix Packages + Development Stack</h1>
<p>The demo-ps project has been &#39;nixified&#39;, with a <a href="https://nixos.org/download.html">nix-shell</a> and <a href="https://direnv.net/">direnv</a> or similar, a fully operational development environment will appear (and yes it works on MacOS).</p>
<p>Our entry point can be found <a href="https://github.com/id3as/demo-ps/blob/master/env/common/shell.nix">here</a>, dumped below for convenience.</p>
<pre><code><span class="hljs-keyword">let</span>
  <span class="hljs-attr">erlangReleases</span> = <span class="hljs-built_in">builtins</span>.fetchTarball https://github.com/nixerl/nixpkgs-nixerl/archive/v1.<span class="hljs-number">0.4</span>-devel.tar.gz;

  <span class="hljs-attr">pinnedNix</span> =
    <span class="hljs-built_in">builtins</span>.fetchGit {
      <span class="hljs-attr">name</span> = <span class="hljs-string">"nixpkgs-pinned"</span>;
      <span class="hljs-attr">url</span> = <span class="hljs-string">"https://github.com/NixOS/nixpkgs.git"</span>;
      <span class="hljs-attr">rev</span> = <span class="hljs-string">"cc6cf0a96a627e678ffc996a8f9d1416200d6c81"</span>;
    };

  <span class="hljs-attr">pursPackages</span> =
    <span class="hljs-built_in">builtins</span>.fetchGit {
      <span class="hljs-attr">name</span> = <span class="hljs-string">"purerl-packages"</span>;
      <span class="hljs-attr">url</span> = <span class="hljs-string">"git@github.com:purerl/nixpkgs-purerl.git"</span>;
      <span class="hljs-attr">rev</span> = <span class="hljs-string">"5da0a433bcefe607e0bd182b79b220af980a4c78"</span>;
    };


  <span class="hljs-attr">nixpkgs</span> =
    <span class="hljs-built_in">import</span> pinnedNix {
      <span class="hljs-attr">overlays</span> = [
        (<span class="hljs-built_in">import</span> erlangReleases)
        (<span class="hljs-built_in">import</span> pursPackages)
        (<span class="hljs-built_in">import</span> ./.)
      ];
    };

  <span class="hljs-keyword">inherit</span> (nixpkgs.stdenv.lib) optionals;
  <span class="hljs-keyword">inherit</span> (nixpkgs)stdenv;
<span class="hljs-keyword">in</span>

<span class="hljs-keyword">with</span> nixpkgs;

mkShell {
  <span class="hljs-attr">buildInputs</span> = <span class="hljs-keyword">with</span> pkgs; [

    nixerl.erlang-<span class="hljs-number">22</span>-<span class="hljs-number">3</span>.erlang
    nixerl.erlang-<span class="hljs-number">22</span>-<span class="hljs-number">3</span>.rebar3

    purerl.purerl-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">5</span>

    demo_ps.purescript-<span class="hljs-number">0</span>-<span class="hljs-number">13</span>-<span class="hljs-number">6</span>
    demo_ps.spago-<span class="hljs-number">0</span>-<span class="hljs-number">12</span>-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>
    demo_ps.dhall-json-<span class="hljs-number">1</span>-<span class="hljs-number">5</span>-<span class="hljs-number">0</span>
   ];
}</code></pre><p><a href="https://github.com/nixerl/nixpkgs-nixerl">nixerl/nixpkgs-nixerl</a> is maintained  by <a href="http://twitter.com/philipstears">@philipstears</a>, <a href="https://github.com/purerl/nixpkgs-purerl">purerl/nixpkgs-purerl</a> is maintained by the purerl org (<a href="http://twitter.com/nwolverson">nick</a>) - the demo-ps project itself  provides some  overlays for purescript/spago/dhall because we want specific versions of them.</p>
<p>I strongly recommend investigating Nix for development workflows based on the last year or so of using it in earnest as a team, we have built our own internal packages for native/shared dependencies across our projects and have started  looking into using it to aid in our deployment as well. It is not without its pain points (it&#39;s a lot easier if you just run Nixos like half the team), but it has made managing our dependencies a lot easier. As a way of getting a sensible Purerl development environment up and running it&#39;s probably the easiest avenue.</p>
<p>We&#39;ve pretty much set ourselves on using</p>
<ul>
<li>dhall-json for our package sets</li>
<li>Spago for building</li>
<li>Purescript is the main compiler</li>
<li>Purerl is the backend for the compiler</li>
<li>Rebar3 is the build engine for our Erlang projects</li>
<li>Erlang is the compiler/VM for... well, Erlang</li>
</ul>
<p>Getting all of these installed is probably a journey that is going to be differ wildly depending on the host OS and Nix at least gets that solved for us.</p>
<h1 id="dhall">Dhall</h1>
<p>There are two dhall files per Purescript project at the moment, there is packages.dhall which describes the package set we are using to pull packages, and then spago.dhall which describes which packaages from that package set we want to use.</p>
<p>At the time of writing, our package set looks like this</p>
<pre><code><span class="hljs-keyword">let</span> <span class="hljs-attr">upstream</span> = https://github.com/purerl/package-sets/releases/download/erl-<span class="hljs-number">0.13</span>.<span class="hljs-number">6</span>-<span class="hljs-number">20200402</span>/packages.dhall sha256:<span class="hljs-number">5442</span>e50aa76c20bd60b2770ab41c68bae80f6ec96f2df1cfaea310673de567d1

<span class="hljs-keyword">let</span> <span class="hljs-attr">overrides</span> =
      { <span class="hljs-attr">erl-cowboy</span> =
          { <span class="hljs-attr">dependencies</span> = [ <span class="hljs-string">"erl-modules"</span> ]
          , <span class="hljs-attr">repo</span> = <span class="hljs-string">"https://github.com/id3as/purescript-erl-cowboy.git"</span>
          , <span class="hljs-attr">version</span> = <span class="hljs-string">"4ee391f0349c00d92f68e4331425174eb8bdff9e"</span>
          },

      <span class="hljs-attr">erl-pinto</span> =
          { <span class="hljs-attr">dependencies</span> = [ <span class="hljs-string">"erl-process"</span> ]
          , <span class="hljs-attr">repo</span> = <span class="hljs-string">"ssh://git@github.com/id3as/purescript-erl-pinto.git"</span>
          , <span class="hljs-attr">version</span> = <span class="hljs-string">"59fd04bb0215f532b984909b3cd52bbaf1c10e6a"</span>
          },

      <span class="hljs-attr">erl-stetson</span> =
          { <span class="hljs-attr">dependencies</span> = [<span class="hljs-string">"erl-atom"</span> , <span class="hljs-string">"erl-binary"</span> , <span class="hljs-string">"erl-lists"</span> , <span class="hljs-string">"erl-maps"</span> , <span class="hljs-string">"erl-tuples"</span> , <span class="hljs-string">"erl-modules"</span> , <span class="hljs-string">"foreign"</span> , <span class="hljs-string">"maybe"</span> , <span class="hljs-string">"prelude"</span> , <span class="hljs-string">"transformers"</span> , <span class="hljs-string">"routing-duplex"</span>]
          , <span class="hljs-attr">repo</span> = <span class="hljs-string">"ssh://git@github.com/id3as/purescript-erl-stetson.git"</span>
          , <span class="hljs-attr">version</span> = <span class="hljs-string">"2244181d4905c16f7a62ead62a12a2056eb0c975"</span>
          }
      }

<span class="hljs-keyword">let</span> <span class="hljs-attr">extras</span> = {
       <span class="hljs-attr">erl-simplebus</span> =
          { <span class="hljs-attr">dependencies</span> =
              [ <span class="hljs-string">"erl-process"</span>
              , <span class="hljs-string">"effect"</span>
              ]
          , <span class="hljs-attr">repo</span> = <span class="hljs-string">"ssh://git@github.com/id3as/purescript-erl-simplebus.git"</span>
          , <span class="hljs-attr">version</span> = <span class="hljs-string">"14b5bd5971e7f2eeba99b51f1c6d4f43761b5376"</span>
          }
  }

<span class="hljs-keyword">in</span>  upstream ⫽ overrides⫽ extras
</code></pre><p><a href="https://github.com/id3as/purescript-erl-simplebus">erl-simplebus</a> is a new package not yet added to the <a href="https://github.com/purerl/package-sets">purerl package-sets</a> so that&#39;s been defined as an &#39;extra&#39;, and our cowboy/pinto/stetson repos are a moving target so we&#39;re using git commit hashes for them as the versions in the package set are out of date. In general our packages.dhall breath a little as we work on core libraries, stabilise changes and then get official releases pushed into the official package set.</p>
<p>With all of this defined, we can define our build package spago.dhall</p>
<pre><code>{-
-}
{ <span class="hljs-attr">name</span> = <span class="hljs-string">"demo"</span>
, <span class="hljs-attr">dependencies</span> =
    [ <span class="hljs-string">"console"</span>
    , <span class="hljs-string">"effect"</span>
    , <span class="hljs-string">"erl-cowboy"</span>
    , <span class="hljs-string">"erl-pinto"</span>
    , <span class="hljs-string">"erl-stetson"</span>
    , <span class="hljs-string">"psci-support"</span>
    , <span class="hljs-string">"simple-json"</span>
    , <span class="hljs-string">"erl-simplebus"</span>
    ]
, <span class="hljs-attr">packages</span> = ./packages.dhall
, <span class="hljs-attr">sources</span> = [ <span class="hljs-string">"src/**/*.purs"</span>, <span class="hljs-string">"test/**/*.purs"</span> ]
, <span class="hljs-attr">backend</span> = <span class="hljs-string">"purerl"</span>
}</code></pre><p>This allows us to use spago build on the CLI, which will pull down all of our packages and build them and our Erlang. Note the presence of &#39;backend&#39; for compiling to Erlang rather than JavaScript - this is a fairly recent change to the Purescript env and definitely differs from my previous blog posts on the subject (We&#39;ve done away with psc-package for starters).</p>
<h1 id="anyway">Anyway</h1>
<p>Look into Nix or install all the dependencies manually, I know which I&#39;d pick these days. Presumably it could be done in a docker container too, but docker is old hat, don&#39;t be old hat.</p>
]]></description><link>http://codeofrob.com/entries/updates-to-pinto+stetson---purerl-in-progress.html</link><guid isPermaLink="true">http://codeofrob.com/entries/updates-to-pinto+stetson---purerl-in-progress.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 25 Jun 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purerl - Some questions from #CodeMeshLdn]]></title><description><![CDATA[<p>Talk at CodeMesh now given, because of a demo god intervention (I discovered a Purerl compiler bug mid-demo, how&#39;s that for luck?) I didn&#39;t have time to receive questions during my actual session, but I kept a note of questions asked afterwards and will cover them here for those not present during their discussion.</p>
<p>I&#39;ll carry on linking these Purerl posts from each other before that however, &#39;cos it serves as a handy indexing mechanism in lieu of having a real blog engine..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
<li><a href="/entries/codemesh-2019---purerl-and-otp-talk.html">Codemesh 2019 - Purerl and OTP</a></li>
</ul>
<h1 id="useful-links">Useful links</h1>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<h1 id="some-questions-then">Some questions then.</h1>
<ul>
<li>What if I use the wrong types in my FFI</li>
<li>What if I don&#39;t use Effect in my FFI</li>
<li>How do you map complex union types back into Purerl when doing FFI (specifically, errors)</li>
<li>Are there any situations where you feel the types in Purescript would get in the way and you&#39;d just write Erlang instead?</li>
</ul>
<h1 id="wrong-types">Wrong types</h1>
<p>In one demo I did a very simple import of the base64 module from base Erlang:</p>
<pre><code class="language-erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(cool@foreign)</span>.

<span class="hljs-keyword">-export</span><span class="hljs-params">([base64/<span class="hljs-number">1</span>])</span>.

<span class="hljs-function"><span class="hljs-title">base64</span><span class="hljs-params">(String)</span> -&gt;</span> base64:encode(String).
</code></pre>
<p>Consumed in purescript with the following import</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> base64 :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
</code></pre>
<p>And all is right and proper, from the erlang shell, I can call this function</p>
<pre><code class="language-bash">Eshell V10.5  (abort with ^G)
1&gt; l(cool@ps).
{module,cool@ps}
2&gt; cool@ps:base64(&lt;&lt;<span class="hljs-string">"foo"</span>&gt;&gt;).
&lt;&lt;<span class="hljs-string">"Zm9v"</span>&gt;&gt;
3&gt;</code></pre>
<p>So.. what if we lie about the types at play here?</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> base64 :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Int</span>
</code></pre>
<p>Well, the result of calling the purescript function from Erlang isn&#39;t going to change because it doesn&#39;t care about types</p>
<pre><code class="language-bash">Eshell V10.5  (abort with ^G)
1&gt; l(cool@ps).
{module,cool@ps}
2&gt; cool@ps:base64(&lt;&lt;<span class="hljs-string">"foo"</span>&gt;&gt;).
&lt;&lt;<span class="hljs-string">"Zm9v"</span>&gt;&gt;
3&gt;</code></pre>
<p>How about using it in a purescript application?</p>
<pre><code class="language-haskell">
<span class="hljs-title">doSomething</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">doSomething</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> result = base64 <span class="hljs-string">"wow"</span>
  _ &lt;- <span class="hljs-type">Console</span>.log $ show result
  pure unit
</code></pre>
<pre><code class="language-bash">
&gt; (cool@ps:doSomething())().
** exception error: bad argument
     <span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span>  integer_to_binary/1
        called as integer_to_binary(&lt;&lt;<span class="hljs-string">"d293"</span>&gt;&gt;)
     <span class="hljs-keyword">in</span> call from data_show@foreign:showIntImpl/1 (output/Data.Show/data_show@foreign.erl, line 4)
     <span class="hljs-keyword">in</span> call from main@ps:<span class="hljs-string">'-doSomething/0-fun-0-'</span>/1 (/home/robashton/talks/purescript_beam/demo_2/src/Main.purs, line 19)
</code></pre>
<p>Passing the variable around in Purescript land, nothing cares - it is assumed that if you&#39;ve said something is a certain type, that it is that type and all type checking will be done on that basis - sooner or later, every bit of data will end up getting somewhere where it needs to be serialized whether for display, storage or transmission and that will involve passing the data into code that makes assumptions based on the type being passed in and you&#39;ll get a runtime crash.</p>
<p>So obviously the answer is &quot;don&#39;t do it&quot; - when building FFI, getting types correct is essential - definitely something worth testing.</p>
<h1 id="what-if-i-dont-use-effect-in-my-ffi">What if I don&#39;t use Effect in my FFI</h1>
<p>You maniac, why would you want to lie about side effects??! Well it turns out to not actually be a big deal, the main reason you&#39;re telling the type system about side effects is for your own benefit and if you choose to lie then at some point you will be hoisted on your own petard and we will all laugh at you. An example of places where this could happen is with legacy code and logging, I guess, probably, maybe.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-module</span><span class="hljs-params">(cool@foreign)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([ add/<span class="hljs-number">2</span> ])</span>.

<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(X,Y)</span> -&gt;</span>
  io:format(user, <span class="hljs-string">"WOW, I AM ADDING ~p and ~p"</span>, [ X, Y ]),
  X + Y.
</code></pre>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> add :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>

<span class="hljs-title">doSomething</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">doSomething</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> result = add <span class="hljs-number">5</span> <span class="hljs-number">6</span>
  _ &lt;- <span class="hljs-type">Console</span>.log $ show result
  pure unit
</code></pre>
<pre><code class="language-bash">8&gt; (main@ps:doSomething())().
WOW, I AM ADDING 5 and 611
unit</code></pre>
<p>Is this the future you want to be a part of? No I didn&#39;t think so - friends don&#39;t let friends write effectful code without declaring it as effectful.</p>
<h1 id="how-do-you-map-complex-union-types-back-into-purerl">How do you map complex union types back into Purerl </h1>
<p>Consider the <a href="http://erlang.org/documentation/doc-6.2/lib/kernel-3.0.3/doc/html/file.html#list_dir-1">read_dir API</a> in classic Erlang: </p>
<pre><code class="language-erlang">  list_dir(Dir) -&gt; {ok, Filenames} | {error, Reason}

  Types:

  Dir = name_all()
  Filenames = [filename()]
  Reason = posix()
         | badarg
         | {no_translation, Filename :: unicode:latin1_binary()}
</code></pre>
<p>There are some decisions to be made when writing code that exposes this API to the Purerl world, and none of them are <em>wrong</em> per se. The default position is usually &quot;Map the exact API across as it is, and if you don&#39;t like it then fix it by writing a somewhat more Purescripty wrapper&quot;.</p>
<p>So that would be.</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">module</span> Erl.File <span class="hljs-keyword">where</span>

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>Which means then passing in the constructors to the FFI so this can be constructed in Erlang without knowing about these types at the top level.</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> <span class="hljs-type">ListDir_</span> :: (<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">ListDirFailure</span>)  
                            -&gt; <span class="hljs-type">ListDirFailure</span> 
                            -&gt; (<span class="hljs-type">Binary</span> -&gt; <span class="hljs-type">ListDirFailure</span>) 
                            -&gt; <span class="hljs-type">ListDirFailure</span> -&gt; (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
                            -&gt; (<span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>)))
                            -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
<span class="hljs-title">listDir</span> = listDir_ <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">ListDirBadArg</span> <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Left</span> <span class="hljs-type">Right</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>Youch that&#39;s a mouthful, obviously we can make that a bit more legible with</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> <span class="hljs-type">ListDir_</span> :: (<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">ListDirFailure</span>)  
                            -&gt; <span class="hljs-type">ListDirFailure</span> 
                            -&gt; (<span class="hljs-type">Binary</span> -&gt; <span class="hljs-type">ListDirFailure</span>) 
                            -&gt; <span class="hljs-type">ListDirFailure</span> -&gt; <span class="hljs-type">ListDirResult</span>
                            -&gt; (<span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; <span class="hljs-type">ListDirResult</span>
                            -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">ListDirResult</span>

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
<span class="hljs-type">ListDir</span> = listDir_ <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">ListDirBadArg</span> <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Left</span> <span class="hljs-type">Right</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ListDirResult</span> = <span class="hljs-type">Either</span> <span class="hljs-type">ListDirResult</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>And the FFI then looks like</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">listDir_</span><span class="hljs-params">(ListDirPosixFailure, ListDirBadArg, NoTranslationError, Failure, Success, Dir)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
    <span class="hljs-keyword">case</span> file:list_dir(Dir) <span class="hljs-keyword">of</span>
      { ok, Filenames } -&gt; Success(Filenames);
      { error, { no_translation, Encoded } } -&gt; Failure(NoTranslationError(Encoded));
      { error, badarg } -&gt; Failure(ListDirBadArg);
      { error, Posix } -&gt; Failure(ListDirPosixFailure(Posix));
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>If you wanted a nicer API on top of this, let&#39;s call it &quot;CoolFileApi&quot; for example, you&#39;d then wrap <em>that</em> binding with something nicer - having at least type-safe-ified the original API in all of its glory, and then you&#39;re doing the work in Purescript rather than Erlang, I haven&#39;t ran this through a compiler so I probably got it a bit wrong but you&#39;ll get picture..</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> CoolFileApi <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Erl.File <span class="hljs-keyword">as</span> File
<span class="hljs-keyword">import</span> Data.Newtype (<span class="hljs-title">unwrap</span>, <span class="hljs-title">wrap</span>)

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Filepath</span> = <span class="hljs-type">Filepath</span> <span class="hljs-type">String</span></span>
<span class="hljs-title">derive</span> <span class="hljs-keyword">instance</span> ntFilepath :: <span class="hljs-type">Newtype</span> <span class="hljs-type">Filepath</span> _

<span class="hljs-type">ListDir</span> :: <span class="hljs-type">Filepath</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">CoolListDirFailureReason</span> (<span class="hljs-type">List</span> <span class="hljs-type">Filepath</span>))
<span class="hljs-type">ListDir</span> <span class="hljs-type">Filepath</span> = <span class="hljs-keyword">do</span>
  result &lt;- <span class="hljs-type">File</span>.<span class="hljs-type">ListDir</span> $ unwrap <span class="hljs-type">Filepath</span>
  pure $ either (<span class="hljs-type">Left</span> &lt;&lt;&lt; nativeFailureToShinyFailure) (<span class="hljs-type">Right</span> &lt;&lt;&lt; wrap)


<span class="hljs-title">nativeFailureToShinyFailure</span> :: <span class="hljs-type">File</span>.<span class="hljs-type">ListDirFailure</span> -&gt; <span class="hljs-type">CoolListDirFailureReason</span>
<span class="hljs-title">nativeFailureToShinyFailure</span> reason =
  <span class="hljs-keyword">case</span> reason <span class="hljs-keyword">of</span>
    <span class="hljs-type">ListDirBadArg</span> -&gt; <span class="hljs-type">CoolListDirBadArg</span>
    <span class="hljs-type">ListDirNoTranslation</span> filename -&gt; <span class="hljs-type">CoolListDirNoTranslation</span> filename
    <span class="hljs-type">ListDirPosixFailure</span> a -&gt; <span class="hljs-type">CoolListDirPosixFailure</span> (atomToCool a)

<span class="hljs-title">atomToCool</span>  :: <span class="hljs-type">Erl</span>.<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">CoolListDirPosixFailure</span>
<span class="hljs-title">atomToCool</span> a = 
  <span class="hljs-keyword">case</span> a <span class="hljs-keyword">of</span>
    (atom <span class="hljs-string">"eacces"</span>) -&gt; <span class="hljs-type">Eaccess</span>
    (atom <span class="hljs-string">"enoent"</span>) -&gt; <span class="hljs-type">Enoent</span>
    <span class="hljs-comment">--- etc</span>
</code></pre>
<p>Essentially getting rid of those arbitary atoms and Erlang data types and representing them as native Purerl data types. You <em>could</em> just write your binding directly in this way from the get-go, but it&#39;s considered polite to write the low level bindings as directly as possible to the original API because it saves on mental load (and doing as little work as possible in the Erlang code), the documentation for the original API is then applicable to the low level bindings too.</p>
<h1 id="arent-types-a-huge-pain-in-the-ass">Aren&#39;t types a huge pain in the ass?</h1>
<p>I mean that&#39;s what I heard for this question, and it&#39;s a bit of a loaded one - people that aren&#39;t used to working in a sensibly typed environment tend to look at the typed environment as being a form of burden, instead of an aid to help you write better code. Some of the conversation around this was about whether we&#39;d be re-writing some of our core functionality in Purescript, and whether that would even be desirable as the types might get in the way of productivity.</p>
<p>I think that actually there is a lot of desire internally for us to do our next re-write of our orchestration logic in Purerl for example, but because  we&#39;re in a different language with a different way of looking at the world, the API and even the design of that would probably not look anything like the original (and the same goes for our media workflow engine too). We&#39;re not afraid of re-writes, we write code  to be thrown away after all - but usually when doing a re-write of a module, you get to learn from the previous iterations and Do It Better this time - the pendulum of compensation from past mistakes slowly zeroes in around an ideal design and by version 3 or 4 you&#39;re laughing.</p>
<p>The main pain of having to do things differently is while there will be some lessons that can be passed into the rewrites into Purescript, a lot of the design decisions don&#39;t come through to the new world and you&#39;re essentially going back to version 1/2 again for that component. That&#39;ll be the pain that we&#39;ll go through but we&#39;ll come out the other side as better Purescript developers so we&#39;re not afraid of that.</p>
<p>I really can&#39;t see a point where I&#39;d say that types are going to get in the way of Just Getting Stuff Done, in my experience so far, the type system is just a more honest way of looking at effort, when you&#39;re working in a sloppy-typed environment you can pretend that it&#39;s really easy and fun and you&#39;re dead smart so it&#39;s okay, but you end up paying the cost in bugs and mistakes eventually - the upfront cost might not be there but you&#39;ve just shifted it elsewhere. Types also typically enable you to write better abstractions to lessen the load of repeated operations - you can be a lot more clever when the compiler has your back.</p>
<p>It&#39;s very hard to currently view what a typed version of some of our core IP would look like, but that&#39;s down to our inexperience rather than it being an impossible task; it&#39;ll come in time.</p>
<h1 id="anyway">Anyway</h1>
<p>That&#39;s some answers, if you have more questions about Purerl/Stetson/Pinto <a href="http://twitter.com/robashton">hit me up on Twitter</a> and I&#39;ll do my best to help..</p>
]]></description><link>http://codeofrob.com/entries/purerl---some-questions-from-codemeshldn.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl---some-questions-from-codemeshldn.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 07 Nov 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Codemesh 2019 - Purerl and OTP talk]]></title><description><![CDATA[<p>Just a note that I&#39;ll be appearing at <a href="https://www.codemesh.io/conferences/code-mesh-ldn/">Codemesh</a> on Thursday (11:25) to give a talk where I go over some of the stuff we&#39;ve been working on at <a href="https://www.id3as.com/home">Work</a>(tm) this year - with a focus on some of the implementation details and nitty gritty/etc.</p>
<p>I silently blogged some of this recently, basically showing off how we&#39;ve now got the ability to write OTP applications in Purescript these days, and indeed are. The posts are all linked below for the majority of folk who are sensible enough not to not subscribe to this sorry excuse for a blog.</p>
<p>Here is a sneaky peek as to what a gen server looks like in this world, tasty no?</p>
<pre><code class="language-haskell">
<span class="hljs-title">findByIsbn</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findByIsbn</span> isbn = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    result &lt;- <span class="hljs-type">Redis</span>.get (dbId isbn) connection
    pure $ <span class="hljs-type">CallReply</span> result state

<span class="hljs-title">findAll</span> :: <span class="hljs-type">Effect</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findAll</span> = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    books &lt;- <span class="hljs-type">Redis</span>.findAll dbPrefix connection
    pure $ <span class="hljs-type">CallReply</span> books state

<span class="hljs-comment">-- Nothing special about this, just a function that returns a certain type</span>
<span class="hljs-comment">-- We can supply arbitrary arguments to this via the gensup</span>
<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.startLink serverName $ init args

<span class="hljs-comment">-- And those arguments can then end up in here, which just needs to return an effect of our State type</span>
<span class="hljs-title">init</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  connection &lt;- <span class="hljs-type">Redis</span>.open args.connectionString
  pure $ { connection }
</code></pre>
<h1 id="the-blog-entries">The blog entries</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="useful-links">Useful links</h1>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
]]></description><link>http://codeofrob.com/entries/codemesh-2019---purerl-and-otp-talk.html</link><guid isPermaLink="true">http://codeofrob.com/entries/codemesh-2019---purerl-and-otp-talk.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 05 Nov 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purescript interop with native Erlang - Interacting with Redis]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<p>We&#39;ve handwaved over the contents of the <a href="https://github.com/id3as/demo-ps/blob/master/server/src/Native/Redis.purs">Redis</a> module so far in the demo app, showing only that we can use it from our <a href="https://github.com/id3as/demo-ps/blob/master/server/src/BookLibrary.purs">BookLibrary.purs</a> like any other module as follows.</p>
<pre><code class="language-haskell">
<span class="hljs-title">update</span> :: <span class="hljs-type">Book</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">String</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">update</span> book =
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-type">Redis</span>.put (dbId book.isbn) book connection
    pure $ <span class="hljs-type">CallReply</span> (<span class="hljs-type">Right</span> book) state
</code></pre>
<p>That&#39;s pretty tidy, so let&#39;s look at the type of that function so we understand the Purescript side of things first and foremost</p>
<pre><code class="language-haskell">
<span class="hljs-title">put</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">DbId</span> -&gt; a -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
</code></pre>
<p>For any type &#39;a&#39; that implements WriteForeign, we&#39;re a function that takes a DbId, an A and a RedisConnection to produce an Effect of type Unit - this pretty much makes sense on the surface, DbId is just a newtype around String, and given a Key and a Value (which we can get from calling writeJSON on our type &#39;a&#39;), we can dump stuff in Redis - but how?</p>
<p>Let&#39;s take a step back a moment and approach this from the <em>other</em> end.</p>
<p>There is an application for accessing Redis in Erlang, called <a href="https://github.com/wooga/eredis">eredis</a> imaginatively enough, the usage of which looks a little like this.</p>
<pre><code class="language-erlang">
   { ok, C } = eredis:start_link(ConnectionString),

   eredis:q(C, [ &lt;&lt;<span class="hljs-string">"SET"</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">"key"</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">"value"</span>&gt;&gt; ]).
</code></pre>
<p>So what we want to do is surface this meaningfully to Purescript is define some foreign imports in our <em>Redis.purs</em>, which map onto their native counterparts in our <em>Redis.erl.</em></p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">ConnectionString</span> :: <span class="hljs-type">Type</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">RedisConnection</span> :: <span class="hljs-type">Type</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> open :: <span class="hljs-type">ConnectionString</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">RedisConnection</span>
</code></pre>
<p>By importing a foreign type, we&#39;re saying to Purescript &quot;Hey, this thing exists in Erlang but we don&#39;t know what is inside it, but we want to model it as something we can pass around thanks&quot;, the ConnectionString comes from sys.config and the RedisConnection is actually a Pid but we don&#39;t need to know that.</p>
<p>By importing a foreign function, we&#39;re saying that there is a function in Erlang with this name and signature and we&#39;d like to call it from Purescript. The &quot;open&quot; function we&#39;re importing from Erlang takes one of those ConnectionStrings and produces an Effect of type RedisConnection.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(ConnectionString)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, C } = eredis:start_link(ConnectionString),
      C
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>We wrap our actual functionality in a function, because that&#39;s how an Effect is modelled in Purerl, and we can return our &#39;Connection&#39; as an opaque type to Purescript when this Effect is processed. I&#39;ve made the decision here to match directly on <em>{ ok, C }</em> which means we&#39;ll crash at runtime if we can&#39;t open a connection - an alternative API could look like this.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">open_</span><span class="hljs-params">(ConnectionString, Just, Nothing)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, C } = <span class="hljs-keyword">case</span> eredis:start_link(ConnectionString) <span class="hljs-keyword">of</span>
                    { ok, C } -&gt; Just(C);
                    _ -&gt; Nothing
                    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>where</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> open_ :: <span class="hljs-type">ConnectionString</span> -&gt; (<span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>) -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>  -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>)

<span class="hljs-title">open</span> :: <span class="hljs-type">ConnectionString</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">RedisConnection</span>
<span class="hljs-title">open</span> connectionString = open_ connectionString <span class="hljs-type">Just</span> <span class="hljs-type">Nothing</span>
</code></pre>
<p>I&#39;ve chosen to &quot;let it crash&quot;, as that fits with how I&#39;d build the supervsion tree in Erlang around this (Restart periodically every 30s until the connection works please), but either approach is valid and not one I have strong opinions on at this time. (an Either with the failure reason would also be an option).</p>
<p>Anyway, going back to that <em>put</em> function with all of this in mind, we want to keep the Erlang pretty minimal, so some transformation on the Purescript side will be required. </p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> put_ :: <span class="hljs-type">DbId</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>

<span class="hljs-title">put</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">DbId</span> -&gt; a -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">put</span> id obj conn =
  put_ id (writeJSON obj) conn
</code></pre>
<p>Purescript knows how to turn our obj into JSON so we&#39;ll do that there, and then use a foreign function that takes just the primitive objects for use within Erlang with eredis.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-define</span><span class="hljs-params">(SET(Key, Value)</span>, [ &lt;&lt;"SET"&gt;&gt;, Key, Value ]).

<span class="hljs-function"><span class="hljs-title">put_</span><span class="hljs-params">(Id, Data, Pid)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, &lt;&lt;<span class="hljs-string">"OK"</span>&gt;&gt;} = eredis:q(Pid, ?SET(Id, Data)),
      ok
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>Now, this is not necessarily how we should approach building an FFI for a native library, as we&#39;re making some decisions in Erlang that could be made in Purescript, a more traditional FFI would look like this.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">q</span><span class="hljs-params">(Pid, Operation)</span> -&gt;</span>
  eredis:q(Pid, Operation).
</code></pre>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> q :: <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">Binary</span>)
</code></pre>
<p>And then we could build the API we <em>actually</em> want on top of <em>that</em> instead - I&#39;ve rather skipped that step in my demo for clarity, but if I was producing a library wrapper for publication that&#39;s probably the approach I&#39;d take, as unwieldy as it is to actually use it means we end up writing more Purescript and less Erlang.</p>
<p>This is the approach that erl-cowboy and Stetson took, whereas erl-pinto takes the direct approach to &quot;desired API&quot;, making the concession that it&#39;ll be easier to build without 1-1 FFI in existence. Either way, it&#39;s pretty easy to call into existing code in Erlang.</p>
<h1 id="next-up">Next up</h1>
<p>We&#39;ve pretty much covered the surface area of the demo project, so I&#39;ll be going off on a little journey talking about some of the common things that we like to do in Erlang and how to get that behaviour into Purerl, if I get any questions about these posts I&#39;ll follow up with answers in blog format also.</p>
]]></description><link>http://codeofrob.com/entries/purescript-interop-with-native-erlang---interacting-with-redis.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purescript-interop-with-native-erlang---interacting-with-redis.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 29 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Shared code twixt Purescript server and client]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<p>We&#39;ve got a basic model representing our &#39;book&#39;</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">module</span> Books <span class="hljs-keyword">where</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Book</span> = { <span class="hljs-title">isbn</span> :: <span class="hljs-type">String</span>
            , <span class="hljs-title">title</span> :: <span class="hljs-type">String</span>
            , <span class="hljs-title">author</span> :: <span class="hljs-type">String</span>
            }</span>
</code></pre>
<p>Which is pretty terribly exciting - the key thing to note here is that this is a plain ol&#39; record containing primitive types - this makes it pretty shareable as far as view models go (Let&#39;s ignore that we&#39;re using it for persistence here, demo code gonna demo code).</p>
<p>We&#39;ve shoved Books.purs into a folder called &#39;shared&#39; which has been softlinked from both the client and server directories, which means it will be separately compiled into JS And Purescript respectively.</p>
<p>There is a great library over in Purescript world called <a href="https://github.com/justinwoo/purescript-simple-json">simple-json</a> which defines a <em>ReadForeign</em> and <em>WriteForeign</em> for these basic types, which means that the functions readJSON and writeJSON will do the back and forth between JSON and the Purescript types.</p>
<p>There is also (thanks to the efforts of <a href="https://github.com/purerl/purescript-simple-json">@nwolverson</a>, a port of this library exists on the Purerl side of things which works in exactly the same way, using <a href="https://github.com/talentdeficit/jsx">JSX</a> under the hood. This is a fairly common pattern across the Purerl world, and you&#39;ll see when browsing the org repos that a lot of the code from the JS Purescript world has been ported across with minimal changes so that the two worlds look as alike as possible.</p>
<p>So, in the previous post we loaded a list of Books out of our genserver in Cowboy and simply called writeJSON on it.</p>
<pre><code class="language-haskell">
<span class="hljs-meta"># Rest.contentTypesProvided (\req state -&gt; Rest.result (jsonWriter : nil) req state)</span>

<span class="hljs-title">jsonWriter</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">Tuple2</span> <span class="hljs-type">String</span> (<span class="hljs-type">Req</span> -&gt; a -&gt; (<span class="hljs-type">Effect</span> (<span class="hljs-type">RestResult</span> <span class="hljs-type">String</span> a)))
<span class="hljs-title">jsonWriter</span> = tuple2 <span class="hljs-string">"application/json"</span> (\req state -&gt; <span class="hljs-type">Rest</span>.result (writeJSON state) req state)
</code></pre>
<p>If we open up the client code, we can see</p>
<pre><code class="language-haskell">
<span class="hljs-title">maybeBook</span> &lt;- <span class="hljs-type">H</span>.liftAff $ loadItem $ <span class="hljs-string">"/api/books/"</span> &lt;&gt; isbn

<span class="hljs-comment">-- where</span>

<span class="hljs-title">loadItem</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">ReadForeign</span> a =&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Aff</span> (<span class="hljs-type">Either</span> <span class="hljs-type">String</span> a)
<span class="hljs-title">loadItem</span> uri = <span class="hljs-keyword">do</span>
  response &lt;- <span class="hljs-type">AX</span>.get <span class="hljs-type">AXResponse</span>.string uri
  <span class="hljs-keyword">case</span> response.body <span class="hljs-keyword">of</span>
     <span class="hljs-type">Left</span> err -&gt; pure $ <span class="hljs-type">Left</span> <span class="hljs-string">"No"</span>
     <span class="hljs-type">Right</span> json -&gt; pure $ bimap show identity $ readJSON json
</code></pre>
<p>That is all that is required to shift data between the server Purescript and the client Purescript which is pretty tidy indeed! Because we&#39;re using the same library, any custom implementations of <em>ReadForeign</em> and <em>WriteForeign</em> we might choose to write can then also be shared between the two.</p>
<p>Obviously sharing code between both client and server is something that should be entered into with caution, typically sharing a lot of business logic is the sign of a problem - but I can easily see us ending up in a world where we can start using Halogen on the server-side to pre-render HTML for serving to the client much in the same way that the ReactJS community have started doing similar with NodeJS.</p>
<h1 id="next-up">Next up</h1>
<p>We&#39;ll look at our bindings to Redis, to get a feel for what interop with &quot;native&quot; Erlang with FFI looks like.</p>
]]></description><link>http://codeofrob.com/entries/shared-code-twixt-purescript-server-and-client.html</link><guid isPermaLink="true">http://codeofrob.com/entries/shared-code-twixt-purescript-server-and-client.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 27 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Building a Purescript web server with Stetson and Pinto]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<p>Having now gotten a basic OTP application up and running, it&#39;d be nice to get some data out to the world.</p>
<h1 id="cowboy">Cowboy</h1>
<p>Cowboy is the defacto web server in the Erlang world, each route loosely maps to a module which has callbacks defined in it to handle various stages of the decisioning process.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-module</span><span class="hljs-params">(my_handler)</span>.

<span class="hljs-keyword">-export</span><span class="hljs-params">([init/<span class="hljs-number">2</span>,
         get_text/<span class="hljs-number">2</span>,
         content_types_provided/<span class="hljs-number">2</span>
        ])</span>.

<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req, _Opts)</span> -&gt;</span>
  { cowboy_rest, Req, #state{} }.

<span class="hljs-function"><span class="hljs-title">content_types_provided</span><span class="hljs-params">(Req, State)</span> -&gt;</span>
  {[{ &lt;&lt;<span class="hljs-string">"text/plain"</span>&gt;&gt;, get_text}], Req, State}.

<span class="hljs-function"><span class="hljs-title">get_json</span><span class="hljs-params">(Req, State)</span> -&gt;</span>
  { &lt;&lt;<span class="hljs-string">"Hello World"</span>&gt;&gt;, Req, State }.
</code></pre>
<p>This is directly representable in Purescript, using <a href="https://github.com/purerl/purescript-erl-cowboy">erl-cowboy</a>.</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> MyHandler <span class="hljs-keyword">where</span>

<span class="hljs-title">init</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">InitHandler</span> a a
<span class="hljs-title">init</span> = mkEffectFn2 \req c -&gt; pure (initResult c req)

<span class="hljs-title">content_types_provided</span> :: <span class="hljs-keyword">forall</span> s. <span class="hljs-type">ContentTypesProvidedHandler</span> s
<span class="hljs-title">content_types_provided</span> =  mkEffectFn2 \req s -&gt; pure $
  restResult
    (contentTypesProvidedResult $ fromFoldable
      [ tuple2 (<span class="hljs-type">ContentType</span> <span class="hljs-string">"text"</span> <span class="hljs-string">"plain"</span> <span class="hljs-type">AnyParams</span>) (<span class="hljs-type">ProvideCallback</span> $ atom <span class="hljs-string">"asText"</span>) ]
    )
    s req


<span class="hljs-title">asText</span> :: <span class="hljs-keyword">forall</span> s. <span class="hljs-type">EffectFn2</span> <span class="hljs-type">Req</span> s (<span class="hljs-type">Tuple3</span> <span class="hljs-type">String</span> <span class="hljs-type">Req</span> s)
<span class="hljs-title">asText</span> = mkEffectFn2 \req s -&gt; pure $ tuple3 <span class="hljs-string">"Hello World"</span> req s
</code></pre>
<p>However, this doesn&#39;t make the best use of Purescript itself - and writing out a few dozen handlers like this would soon get a bit tedious, which is why I went away and wrote <a href="https://github.com/id3as/purescript-erl-stetson">Stetson</a>. Purescript is a functional programming language and it makes sense that rather than provide a bunch of loosely typed callbacks referred to by name using strings, that we built an API that took functions to do all the heavy lifting.</p>
<pre><code class="language-haskell">
<span class="hljs-title">helloWorld</span> :: <span class="hljs-type">StetsonHandler</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">helloWorld</span> =
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-type">Rest</span>.initResult req unit)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (tuple2 <span class="hljs-string">"text/html"</span> asText) req state)
    # <span class="hljs-type">Rest</span>.yeeha
    <span class="hljs-keyword">where</span> 
      asText req state = <span class="hljs-keyword">do</span>
        <span class="hljs-type">Rest</span>.result <span class="hljs-string">"Hello World"</span> req state)
</code></pre>
<p>The idea of course being that we can configure Stetson/Cowboy at the top level by providing a pile of functions and abstract over the common bits like &quot;This is an accept handler that turns state into JSON because State has the typeclass &quot;WriteForeign&quot;, and start to get rid of a lot of duplication across our routes.</p>
<pre><code class="language-haskell">
<span class="hljs-title">init</span> :: <span class="hljs-type">BookWebStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  <span class="hljs-type">Stetson</span>.configure
    # <span class="hljs-type">Stetson</span>.route <span class="hljs-string">"/api/books"</span> books
    # <span class="hljs-type">Stetson</span>.route <span class="hljs-string">"/api/books/:isbn"</span> book
    # <span class="hljs-type">Stetson</span>.static <span class="hljs-string">"/assets/[...]"</span> (<span class="hljs-type">PrivDir</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/assets"</span>)
    # <span class="hljs-type">Stetson</span>.static <span class="hljs-string">"/[...]"</span> (<span class="hljs-type">PrivFile</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/index.html"</span>)
    # <span class="hljs-type">Stetson</span>.port args.webPort
    # <span class="hljs-type">Stetson</span>.bindTo <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>
    # <span class="hljs-type">Stetson</span>.startClear <span class="hljs-string">"http_listener"</span>
  pure $ <span class="hljs-type">State</span> {}
</code></pre>
<p>where books and book are handlers as described above. In our own applications, we have ended up with pretty much the entire web server and all routes in a single file - which is in stark contrast to our usual Erlang apps where we have a folder containing dozens of separate erlang modules.</p>
<pre><code class="language-haskell"><span class="hljs-title">books</span> :: <span class="hljs-type">StetsonHandler</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">books</span> =
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-keyword">do</span>
                        state &lt;- <span class="hljs-type">BookLibrary</span>.findAll
                        <span class="hljs-type">Rest</span>.initResult req state)
    # <span class="hljs-type">Rest</span>.allowedMethods (\req state -&gt; <span class="hljs-type">Rest</span>.result (<span class="hljs-type">Stetson</span>.<span class="hljs-type">POST</span> :  <span class="hljs-type">Stetson</span>.<span class="hljs-type">HEAD</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">GET</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">OPTIONS</span> : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (jsonWriter : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesAccepted (\req state -&gt; <span class="hljs-type">Rest</span>.result ((tuple2 <span class="hljs-string">"application/json"</span> acceptJson) : nil)
                                req state)
    # <span class="hljs-type">Rest</span>.yeeha
    <span class="hljs-keyword">where</span> 
          acceptJson req state = <span class="hljs-keyword">do</span>
            body &lt;- allBody req mempty
            result &lt;- either (pure &lt;&lt;&lt; <span class="hljs-type">Left</span> &lt;&lt;&lt; show) <span class="hljs-type">BookLibrary</span>.create $ readJSON $ unsafeCoerce body
            <span class="hljs-keyword">case</span> result <span class="hljs-keyword">of</span>
                 <span class="hljs-type">Left</span> err -&gt; <span class="hljs-type">Rest</span>.result false (setBody err req) state
                 <span class="hljs-type">Right</span> c -&gt; <span class="hljs-type">Rest</span>.result true req state

<span class="hljs-title">jsonWriter</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">Tuple2</span> <span class="hljs-type">String</span> (<span class="hljs-type">Req</span> -&gt; a -&gt; (<span class="hljs-type">Effect</span> (<span class="hljs-type">RestResult</span> <span class="hljs-type">String</span> a)))
<span class="hljs-title">jsonWriter</span> = tuple2 <span class="hljs-string">"application/json"</span> (\req state -&gt; <span class="hljs-type">Rest</span>.result (writeJSON state) req state)
</code></pre>
<p>So that&#39;s a handler that has a state of type <em>&#39;List Book&#39;</em>, which it gets from our <em>BookLibrary</em> via a call (as in the previous blog entry), jsonWriter being a function as decscribed above - simply taking that model and spitting it out as JSON, leveraging our model which happens to implement that type class.</p>
<p>We&#39;ll look more into that in the next entry, where we talk about that model and how we&#39;re using it on both client and server.</p>
]]></description><link>http://codeofrob.com/entries/building-a-purescript-web-server-with-stetson-and-pinto.html</link><guid isPermaLink="true">http://codeofrob.com/entries/building-a-purescript-web-server-with-stetson-and-pinto.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 22 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Building on top of OTP with Purescript with Pinto]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowbou we&#39;re using)</li>
</ul>
<p>We left the last post demonstrating that an end-to-end Purescript project was essentially a pile of Purescript written in the right place, in order that the usual Erlang application/rebar3/etc can just work with it.</p>
<h1 id="that-entry-point-again-then">That entry point again then</h1>
<p>We looked at <em>BookApp.purs</em>, which compiled into an Erlang module called <em>bookApp@ps</em>. which ends up in <em>src/compiled_ps</em> and gets picked up with the usual Erlang structure. Let&#39;s look at that file and see what we see:</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> BookApp <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Prelude
<span class="hljs-keyword">import</span> BookSup <span class="hljs-keyword">as</span> BookSup

<span class="hljs-keyword">import</span> Pinto.App <span class="hljs-keyword">as</span> App

<span class="hljs-title">start</span> = <span class="hljs-type">App</span>.simpleStart <span class="hljs-type">BookSup</span>.startLink</code></pre>
<p>That <em>simpleStart</em> function is just a Pinto helper that describes an entry point that doesn&#39;t worry about inputs, and provided a Supervisor will start that Supervisor when the application is started.</p>
<p>This gets compiled into the following Erlang</p>
<pre><code class="language-erlang"><span class="hljs-comment">% Generated by purs version 0.12.3</span>
<span class="hljs-keyword">-module</span><span class="hljs-params">(bookApp@ps)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([start/<span class="hljs-number">0</span>, start/<span class="hljs-number">2</span>])</span>.
<span class="hljs-keyword">-compile</span><span class="hljs-params">(nowarn_shadow_vars)</span>.
<span class="hljs-keyword">-compile</span><span class="hljs-params">(nowarn_unused_vars)</span>.
<span class="hljs-keyword">-compile</span><span class="hljs-params">(no_auto_import)</span>.
<span class="hljs-keyword">-file</span><span class="hljs-params">(<span class="hljs-string">"src/BookApp.purs"</span>, <span class="hljs-number">8</span>)</span>.
<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> -&gt;</span> (pinto_app@ps:simpleStart((bookSup@ps:startLink()))).
<span class="hljs-keyword">-file</span><span class="hljs-params">(<span class="hljs-string">"src/BookApp.purs"</span>, <span class="hljs-number">8</span>)</span>.
<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_@<span class="hljs-number">0</span>,_@<span class="hljs-number">1</span>)</span> -&gt;</span> ((pinto_app@ps:simpleStart((bookSup@ps:startLink())))(_@<span class="hljs-number">0</span>, _@<span class="hljs-number">1</span>)).</code></pre>
<p>If get rid of the cruft, that&#39;s essentially just</p>
<pre><code class="language-erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(bookApp@ps)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([start/<span class="hljs-number">0</span>, start/<span class="hljs-number">2</span>])</span>.
<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> -&gt;</span> (pinto_app@ps:simpleStart((bookSup@ps:startLink()))).
<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_@<span class="hljs-number">0</span>,_@<span class="hljs-number">1</span>)</span> -&gt;</span> ((pinto_app@ps:simpleStart((bookSup@ps:startLink())))(_@<span class="hljs-number">0</span>, _@<span class="hljs-number">1</span>)).</code></pre>
<p>This is just a standard application module that you&#39;d find in an Erlang application, exporting the usual start function that calls into a supervisor to start it. This is the only time I&#39;ll be loading up the compiled Purescript as it&#39;s the simplest example - but nearly all of the Pinto helpers are about making sure we can end up exposing a module that looks like the equivalent OTP erlang module.</p>
<p>The supervisor? More of the same</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> BookSup <span class="hljs-keyword">where</span>

<span class="hljs-comment">-- [[ imports redacted ]]</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Pinto</span>.<span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> = <span class="hljs-type">Sup</span>.startLink <span class="hljs-string">"book_sup"</span> init

<span class="hljs-title">init</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">SupervisorSpec</span>
<span class="hljs-title">init</span> = <span class="hljs-keyword">do</span>
  connectionString &lt;- <span class="hljs-type">BookConfig</span>.connectionString
  webPort &lt;- <span class="hljs-type">BookConfig</span>.webPort
  pure $ buildSupervisor
                # supervisorStrategy <span class="hljs-type">OneForOne</span>
                # supervisorChildren ( ( buildChild
                                       # childType <span class="hljs-type">Worker</span>
                                       # childId <span class="hljs-string">"book_web"</span>
                                       # childStart <span class="hljs-type">BookWeb</span>.startLink  { webPort } )
                                       : 
                                       ( buildChild
                                       # childType <span class="hljs-type">Worker</span>
                                       # childId <span class="hljs-string">"book_library"</span>
                                       # childStart <span class="hljs-type">BookLibrary</span>.startLink { connectionString } )
                                        : nil)</code></pre>
<p><em>Sup.startLink</em> is a Pinto helper that&#39;ll end up calling our usual <em>supervisor:start_link</em> under the hood, with our <em>init</em> function being invoked within the context of that created supervisor and returning a supervisor spec when invoked. </p>
<p>The supervisor spec structure is quite a complicated tangle of maps in Erlang, and while possible to directly represent these in Purescript with records, there are convenience builders/etc provided by Pinto to describe these specs in a more Purescripty and type safe manner - all of these values are pretty much relatable right back to the OTP documentation which is handy and intentional.</p>
<p>Now, let&#39;s break down one of these gen servers to see what we can see - we&#39;ll have to do this piece-meal as there is a lot to uncover. We&#39;ll be looking at <em>BookLibrary.purs</em>, invoked above in the second child of the supervision tree with BookLibrary.startLink and the code for which is shown below..</p>
<pre><code class="language-haskell">
<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">ServerName</span> <span class="hljs-string">"book_library"</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">BookLibraryStartArgs</span> = {
  <span class="hljs-title">connectionString</span> :: <span class="hljs-type">ConnectionString</span>
}</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.startLink serverName $ init args
</code></pre>
<p>So there is nothing too special about this, we&#39;re exporting a function called startLink that takes some configuration from the supervisor, and that calls into the Pinto function <em>Gen.startLink</em> with the serverName, and an init function to invoke within the context of the started GenServer along with those args. This isn&#39;t disimilar to how this looks in the Erlang world so far. </p>
<p>That serverName construct represents both the unique identifier for this started process, and also encapsulates the type of the &#39;state&#39; that is held by the GenServer, and will be used in all interactions with the <em>Gen</em> module.</p>
<p>That init function?</p>
<pre><code class="language-haskell">
<span class="hljs-title">init</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  connection &lt;- <span class="hljs-type">Redis</span>.open args.connectionString
  pure $ { connection }
</code></pre>
<p>Takes place inside the context of the newly started GenServer, and is responsible for effectfully creating the initial state of the GenServer, which is just a Redis connection (We&#39;ll talk about that later). This is actually all we need to create a running GenServer as everything else is entirely optonal.</p>
<p>Obviously that&#39;s useless, so let&#39;s look at how we can externally call into this GenServer to do something useful</p>
<pre><code class="language-haskell">
<span class="hljs-title">findAll</span> :: <span class="hljs-type">Effect</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findAll</span> = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    books &lt;- <span class="hljs-type">Redis</span>.findAll dbPrefix connection
    pure $ <span class="hljs-type">CallReply</span> books state
</code></pre>
<p>We can export a plain ol&#39; Purescript function called findAll that returns a plain ol&#39; Effect producing a List of Book, and we can do the rest of the work by invoking a &#39;call&#39; with the <em>Gen</em> module, by giving <em>Gen.doCall</em> our <em>serverName</em> construct, we are able to then provide a typed callback that  will be invoked within the context of the gen-server as part of a <em>handle_call</em>, and therefore gain access to the state and return some books by calling into the Redis connection.</p>
<p>The original Erlang would of course look a little like this.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-export</span><span class="hljs-params">([start_link/<span class="hljs-number">1</span>, 
         init/<span class="hljs-number">1</span>,
         find_all/<span class="hljs-number">0</span>])</span>.

<span class="hljs-keyword">-record</span><span class="hljs-params">(args, {
    connection_string :: connection_string()
    })</span>.

<span class="hljs-keyword">-record</span><span class="hljs-params">(state, {
    connection :: redis:connection()
  })</span>.

<span class="hljs-function"><span class="hljs-title">find_all</span><span class="hljs-params">()</span> -&gt;</span>
  gen_server:call({via, gproc, {n, l, ?MODULE}}, find_all).

<span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(Args)</span> -&gt;</span>
  gen_server:start_link({via, gproc, {n, l, ?MODULE}}, ?MODULE, [Args], []).

<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([#args { connection_string = ConnectionString }])</span> -&gt;</span>
  { ok, Connection } = redis:open(ConnectionString),
  {ok, #state { connection = Connection }}.

<span class="hljs-function"><span class="hljs-title">handle_call</span><span class="hljs-params">(find_all, _Sender, State = #state { connection = Connection })</span> -&gt;</span>
  { ok, Result } = redis:find_prefix(dbPrefix, Connection),
  { reply, Result, State }.

</code></pre>
<p>This is a bit unwieldy, lacks any notion of type safety across the calls being made, but is still pleasantly relatable to the Purescript variant.</p>
<pre><code class="language-haskell">
<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">ServerName</span> <span class="hljs-string">"book_library"</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">BookLibraryStartArgs</span> = {
  <span class="hljs-title">connectionString</span> :: <span class="hljs-type">ConnectionString</span>
}</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = {
  <span class="hljs-title">connection</span> :: <span class="hljs-type">RedisConnection</span>
}</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.startLink serverName $ init args

<span class="hljs-title">init</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  connection &lt;- <span class="hljs-type">Redis</span>.open args.connectionString
  pure $ { connection }

<span class="hljs-title">findAll</span> :: <span class="hljs-type">Effect</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findAll</span> = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    books &lt;- <span class="hljs-type">Redis</span>.findAll dbPrefix connection
    pure $ <span class="hljs-type">CallReply</span> books state
</code></pre>
<p>Note: Wrapping up a connection behind a genserver is nearly always not the thing you want to do (effectively it introduces a read/write lock), but sample code gonna sample code.</p>
<p>Next up, we&#39;ll look at how we could use this GenServer from Stetson to provide a restful JSON API to our client.</p>
]]></description><link>http://codeofrob.com/entries/building-on-top-of-otp-with-purescript-with-pinto.html</link><guid isPermaLink="true">http://codeofrob.com/entries/building-on-top-of-otp-with-purescript-with-pinto.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 20 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[The structure of an end-to-end Purescript OTP project]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowbou we&#39;re using)</li>
</ul>
<h1 id="the-structure-of-an-end-to-end-purescript-otp-project">The structure of an end-to-end Purescript OTP project</h1>
<p>Our <a href="https://github.com/id3as/demo-ps">demo-ps</a> can be viewed as two separate chunks of code, the base layer is just a plain old Erlang application built using rebar3 and such, and then on top of that we have a pile of Purescript that compiles into Erlang that can then be compiled and used by the usual development workflow.</p>
<h1 id="the-erlangy-bits">The Erlangy bits</h1>
<ul>
<li><em>release-files</em>: Assets to be shipped during the release process</li>
<li><em>src</em>: This is usually where the Erlang application lives, but there is no Erlang code<ul>
<li><em>demo_ps.app.src</em>: The entry point, just points at a Purescript module, we&#39;ll talk about that</li>
</ul>
</li>
<li><em>rebar.config</em>: Erlang dependencies and such</li>
<li><em>priv</em>: Assets/files we want access to from code (static html/js/etc is covered here)</li>
</ul>
<h1 id="the-purescript-bits">The purescript bits</h1>
<ul>
<li><em><a href="https://github.com/id3as/demo-ps/tree/master/server">server</a></em>: The Purescript application that we want to compile into Erlang lives here</li>
<li><em><a href="https://github.com/id3as/demo-ps/tree/master/client">client</a></em>: The Purescript application we want to compile into JS lives here</li>
<li><em>Makefile</em>: Turns the Purescript into JS/Erlang</li>
<li><em>shared</em>: Contains Purescript we&#39;ll share between JS/Erlang</li>
</ul>
<p>In an ideal world, we&#39;d just have a single Purescript entry point and forego our interaction with the Erlang world, but this would involve building out a lot more tooling - the result of this, is that sometimes you will be bringing Purescript dependencies down that require Erlang dependencies and then adding these to rebar.config and the entry point will be your responsibility.</p>
<p>The purescript dependencies can be found in in <em>psc-package.json</em> inside the server and client directories, and the Erlang dependencies can be found in rebar.config at the top level.</p>
<p>As a team already familiar with the Erlang ecosystem, this doesn&#39;t represent a hardship for us; but this definitely represents an area which could be improved by an enterprising developer or two, probably a plugin to the Purescript stack that stashes the rebar assets/etc in another build folder and allows us to just write PS/Erlang in the right place. (But this would then also involve modifying our editor plugins to know about this new structure, and as you can already see, it&#39;s a lot of work when we have something that is already functional..)</p>
<h1 id="that-entry-point-then">That entry point then</h1>
<pre><code class="language-erlang">{application, demo_ps,
 [{description, <span class="hljs-string">"An OTP application"</span>},
  {vsn, <span class="hljs-string">"0.1.0"</span>},
  {registered, []},
  {mod, { bookApp@ps, []}},
  {applications,
   [kernel,
    stdlib,
    lager,
    gproc,
    recon,
    cowboy,
    jsx,
    eredis
   ]},
  {env,[]},
  {modules, []},
  {maintainers, []},
  {licenses, []},
  {links, []}
 ]}.</code></pre>
<p>One of the key things to note here, is that we have cowboy as a dependency, this is to support (as mentioned), the Purescript libraries that binds to it (<a href="https://github.com/id3as/purescript-erl-stetson">stetson</a> and <a href="https://github.com/purerl/purescript-erl-cowboy">erl-cowboy</a>. </p>
<p>The other big note, is that entry point module is <em>&#39;bookApp@ps&#39;</em> - that module can be found in server/src/BookApp.purs, which defines a module <em>&#39;BookApp&#39;</em> - the Purescript compiler will compile Purescript modules into *<moduleName>@ps*, as this is unlikely to clash with anything else in the global application namespace. Beyond this entry point there is no Erlang code in the application itself - it&#39;s Purescript all the way down...</p>
<p>The Makefile in <em>server/Makefile</em> does the work of compiling this Purescript into Erlang that can then be compiled by the usual rebar3 toolchain. The gist of the below Makefile being that we take all the .purs files lying around in the &#39;server&#39; folder, and compile them into .erl files that end up in ../../src/compiled_ps.</p>
<p>We&#39;ll go into detail on the Purescript stuff in the next post, as that&#39;s the key; we put a pile of Erlang supporting files in the right location, and then write PS in the other location and everything &quot;just kinda works&quot;.</p>
]]></description><link>http://codeofrob.com/entries/the-structure-of-an-end-to-end-purescript-otp-project.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-structure-of-an-end-to-end-purescript-otp-project.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 15 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Introducing Pinto and Stetson - Opinionated Purescript bindings to OTP and Cowboy]]></title><description><![CDATA[<p>If you&#39;re reading this, you&#39;ve either been given the link to the posts ahead of time cos you&#39;ve asked to see what is going on, or I&#39;ve hit the publish button in which case hooray. Either way, this is a little series of posts going through some of the Purescript/Purerl code that we&#39;ve quietly open sourced on Github under the Apache 2.0 license. Hopefully betwen these posts, the published markdown docs and the sample application there will be enough to get started with.</p>
<p>Over the last year or so, we&#39;ve been gradually building out our capacity to create applications end-to-end in Purescript, compiled to JS on the front-end and compiled to Erlang on the back, building on top of both OTP and our existing libraries from nearly a decade of company history doing business on top of the Erlang stack.</p>
<p>The repositories we&#39;re looking at are:</p>
<ul>
<li><a href="https://github.com/purerl/">Purerl</a> itself</li>
<li>The <a href="https://github.com/purerl/package-sets">purerl-package-sets</a></li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">Stetson</a> (Opinionated Cowboy bindings)</li>
<li><a href="git@github.com:id3as/purescript-erl-pinto.git">Pinto</a> (Opinionated OTP bindings)</li>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> (end-to-end sample code)</li>
</ul>
<p>The best place to start if you want to dive right in, is probably the demo-ps project as it demonstrates the usage of most of the above, and that is indeed where we&#39;ll be starting in this series.</p>
<h1 id="purerl">Purerl</h1>
<p>The Purerl organisation contains the core sets of bindings to much of Erlang&#39;s base libraries, as well as the fork of the Purescript compiler that can generate Erlang as a backend. </p>
<h1 id="purerl-package-sets">Purerl-package-sets</h1>
<p>Essentially a pile of Dhall that generates a package.json containing a list of versions of the various Purerl libraries that work together, you&#39;ll not need to touch this directly unless you end up using Purerl internally in an organisation and you want to fork it and add your own internal/private Purerl dependencies.</p>
<h1 id="stetson">Stetson</h1>
<p><a href="https://github.com/ninenines/cowboy">Cowboy</a> is the de-facto webserver in the Erlang world, and <a href="https://github.com/purerl/purescript-erl-cowboy">direct bindings</a> exist for the project already, however when it came time to start building applications on top of this, it was clear that there was little gain to be had by directly using them over simply writing Erlang in the first place. Stetson was my attempt to mirror the experience I&#39;ve had in other functional languages using libraries such as <a href="https://github.com/weavejester/compojure">Compojure</a> and <a href="https://github.com/scotty-web/scotty">Scotty</a>. It isn&#39;t by any means complete, and merely serves as a statement of intent around the kind of interaction I&#39;d personally like to have around routing/etc in a Purerl world. I fully hope/expect that somebody will write a native http server in time rather than simply wrapping Cowboy as I have done here.</p>
<h1 id="pinto">Pinto</h1>
<p>There have been a <a href="https://github.com/purerl/purerl_otp_sandbox">few examples</a> written demonstrating how to interact with OTP from Purerl, but again at the point of building a real application, direct bindings don&#39;t offer a good user experience once you start building out functionality and repeating yourself a whole ton. I cheated a lot when putting together Pinto and skipped the direct bindings step, going straight to the &quot;desired usage&quot; step and doing a pile of cheats around types and such. It seeks to largely mirror the existing OTP interactions, but in a more functional manner. Much like with Stetson, I fully expect/hope that in time somebody (maybe even us) will want a more idiomatic Purescript experience and choose to build something even more opinionated outside the familiar comfort of the OTP vocabulary. For now, we have Pinto.. :)</p>
<h1 id="demo-ps">Demo-ps</h1>
<p>This is a completely pointless web app that uses <a href="https://github.com/id3as/purescript-erl-stetson">purescript-erl-stetson</a>, <a href="https://github.com/id3as/purescript-erl-pinto">purescript-erl-pinto</a>, <a href="https://github.com/purerl/purescript-simple-json">purescript-simple-json</a> and <a href="https://github.com/slamdata/purescript-halogen">purescript-halogen</a> to store data in Redis using some FFI and display it in a single page application, sharing the view models between the server and client components. It seeks to demonstrate rough usages of all of these without cluttering up the interactions with &quot;real code&quot; (read: business logic).</p>
<p>Next post, we&#39;ll look at the structure of the demo-ps project, as understanding this is essential if you wish to build your own.</p>
]]></description><link>http://codeofrob.com/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html</link><guid isPermaLink="true">http://codeofrob.com/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 13 Aug 2019 09:30:00 GMT</pubDate></item></channel></rss>