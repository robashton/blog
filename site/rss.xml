<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>NodeJS RSS Module</generator><lastBuildDate>Wed, 27 Feb 2013 11:36:42 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Custom query inputs in RavenDB]]></title><description><![CDATA[<p>Back on the list of things "added to RavenDB" <a href="/entries/working-at-hibernating-rhinos.html">during my time at Hibernating Rhinos</a>, ever wished you could pass custom arguments to the transformer when performing a query in RavenDB?</p>

<p>Well, this has been asked for a number of times and since <a href="/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html'">splitting out results-transformers</a> into their own process, it has become much easier to add this functionality.</p>

<p>What does this look like?</p>

<p>Well, say we have a result transformer that takes Ponies and creates unicorns, only our database doesn't know about horns - let's see what we can do here.</p>

<pre><code>public class Unicorn {
  public string Name { get; set; }
  public string Colour { get; set; }
  public string CutieMark { get; set; }
  public int Hornsize { get; set; }
}

public class PoniesIntoUnicorns : AbstractTransformerCreationTask&lt;Pony&gt; {
  public PoniesIntoUnicorns() {
    Transform = ponies =&gt; from pony in ponies
                          select new {
                            pony.Name,
                            pony.Colour,
                            pony.CutieMark,
                            Hornsize = pony.Size * Query["hornscalefactor"]
                          }
  }
}
</code></pre>

<p>Okay, contrived example but this feature isn't for me and my pony database, it's for you and your requirements, and you know it's you I'm talking about because you're looking at the above and going <em>finally, I've been waiting for this</em>.</p>

<p>How do we use the above?</p>

<pre><code>session.Query&lt;Pony&gt;()
       .Where(pony =&gt; pony.Colour === "purple")
       .TransformWith&lt;PoniesIntoUnicorns, Unicorn&gt;()
       .AddQueryInput("hornscalefactor", 0.1)
       .ToArray();
</code></pre>

<p>Pretty simple and effective, glad I could oblige :)</p>

<p>Oh yeah, it works for Load too</p>

<pre><code>var unicorn = session.Load&lt;PoniesIntoUnicorns, Pony&gt;(
              x=&gt; x.AddQueryInput("hornscalefactor", 0.1))
</code></pre>

<p>Not the tidiest API in the world, but I'm sure it will improve as people actually use it.</p>]]></description><link>http://codeofrob.com/entries/custom-query-inputs-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/custom-query-inputs-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 27 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Talking at DevSum 2013]]></title><description><![CDATA[<p>I've been told I need to tell people when I'm doing talks, so consider this my attempt at making this so.</p>

<p>I'll be talking at <a href="http://devsum.se/">Devsum 2013</a> on the 29th/30th of May on the <a href="http://devsum.se/talare/rob-ashton/">pragmatic outside-in testing of ASP.NET MVC applications</a></p>

<p>I went to Devsum last year and had a lot of fun, last year the venue was just down the road from an Irish Pub and that pretty much put the icing on the cake. Let me know if you're going to be there and we can organise a guinness driven get-together.</p>

<p>Hoping to announce a few other talks here soon, I finish travelling and working around the world at the end of May and I'm available.</p>]]></description><link>http://codeofrob.com/entries/talking-at-devsum-2013.html</link><guid isPermaLink="true">http://codeofrob.com/entries/talking-at-devsum-2013.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 26 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[RavenDB - Avoiding ambiguity in result transformers]]></title><description><![CDATA[<p>So, this is a niche case that is quite annoying for people writing transformers as part of a map or a map/reduce index - and now we have the ability to specify transformers separately to the index this problem only gets worse.</p>

<p>What is this problem?</p>

<p>Well, if I make a map that does this:</p>

<pre><code>public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
{
   public Ponies() {
     Map = ponies =&gt;
           from pony in ponies
           select new {
             pony.Name,
             pony.Colour,
             pony.CutieMark
           }

     Store(pony =&gt; pony.CutieMark, FieldStorage.Yes);
     Store(pony =&gt; pony.Name, FieldStorage.Yes);
     Store(pony =&gt; pony.Colour, FieldStorage.Yes);
   }
}
</code></pre>

<p>Available to me <em>without even loading the document</em> after performing a query, is "Name", "Colour", and "CutieMark". Obviously we can store other things in there as well, and so some funky things in the map - but this is the essence of this functionality.</p>

<p>The same thing happens by default when you apply a reduce stage to an index, because you lose the original document entirely because of aggregation.</p>

<p>This can be a bit confusing, as sometimes you want the result from that store data, and sometimes you want the data from the document, and this has been an all-or-nothing thing.</p>

<p>Now we can <a href="/entries/result-transformers---not-just-for-querying.html">Use Load&lt;></a> with a ResultTransformer, this is even more ambiguous.</p>

<p>So, from now on, whenever you access anything in a ResultTransformer, RavenDB will first look in the stored fields for the information, and if not found - will load the document associated with the current result and fetch it from that.</p>

<p>It's a small change, but one which will remove a lot of the confusion around this feature.</p>]]></description><link>http://codeofrob.com/entries/ravendb---avoiding-ambiguity-in-result-transformers.html</link><guid isPermaLink="true">http://codeofrob.com/entries/ravendb---avoiding-ambiguity-in-result-transformers.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 25 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Result transformers - not just for querying]]></title><description><![CDATA[<p>In the <a href="/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html">last entry</a> I demonstrated a new artifact in RavenDB for transforming results from queries into view models with all the information attached you could think of.</p>

<p>Well, the primary use case (in my mind) for this, is the creation of view models for web clients without having to de-normalise data or perform multiple remote calls.</p>

<p>Well, actually - if we're viewing say, a single item by id, it doesn't make a lot of sense to have to do a query to get that single item by id. It doesn't make a lot of sense to have to create an index for this.</p>

<p>In the past, that's the best we could hope for, unless perhaps you used the 'include' functionality to load related documents and then created the view model in the client out of those related documents. This looks something like this:</p>

<pre><code>var order = session.Include("CustomerId")
                        .Load&lt;Order&gt;("orders/1")

var customer = session.Load&lt;Customer&gt;(order.CustomerId)

// Build view model here
</code></pre>

<p>This is okay and everything, but requires a bit of mental leg-work on the part of the client.</p>

<p>What you really want to do is just ask for the view model, sort of like making a single query in SQL to get all the information you want with one go.</p>

<p>Well, how about this?</p>

<pre><code>  var orderViewModel = session.Load&lt;OrderWithCustomerTransform, OrderWithCustomer&gt;("orders/1")
</code></pre>

<p>That's a lot nicer, the code for this is as thus</p>

<pre><code>public class OrderWithCustomer 
{
   public string OrderId { get; set; }
   public string OrderDate { get; set; }
   public string CustomerId { get; set; }
   public stirng CustomerName { get; set; }
}

    public class OrderWithCustomerTransform : AbstractIndexCreationTask&lt;Order&gt;
    {
         public OrderWithCustomerTransform()
         {
                TransformResults = (database, orders) =&gt;
                        from order in orders
                        let customer = database.Load&lt;Pet&gt;(order.CustomerId)
                        select new {
             OrderId = order.Id,
             OrderDate = order.Date,
             CustomerId = customer.Id,
             CustomerName = customer.Name
                        }
         }
    }
</code></pre>

<p>Being able to compose view models on the server as part of the load process by pulling in related documents and only pull out the fields you need is awesome.</p>

<p>Being able to re-use these transforms across different indexes or load operations and get a consistent return shape is even awesomer.</p>

<p>Tomorrow I'll show a really cool edge case around this, and how we got rid of a lot of he confusion around transforms.</p>]]></description><link>http://codeofrob.com/entries/result-transformers---not-just-for-querying.html</link><guid isPermaLink="true">http://codeofrob.com/entries/result-transformers---not-just-for-querying.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 22 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[RavenDB ResultTransformers - a new way of looking at things]]></title><description><![CDATA[<p>So, how do we solve a problem like TransformResults? Easy! We make ResultsTransfomers!</p>

<p><img src="/img/prime.jpg" alt="Optimus Prime" title="" /></p>

<p>Okay, so what's in a name?</p>

<p>Well, rather than attach the function we want to transform the results with to the index like so</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
              from pony in ponies
              select new {
                pony.Name,
                pony.Colour,
                pony.Trampstamp
                            }
                TransformResults = (database, results) =&gt;
                        from result in results
                        let pet = database.Load&lt;Pet&gt;(result.PetId)
                        select new {
                            PonyId = pony.Id
                            Name = pony.Name,
                            PetName = pet.Name,
                            PetSpecies = pet.Species
                        }
         }
    }
</code></pre>

<p>How about defining it separately like this?</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
            from pony in ponies
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp
                            }
         }
    }
</code></pre>

<p>And</p>

<pre><code>public class PonyWithPetViewModel 
    {
        public string PonyId { get; set; }
        public string Name { get; set; }
        public string PetName { get; set; }
        public string PetSpecies { get; set; }
    }


    public class PoniesWithPets : AbstractTransformerCreationTask&lt;Pony&gt;
    {
         public PoniesWithPets()
         {
              TransformResults = ponies =&gt; 
                        from pony in ponies
                        let pet = database.Load&lt;Pet&gt;(pony.PetId)
                        select new {
                            PonyId = pony.Id
                            Name = pony.Name,
                            PetName = pet.Name,
                            PetSpecies = pet.Species
                        }
         }
    }
</code></pre>

<p>Then, to get a list of ponies with pets in that view model format, we can simply supply the transformer want to use as part of the query</p>

<pre><code>    session.Query&lt;Pony&gt;()
                 .Where(pony =&gt; pony.Name == "Pinkie Pie")
                 .TransformWith&lt;PoniesWithPets, PonyWithPetViewModel&gt;
                 .ToList()
</code></pre>

<p>This is much tidier, and allows us to use transformers to elegantly create view models across any index providing the input is sane enough, it also removes some of the complexity around indexes. Look - we didn't even specify an index for this query and yet we were able to use a transformer on it, dynamic index win!</p>

<p>This actually took a couple of days to implement, but I still have four days of work at Hibernating Rhinos so hopefully more coming soon!</p>]]></description><link>http://codeofrob.com/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html</link><guid isPermaLink="true">http://codeofrob.com/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 21 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[The problem with result transformations in RavenDB]]></title><description><![CDATA[<p>I mentioned yesterday that there are some problems with how <a href="/entries/re-thinking-result-transformations-in-ravendb.html">result transformations work in RavenDB</a></p>

<p>In truth, there are no problems, but as <a href="http://twitter.com/ayende">@ayende</a> mentioned himself, feature intersection is causing issues for development in RavenDB.</p>

<p>What is this feature intersection? Well, we have a <em>lot</em> of features around indexes and queries now, and they're all touching and overlapping in all sorts of strange ways - this is hardly surprising, it happens to many well-used software projects with feature requests flying in every day and so many awesome ideas to implement.</p>

<p>The problem that result transformations were initially trying to solve (and I know, I helped implement them in a hotel lobby with Ayende a couple of years ago), were the question of "joins" across documents. Well - this worked well, and had the added bonus of being able to define the exact result shape coming back from RavenDB (pre-forming entire view models in a single query as it were).</p>

<p>That's great, and now we have the ability to do what we did yesterday with yet another feature, load document in map, like so:</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
                Map = from pony in ponies
                            let pet = LoadDocument(pony.id)
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp.
                                PetName = pet.Name.
                                PetSpecies = pet.Species
                            }
         }
    }
</code></pre>

<p>This is kinda cool, although it has implications in complexity when it comes to the indexing and re-indexing of documents that isn't what this blog entry is about.</p>

<p>We've ended up with information in the index which we might want as part of our output, and it's not immediately obvious how we're going to get that out, and this is also doing quite a bit of the work we might want to do with the result transformation phase. (Feature overlap)</p>

<ul>
<li>How about what happens if we have a standard view model that we want to return from a transform, but several different indexes we might query to do that?</li>
<li>What about what happens we want to do a result transform when performing a dynamic query?</li>
<li>And what if we want to use the stored data in index instead of transforming a loaded document?</li>
</ul>

<p>We've actually got a few <em>niggles</em> around these functionalities too, existing as entries in the issue tracker (such as we don't ignore FieldsToFetch when performing a transform), and we've ended up boolean flags to "SkipTransformResults"!!</p>

<p>In essence, it's a bit messy and there is one immediate step we can take to fix this - any takers on what that might be?</p>]]></description><link>http://codeofrob.com/entries/the-problem-with-result-transformations-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-problem-with-result-transformations-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 20 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Re-thinking result transformations in RavenDB]]></title><description><![CDATA[<p>After all the work on indexes, things started getting downright <em>dirty</em> at the Hibernating Rhinos offices as we looked at re-vamping TransformResults in RavenDB.</p>

<p>First, a re-cap on what TransformResults actually is; consider we have a couple of documents that look something like this:</p>

<p><em>A pony</em></p>

<pre><code>    {
        id: "ponies/rainbowdash",
        name: "Rainbow Dash",
        colour: '#9EDBF9',      // I actually looked this up
        trampstamp: 'rainbow-lightning',
        petid: 'pets/tank'
    }
</code></pre>

<p><em>a pet</em></p>

<pre><code>    {
        id: "pets/tank",
        name: "Tank",
        species: "Tortoise",
        colour: '#0F0'          // I didn't look this up
    }
</code></pre>

<p>Let's say we have an index that looks like this</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
            from pony in ponies
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp
                            }
         }
    }
</code></pre>

<p>When querying for a list of blue ponies, we might actually decide we want to know what species their pets are, we have the following options</p>

<ul>
<li>Include them from the client (This brings back a lot of information that we don't need)</li>
<li>Add a results transformer to the index</li>
</ul>

<p>We mostly end up doing the last one and so we do that and it looks like this:</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
            from pony in ponies
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp
                            }
                TransformResults = (database, results) =&gt;
                        from result in results
                        let pet = database.Load&lt;Pet&gt;(result.PetId)
                        select new {
                            PonyId = pony.Id
                            Name = pony.Name,
                            PetName = pet.Name,
                            PetSpecies = pet.Species
                        }
         }
    }
</code></pre>

<p>This gives us the ability to send only the information we want to the client as well as pull in information from other documents, that's pretty neat, but now it's in need of a bit of TLC, as some of its functionality has been <a href="http://ayende.com/blog/160545/feature-intersection-is-killing-me-referenced-document-indexing">superceded by Referenced Documents in Map</a> and it's a bit awkward as it is.</p>

<p>I'll talk more about that tomorrow when I go into some of the issues that we're experiencing with this feature.</p>]]></description><link>http://codeofrob.com/entries/re-thinking-result-transformations-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/re-thinking-result-transformations-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 19 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Next, we run new RavenDB indexes in memory]]></title><description><![CDATA[<p><a href="/entries/getting-rid-of-temporary-indexes-in-ravendb.html">Other day</a> I wrote about the awesome news that we'd managed to delete an entire code-path from RavenDB as a result of some of the other changes coming in.</p>

<p>Well, it's not quite as simple as that, you see - temporary indexes in RavenDB had a reallly big advantage in that they were run entirely in memory (until they reached a configurable threshold anyway).</p>

<p>That's good, because  indexes and running data through indexes is typically an IO bound process, and if we can keep the indexes in memory while we work on them, the whole proces can be a lot more efficient.</p>

<p>Well, having gotten rid of an entire code path, surely it makes sense to move the code that used to do this to be applicable to all indexes?</p>

<p>Absolutely, so starting from whenever my pull request gets merged, all new indexes in RavenDB will be ran in memory to begin with (meaning you get less stale results much faster - great if you're using the auto-indexes or experimenting with manual indexes on large sets of data).</p>

<p>After the index has caught up with reality, it will be flushed to disk and celebrations will be had, or if the index reaches a configurable memory threshold that will happen too.</p>

<p>This is a small change that makes a big difference, and is possible (in part) because we managed to get rid of having two different types of index and two different code paths.</p>

<p>In the next entry, I'll talk about further optimisations made in this pull request to do with auto indexes.</p>]]></description><link>http://codeofrob.com/entries/next,-we-run-new-ravendb-indexes-in-memory.html</link><guid isPermaLink="true">http://codeofrob.com/entries/next,-we-run-new-ravendb-indexes-in-memory.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 18 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Automatically merging indexes in RavenDB for optimal performance]]></title><description><![CDATA[<p>So, we can mark indexes as idle, we can automatically do this to auto indexes, and we delete auto indexes that aren't being used enough - that paves the way for a pretty useful feature - merging automatic indexes for fun and for profit.</p>

<p>What is that you ask? Well - when we do the following series of queries</p>

<pre><code>session.Query&lt;Pony&gt;()
    .Where(pony =&gt; pony.Name == "Rainbow Dash")
    .FirstOrDefault()
</code></pre>

<p>and</p>

<pre><code>session.Query&lt;Pony&gt;()
        .Where(pony =&gt; pony.Colour == "Pink")
        .ToList()
</code></pre>

<p>We will end up with the following indexes in RavenDB</p>

<p><em>Pony/Name</em></p>

<pre><code>    from pony in ponies
      select new {
        pony.Name
      }
</code></pre>

<p><em>Pony/Colour</em></p>

<pre><code>    from pony in ponies
      select new {
        pony.Colour
      }
</code></pre>

<p>Well, in reality there is no real reason why we'd have two indexes and incur the cost of iterating over documents every time they're added more often than we need.</p>

<p>One of the things that the query optimiser already does, is look for the 'widest' index - that is the index that touches the most fields.</p>

<p>It makes sense therefore, that rather than simply look for the widest index that matches the query, we should look for the most compatible index and create a new one based off of that if it doesn't match completely.</p>

<p>Consider the above, we should end up with two indexes</p>

<pre><code>    from pony in ponies
      select new {
        pony.Name
      }
</code></pre>

<p>and</p>

<pre><code>    from pony in ponies
      select new {
        pony.Name,
        pony.Colour
      }
</code></pre>

<p>Over time, the first index won't be used (as it's not as wide as the second index), and it will wither and die because of idling and auto-removal.</p>

<p>Over time, we'll actually end up with only one index per document type (providing there aren't any reasons why a query isn't compatible with an existing index, such as different indexing or sorting options)</p>

<p>This ensures that over time when using automatically generated queries, that RavenDB keeps itself as lean as possible and using as few resources as possible (and tidy!)</p>

<p>Now that covers what I did on in first couple of days at Hibernating Rhinos, next up I'll talk about what I'm helping do with result transformations.</p>]]></description><link>http://codeofrob.com/entries/automatically-merging-indexes-in-ravendb-for-optimal-performance.html</link><guid isPermaLink="true">http://codeofrob.com/entries/automatically-merging-indexes-in-ravendb-for-optimal-performance.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 15 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Getting rid of temporary indexes in RavenDB]]></title><description><![CDATA[<p>I talked about RavenDB's new ability to promote and demote automatically created indexes <a href="/entries/auto-idling-auto-indexes-in-ravendb.html">yesterday</a>, but what are the implications of this?</p>

<p>I mentioned that the process in RavenDB for managing dynamically created indexes is as thus:</p>

<ul>
<li>Look for appropriate index to use in query</li>
<li>If found, return the most appropriate index</li>
<li>If not found, create an index that will deal with the query</li>
<li>Return that index as a Temporary</li>
<li>If that index is used enough, promote it into an Auto index</li>
<li>If that index is not used enough, delete it</li>
</ul>

<p>Well, we now have a way of marking indexes as idle and therefore not taking up needless resources, we can <em>remove temporary indexes entirely</em>.</p>

<p>That's actually a lot of code we can remove, in fact a pile of code that I wrote over two years ago, that's kinda cool, as it means entire code-path that doesn't need maintaining any more.</p>

<p>Obviously we can still remove auto indexes that were only queried once or twice, but that can take part with the algorithm that marks them as idle, and to make things even better we can add some functionality to the Studio to manage these idle indexes or delete them.</p>

<p>Now, this still isn't as awesome as it could be, but we've laid the ground work for a pretty awesome feature, I'll talk about that tomorrow.</p>]]></description><link>http://codeofrob.com/entries/getting-rid-of-temporary-indexes-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/getting-rid-of-temporary-indexes-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 14 Feb 2013 12:34:00 GMT</pubDate></item></channel></rss>