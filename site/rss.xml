<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><generator>NodeJS RSS Module</generator><lastBuildDate>Mon, 07 May 2012 11:16:10 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Github Live]]></title><description><![CDATA[<h5>Visualize git 'pushes' live as they happen across Github.</h5>

<p>I visited <a href="https://twitter.com/#!/cranialstrain">@cranialstrain</a> in England this weekend, and he suggested we hack something together around the Github APIs in response to the <a href="https://github.com/blog/1118-the-github-data-challenge">Github data challenge </a>.</p>

<p>Looking at the Event stream, I thought it would be interesting to visualise what was going on in live, in a web browser, and given all the toys I've written over the past year or so in NodeJS, it was fairly clear that a simple web server processing the events and broadcasting them to clients wouldn't take a lot of work to complete.</p>

<p>So, we ended up with <a href="http://githublive.codeofrob.com">Github Live</a>, which looks something like this once you've left it running for five minutes (during the morning, so it's a bit quiet)</p>

<a href="/img/githublive.png"><img src="/img/githublive.png" width="640px"></img></a>

<p><strong>The server side</strong></p>

<p>The server is using Node, which is operating as a basic static file server, and as a point of call for incoming sockets with socket.io.</p>

<p>It starts off every 10 seconds polling the Events API, storing the most recent timestamp so to avoid publishing duplicates (the events API doesn't have a "last retrieved id").</p>

<p>It attempts to throttle requests to the events API to avoid the amount of duplicate events being retrieved from the API (if it finds an overlap, it increases the time until next request by a second, and if it doesn't, it decreases by a second).</p>

<p>In hindsight, the hideous inline callbacks would be best replaced with a stream that did all this work, and just published events transparently to the consuming code.</p>

<p>The next job, once this has taken place is that a request is made to Github for each pull, asking for information about the repository (for the language), so the events being streamed to the clients can be augmented with this information.</p>

<p>This is another thing that should be dealt with by a stream rather than inline callback soup.</p>

<p>Oh well, it's only 200 lines of throwaway code, perhaps something to tidy up on a rainy day.</p>

<p><strong>The client side</strong></p>

<p>Because it's quick and easy, we're using HTML and CSS3 to do display and transformations.</p>

<p>As the events stream in from the server, some HTML is created for the event and it is put in an appropriate bucket (for the language being used).</p>

<p>The outside container has a CSS transition applied to it, and the transform 'scale' is set to fit all buckets into the same window periodically.</p>

<p>From this I have ascertained that</p>

<ul>
<li>I dislike vendor prefixes</li>
<li>these are not as fast as I'd like</li>
<li>Webkit has some unusual glitches if you're not careful</li>
</ul>

<p>I guess with some more work, these things could be worked around, there are some definite performance improvements that could be made client side here.</p>

<p>I'd quite like to give an SVG implementation a go, and see about the performance of that. Another project for a rainy weekend.</p>

<p><strong>The code</strong></p>

<p>The code in all its (raw) form can be found at<a href="https://github.com/robashton/githubfall"> https://github.com/robashton/githubfall</a></p>

<p>I'd be interested to see any obvious improvements made and pull requested in.</p>
]]></description><link>http://codeofrob.com/entries/github-live.html</link><guid isPermaLink="true">http://codeofrob.com/entries/github-live.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 07 May 2012 12:28:00 GMT</pubDate></item><item><title><![CDATA[Anatomy of a 48 hour HTML5-JS Game]]></title><description><![CDATA[<p>I participated in my second <a href="http://www.ludumdare.com/compo/">Ludum Dare</a> 48 hour game-building compo this weekend, and this was my fourth attempt at <a href="http://www.ludumdare.com/compo/ludum-dare-23/?action=preview&amp;uid=7112">building a game from scratch</a> in 48 hours in HTML5/JS.</p>

<p>Each time I have approached the problem in a slightly different way, but I'm beginning to get the process sussed (with a few caveats) so let's break down my latest attempt (<a href="http://www.ludumdare.com/compo/ludum-dare-23/?action=preview&amp;uid=7112">Web</a> | <a href="https://github.com/robashton/ld4823tw">Source</a>) and see how it is put together.</p>

<h2>Libraries + Frameworks</h2>

<p>I've tried a couple of approaches for this so far, one is to start with a set of 'base code' (written in advance either extracted from another project, or written especially for the 48 hour compo).</p>

<p>I've ended up settling for a halfway house, I have some libraries that I <em>really</em> like from JS/HTML development in general, and some libraries/components that I keep around for convenience.</p>

<p><strong>Third party</strong></p>

<p><em><a href="http://documentcloud.github.com/underscore/">Underscore</a></em> - this is a library containing a load of polyfills for doing common operations in JS (iteration, binding, etc) - my favourite method is probably _.extend, which I'll cover in a bit.</p>

<p><em><a href="http://jquery.org/">jQuery</a></em> - we all know what this is - to be honest, I use it for DOM selection and the most basic of manipulation only - as such it's a bit heavy-weight for what I need. Still - it's familiar to me and allows me to get started - can't say wrong with that.</p>

<p><strong>Hand-rolled components</strong></p>

<p><strong><a href="https://github.com/robashton/swallow">Swallow</a></strong> - Packaging up a directory as a JSON file and downloading it all-as-one might not be the most elegant/modern way of dealing with multiple assets but it at least allows an easy deterministic way of dealing with dependencies, and means that I forego a lot of the issues with playing Audio in browsers (creating a new audio file with a URL means the browser re-downloading the asset!). </p>

<p>Base64 encoding all the binary assets and getting on with life means not faffing around with them during the compo - which is a good thing.</p>

<pre><code>// Build script
swallow.build({
    in: 'assets',
    out: 'site/assets.json'
});

// Client code
GlobalResources.loadPackage('assets.json', function() {
    game.start();
});

GlobalResources.getImage('image.png');
GlobalResources.playSound('explosion');
</code></pre>

<p><strong><a href="https://github.com/robashton/camera">Camera</a></strong> - Separation of in-game coordinates from the pixels being displayed on screen is pretty important because otherwise we limit ourselves to a specific resolution and aspect ratio, and prevent our application from being run at different resolutions on different screens.</p>

<p>The principle of this tiny piece of code is that rather than drawing using 'screen coordinates', we draw using 'world coordinates' and haven't got to any of the transformations ourselves in expensive JS.</p>

<p>For example,</p>

<pre><code>context.fillRect(0, 0, 100, 100);
</code></pre>

<p>Would ordinarily fill a rectangle 100 pixels by 100 pixels at the top-left of the screen, but if we apply transforms to the underlying canvas as if we had a camera moving over it, using the following code</p>

<pre><code>camera.lookAt(50, 50);
camera.zoomTo(100);
camera.fieldOfView(Math.PI / 4);
</code></pre>

<p>Then the same fillRect code will be drawing the same rectangle  (roughly) in the middle of the screen. </p>

<p>The advantage of this code is that the same picture can be drawn whether the canvas is sized at 320x240, 640x480, 800x600 (and can even handle strange aspect ratios). In case of bad performance, the canvas size can be set to half the size of the actual display and upscaled automatically!</p>

<p><strong>Eventable</strong> - I've found that messaging is the best way to keep the ability to crank out features without littering the codebase with conditionals and irrelevant code, I have a basic set of behaviours in an object called "Eventable" that looks like</p>

<pre><code>on(event, callback, context)
onAny(callback, context)
off(event, callback, context)
offAny(callback, context)
</code></pre>

<p>I also have a basic <strong>Scene</strong> object, through which all entity events bubble up through for caretaker objects to deal with, consider the following scenario from my #LD23 game</p>

<ul>
<li>EnemyFactory decides to spawn an Asteroid</li>
<li><p>EnemyFactory hooks '<em>Destroyed</em>' event on Asteroid</p>

<pre><code>   asteroid.on('Destroyed', this.onAsteroidDestroyed, this);
</code></pre></li>
<li><p>Asteroid goes off and does its thing</p></li>
<li>Player blasts away Asteroid</li>
<li><p>Asteroid raises event like so:</p>

<pre><code>this.raise('Destroyed');
</code></pre></li>
<li><p>EnemyFactory removes the Asteroid from the scene</p></li>
<li>Also listening to events from the scene are
<ul>
<li>ExplosionCreation</li>
<li>ScoreKeeper</li>
<li>SoundCreation</li>
</ul></li>
</ul>

<p>They hooked the events from the scene when they were added to it like so</p>

<pre><code>scene.on('Destroyed', this.onEntityDestroyed, this);
</code></pre>

<p>And in their respective methods they get to do</p>

<pre><code>onEntityDestroyed: function(data, sender) {
    this.createExplosion(sender.x, sender.y);
}

onEntityDestroyed: function(data, sender) {
    this.increaseScore(sender.getPoints() * this.currentLevel);
}

onEntityDestroyed: function(data, sender) {
    this.playSound('explosion', sender.x, sender.y);
}
</code></pre>

<p>Having the ability to slap on extra functionality without creating masses of extension code meant that throwing in power-ups was a simple matter of creating something to listen to destruction events and add new entities to the scene to represent as power-ups.</p>

<p>Keeping the UI updated looks something like this:</p>

<pre><code>var Hud = function(scene) {
    scene.autoHook(this);
    this.score = $('#score');
    this.health = $('#health');
    this.energy = $('#energy');
};
Hud.prototype = {
    onScoreChanged: function(score) {
        this.score.text(score);
    },
    onHealthChanged: function(health, sender) {
        if(sender.id !== 'player') return;
        this.health.css('width', sender.percentageHealth() + '%');
    },
    onEnergyChanged: function(energy, sender) {
        if(sender.id !== 'player') return;
        this.energy.css('width', sender.percentageEnergy() + '%');
    }
}
</code></pre>

<p>Hmmm, tidy.</p>

<p>I choose not to publish this as a library, because this is something specific to the way I like to work and everybody is either using one that already exists or are capable of writing on themselves.</p>

<h2>Patterns and Practises</h2>

<p><strong>Working in a single file</strong></p>

<p>When working on my more long-term projects, I often use a dependency/module system like RequireJS to break up the project across multiple files (one-per-class type of thing)</p>

<p>When working on a 48 hour game jam, I find that just coding everything in a single file like a madman is really helpful providing I'm using a good text editor with the ability to search and jump around the document built in.</p>

<p><strong>Working with "Classes"</strong></p>

<p>I admit it, I'm a sucker for encapsulating state and behaviour into discrete little objects that I can create and throw around the place,</p>

<p>The thing is, because JS allows for duck-typing, this object flinging makes throwing things into a scene and performing operations on them pretty convenient.</p>

<p>For example, I have a scene object, which exposes the following methods, and at its most simplistic looks something like this:</p>

<pre><code>add: function(entity) {
    this.entities[entity.id] = entity;
},
remove: function(entity) {
    delete this.entities[entity.id];
}
tick: function() {
    this.eachEntity(this.entityTick);
},
entityTick: function(entity) {
    if(entity.tick) entity.tick();
},
draw: function(context) {
    this.eachEntity(this.entityDraw, context);
},
entityDraw: function(entity, context) {
    if(entity.draw) entity.draw();
}
</code></pre>

<p>Now, in my long-term projects, drawing/logic/etc are just components that are attached to the entities, and the scene is certainly not responsible for this stuff - but for this kind of rapid-work project having something really simplistic really aids in the development process.</p>

<p>The important things of note, is above - we only care that an entity has a field called 'id', we don't care where it got it from - and if that entity has a draw method, we'll use it and if the entity has a tick method, we'll use that too.</p>

<p>I don't bother trying to emulate classic inheritance, even in something as simplistic as this it's not desirable (and leads to more complexity). I do however make judicious use of underscore's 'extend' method.</p>

<pre><code>// Basic rendering functionality for a textured quad
var Quad = function() {
    // stuff
};

Quad.prototype = {
    draw: function(context) {}; // stuff
}

// A basic powerup which floats towards the player
var Powerup = function(image, x, y) {
    Quad.call(this, image, x, y);
    Eventable.call(this);
    this.id = IdGenerator.Next("powerup");
};
Powerup.prototype = {
    tick: function() {
        this.moveTowardsPlayer();
    },
    notifyCollision: function(other) {
        if(other.isPlayer())
            this.bestow();
    }
};
_.extend(Powerup.prototype, Quad.prototype, Eventable.prototype);

// An actual powerup
var DestructionFieldPickup = function(x, y) {
    Powerup.call(this, "destructionfield.png", x, y );

};
DestructionFieldPickup.prototype = {
    bestow: function() {
        this.scene.addEntity(new DestructionField(this.x, this.y));
    }
}
_.extend(DestructionFieldPickup.prototype, Powerup.prototype);
</code></pre>

<p>I'd usually shy away from such hierarchies, but in a 48 hour jam they're a really easy way of throwing functionality in with gay abandon (remember, I don't need to maintain this code, I don't need to remember that the Pickup somehow magically has an 'x' value 2 months later, I don't need to remember what fields have already been declared so not to overwrite them etc).</p>

<p>Working with such lightweight base components and with such explicit objects means that providing my codebase remains below 2000 lines of code (about the maximum deliverable for a solo 48 hour jam if I'm honest), I can keep it all in my head and not fuss around too much.</p>

<p>At least they're relatively small and (mostly) hide their data, and hold onto the functionality they expose in neat, readable blobs.</p>

<h2>Assets</h2>

<p>I'm not an artist, and I'm not a sound engineer either, I have found however that with Inkscape it is possible to create relatively non-sucky art with the combination of geometric shapes.</p>

<p><img src="../img/ship.png" alt="" /></p>

<p>Including these is simple, as they're bundled up with Swallow - however, sounds are more tricky.</p>

<p>Sound on the internet SUCKS.</p>

<p><strong>SUCKS. SUCKS SUCKS.</strong></p>

<p><em>breath</em>, basically you'll be fine if you use a combination of <strong>ogg vorbis</strong> and <strong>MP3</strong>, and don't worry about the older browsers.</p>

<p>In a little game like this, I don't worry about the cost and simply download both files all of the time (in swallow), I guess I could package them up individually and do a check on start-up, and perhaps a little library is warranted (either one on the internet or hand-rolled)</p>

<p>The code for playing a sound goes as follows therefore:</p>

<pre><code>playSound: function(path) {
  var player = new Audio();
  if(player.canPlayType("audio/mpeg")) {
    player.src = "data:audio/mpeg;base64," + this.findData(path + '.mp3');
  } else {
    player.src = "data:audio/ogg;base64," + this.findData(path + '.ogg');
  }
  player.volume = 0.5;
  player.play();
}
</code></pre>

<p>This will work okay, as the data is cached (so no faffing with re-load pauses).</p>

<h2>In Summary</h2>

<p>In a 48 hour game jam, I've found that productivity is <em>much</em> more important than the long-term maintainability of the code, but this does not mean abandoning some sensible software practises, as short term maintainability is still important (keeping 2000 lines of procedural spaghetti code in your head isn't quite as easy...).</p>

<p>Any questions? The code is over <a href="https://github.com/robashton/ld4823tw/blob/master/site/game.js">here</a>, and the above should help with the navigation a bit...</p>
]]></description><link>http://codeofrob.com/entries/anatomy-of-a-48-hour-html5-js-game.html</link><guid isPermaLink="true">http://codeofrob.com/entries/anatomy-of-a-48-hour-html5-js-game.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 23 Apr 2012 12:34:00 GMT</pubDate></item><item><title><![CDATA[Asset packaging in browser based games]]></title><description><![CDATA[<script type="text/javascript">
 setTimeout(function() {
   window.location = "http://altdevblogaday.com/2012/03/28/asset-packaging-in-browser-based-games/";
 }, 2000);
</script>

  <p>I'm redirecting you to <a href="http://altdevblogaday.com/2012/03/28/asset-packaging-in-browser-based-games/">http://altdevblogaday.com/2012/03/28/asset-packaging-in-browser-based-games/</a> with JavaScript, feel free to skip the setTimeout call I've used</p>
]]></description><link>http://codeofrob.com/entries/asset-packaging-in-browser-based-games.html</link><guid isPermaLink="true">http://codeofrob.com/entries/asset-packaging-in-browser-based-games.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 30 Mar 2012 07:54:00 GMT</pubDate></item><item><title><![CDATA[Anti-templating languages]]></title><description><![CDATA[<p>I don't really like templating languages or view engines (especially in JavaScript) - it's something I've been vocal on in person for a while now but never got around to writing about.</p>

<p>Things like this have been <a href="http://www.workingsoftware.com.au/page/Your_templating_engine_sucks_and_everything_you_have_ever_written_is_spaghetti_code_yes_you">ranted on</a> before by other people, but I want to share my particular dislike of the frameworks and technologies here, as well as present up the way I'm currently working.</p>

<p><strong>Logic in your views</strong></p>

<p>Now, we all know this isn't a good idea, but what do we really mean by this? What are the problems we're facing?</p>

<p><strong>EJS</strong></p>

<p>EJS is a view engine similar in nature to WebForms in ASP.NET, which means for .NET devs it's often reached at for its comfortable familiarity and lack of learning requirements.</p>

<p>Let's look at the default example on the EJS website to understand this</p>

<pre><code>&lt;ul&gt;
&lt;% for(var i=0; i &lt; supplies.length; i++) {%&gt;
   &lt;li&gt;&lt;%= supplies[i] %&gt;&lt;/li&gt;
&lt;% } %&gt;
&lt;/ul&gt;
</code></pre>

<p>EJS promises to "<em>Clean the HTML out of your JavaScript</em>", and the very first demo shows us an example of HTML which has been dirtied with JavaScript.</p>

<p>This is just moving the problem around, this is very much a case of "logic in the view" and it makes it difficult to maintain because it's difficult to read and it's hard to tell where the HTML begins and where the HTML ends.</p>

<p>Standard practise might be to do something like this:</p>

<pre><code>&lt;ul&gt;
    &lt;%= Helpers.RenderList(supplies) %&gt;
&lt;/ul&gt;
</code></pre>

<p>But this just means I've moved the HTML back into my JavaScript again. I guess what we're saying here, is that trying to arbitrarily separate 'view' from 'logic' in this manner is a fools errand, doomed to fail because all we're doing is moving the problem around.</p>

<p><strong>Mustache</strong></p>

<p>Mustache is a "logic-less" templating language (they say so on their site), there are other "logic-less" templating languages around too and they're all much of a muchness.</p>

<p>I quote:</p>

<blockquote>
  <p>We call it "logic-less" because there are no if statements, else clauses, or for loops. Instead there are only tags.</p>
</blockquote>

<p><em>for-loop-replacement:</em></p>
<pre><code>
    &lt;ul&gt;
    {{#supplies}}
      &lt;li&gt;{{text}}&lt;/li&gt;
    {{/supplies}}
    &lt;/ul&gt;
</code></pre>

<p><em>if-else-statement-replacement</em></p>

<pre><code>
{{#shipped}}
    &lt;li&gt;This product shipped on {{shipdate}}&lt;/li&gt;
{{/shipped}}
{{^shipped}}
    &lt;li&gt;This product has not yet shipped&lt;/li&gt;
{{/shipped}
</code></pre>

<p>This is just a for loop and an if-else statement but with different syntax, pretending they're otherwise is doing a disservice to everybody who is going to be reading and writing this code.</p>

<p>Adding onto this, we of course also have the ability to seamlessly call methods from Mustache because we're always going to need to write code somewhere (Well, it's one way to keep logic out of the view by.. err calling logic from the view) <i>(see above re: arbitrary separation)</i>.</p>

<pre><code>{{#wrapped}}
  {{name}} is awesome.
{{/wrapped}}

{
  "name": "Rob",
  "wrapped": function() {
    return function(text) {
      return "&lt;b&gt;" + render(text) + "&lt;/b&gt;"
    }
  }
}
</code></pre>

<p>This serves to just confuse though, as the fact a method is being called is hidden from us and means we're reduced to jumping between template and code to work out what is going on.</p>

<p><strong>A shared concern</strong></p>

<p>I have a problem that's shared across all of these solutions though, and that's the one of dealing with external designers.</p>

<p>I have only once worked in a situation where I was privileged enough to work with a designer who knew her HTML and Webforms syntax and could be taught more if needed because she was a permanent member of our team. <em>(And that was only because I spent months campaigning to get somebody who knew what they were doing when it came to making things look pretty!)</em></p>

<ul>
<li>I want to be delivered clean HTML which I can use in my application</li>
<li>I want to be able to integrate updates to that HTML if need be</li>
<li>Teaching a contractor how to use 'template language X' is a waste of my money</li>
<li>Finding a contractor who knows 'template langauge X' is a waste of my time</li>
</ul>

<p>Here in lies a problem - the moment we go to any templating language/system that isn't <em>just</em> HTML, we have to transform what the designer has given us into that templating language - and then translate it back when patching in any amendments that might come as we continue developing.</p>

<p><strong>Performance</strong></p>

<p>Not only those points, but if we're truly going to have a logic-less templating language and we're using third party APIs in any way (whether they be third-third party, or just plain old third party) then in order to get the data into a shape fit for binding directly to your template, transforms must be done which means writing mapping code one way or another.</p>

<p>It's not healthy I tell you - if you're going to transform one set of data into other data that is an exact match of your view requirements, and then transform from that data into another set of data (your view) then you're paying a cost for this. (Throw in your favourite MVC/MVVM framework for JS and even more so, but that's another blog entry entirely).</p>

<p><strong>So what do I like then?</strong></p>

<ul>
<li>Accept that a for loop is a for loop</li>
<li>Accept that an if statement is an if statement</li>
<li>Accept that you're always going to need some of these things in your applications</li>
<li>Accept that the above is best suited to being in a programming language of some sort</li>
</ul>

<p>We have a great opportunity in JS, where we have a language that has been built almost for the primary purpose of interacting with the output that the user sees and where we have libraries whose sole purpose is the interaction <em>with</em> that output.</p>

<p><em>Use the force</em></p>

<p>Enter the anti-templating system "<a href="https://github.com/flatiron/plates">Plates</a>" (there are others that are similar, but this is what I'm using at the moment, as it's isomorphic, fast with no-frills and hopefully will remain so - despite the "issue" reports asking for "nesting" or "collections" etc - as they're missing the point).</p>

<p>Rather than being a templating language, Plates merely binds data to HTML. </p>

<p>HTML!! You know - the stuff that you're going to give to the browser, the  stuff which your designer gives you - the stuff that everybody on the internet and their pet animals know how to use.</p>

<p>Given some HTML:</p>

<pre><code>&lt;div id="test"&gt;&lt;/div&gt;
</code></pre>

<p>And some model:</p>

<pre><code>{ 
    "test": "hello"
}
</code></pre>

<p>Then </p>

<pre><code>Plates.bind(html, model);
</code></pre>

<p>Combined with a bit of JavaScript this gives us enough power to do everything we'd want to do when it comes to taking some data and displaying it on a page. <em>(Yes, it supports matching by class, yes it supports putting data into attributes on those elements, this is all trivial).</em></p>

<p><em>How does it all fit together?</em></p>

<p>Well, I tend to either keep the HTML snippets which I'm going to hydrate on the page itself in a hidden div, or if they're shared templates, as files which I can pull down with a HTTP GET (not rocket science really).</p>

<p>How do I deal with collections? Easy - I write a for loop. How do I deal with different paths? I want an 'if' statement.</p>

<p><em>But don't you end up with spaghetti code?</em></p>

<p>Well no - just because I'm not following an enforced and arbitrary separation of 'view' and 'logic' doesn't mean I'm throwing away sensible software practises.</p>

<p>It's just, that separation comes naturally on a case-by-case basis.</p>

<p>Sometimes I'll end up with some code that matches the model purely on convention and I can write</p>

<pre><code>hydrateTemplate('source', 'target', data);
</code></pre>

<p>Sometimes I'll end up with builders that look like this</p>

<pre><code> startTemplateWithId('targetId')
    .withText('title', data.title)
    .withText('name', data.name)
    .withCollection('itemList', data.items, getItemHtml)
    into('placeholder');
</code></pre>

<p>Or similar (although in most simple cases this kind of over-blown code isn't needed).</p>

<p>My mark-up remains clean, my model remains clean, and the code that lies between is kept clean, tidy and to the point - not to mention re-usable where appropriate because it's <em>just code</em>.</p>

<p>When asked where this style fits in, I'd say it's essentially just MVP, with the line between V and P moving around to fit the situation.</p>

<p><strong>Summary</strong></p>

<p>Separation of view and logic isn't going to happen along any sort of neat line without silly amounts of abstraction; use something that allows you to have clean HTML and clean JavaScript with as little bullshit in-between as possible. </p>

<p>You'll be happier, your code will be happier and you'll find it is a lot easier to deliver a product when you stop arguing about whether you have enough separation in your abstractions.</p>


]]></description><link>http://codeofrob.com/entries/anti-templating-languages.html</link><guid isPermaLink="true">http://codeofrob.com/entries/anti-templating-languages.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 28 Mar 2012 16:34:00 GMT</pubDate></item><item><title><![CDATA[Lessons learned building a multiplayer game in NodeJS and WebGL]]></title><description><![CDATA[<p>I've uploaded Hoverbattles to its own server on EC2, and it has been running fine with an uptime of over 96 hours so far, and this is great!</p>

<p><a href="http://hoverbattles.com">http://hoverbattles.com</a></p>

<p>I've wanted to share a few of the mistakes/lessons learned writing and deploying a multiplayer game built entirely with JavaScript on top of <a href="http://nodejs.org/">NodeJS</a> and <a href="http://learningwebgl.com/blog/">WebGL</a> for a while and this represents an opportune moment to do so. </p>

<p>I've gone with a brain-dump of various related learnings, as well as a couple of periphery items - first off, we'll go with the reason I couldn't keep Hoverbattles up on the old server.</p>

<p><strong>Deploy long-running, processor-intensive node apps to decent hardware</strong></p>

<p>If you're going to deploy a long running node application that is going to be running a constant load, don't deploy it to either:</p>

<ul>
<li>A micro instance of EC2</li>
<li>A really low budget VPS</li>
</ul>

<p>This might be plain old obvious to most people, but apparently not to me - I first deployed to my own VPS, and found that after it had been running for an hour or so it consumed all the memory on the server and fell over in a steaming heap.</p>

<p>I tried to find a memory leak in Hoverbattles itself, I changed to various versions of node, I re-built various components of the OS and nothing seemed to work. I wasn't able to reproduce the issue on my meaty laptop and I gave up for a while, as I was working on a new project.</p>

<p>Turns out that by running long running processes on a virtualised OS on oversubscribed hardware, the OS is lied to, or it lies to you and things don't work quite well. Some of the more knowledgeable types could probably tell us why - but the bottom line is you shouldn't be doing it.</p>

<p><strong>Note:</strong> This probably doesn't go for simple websites built on top of node in express or whatever, I'm talking about long running applications that are doing processing almost constantly, like the server-side component to a 'realtime' multiplayer game.</p>

<p><strong>If you're really going to share code between client + server, plan this accordingly</strong></p>

<p>With Hoverbattles, it started off as a purely client-based game, with JavaScript files being included in the main HTML file and this worked great while I was experimenting with the WebGL and working out how everything was going to work.</p>

<p>I soon moved to having a server implementation running the logic, and ported everything across to <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS</a>, using <a href="https://github.com/sstephenson/stitch">Stitch</a> to package up all of the files so I could use them on the client.</p>

<p>This is actually problematic, as you don't want <em>all</em> the code on the client, and you don't want <em>all</em> the code on the server - with CommonJS you'll only get the code loaded on the server that is used there, but if you're stitching your entire /src folder, you're potentially also sending down code for your persistence, communication, 'secret sauce' stuff etc.</p>

<p>I ended up solving this in Hoverbattles by having a folder structure of:</p>

<pre><code> /shared
 /server
 /client
</code></pre>

<p>This is a bit hideous and arbitrary - and doesn't allow me to organise my codebase naturally along its logical borders, and it's for that reason in my latest projects I've switched across to using <a href="http://requirejs.org/">RequireJS</a>.</p>

<p>By writing different entry points to the same code, and simply boot-strapping in various sub-systems and behaviours from those call-sites, you can naturally end up with a dependency chain that only includes code relevant to the platform for which it is targetted. </p>

<p><strong>Avoid creating new objects in the main event loop</strong></p>

<p>This is obvious too if you've been developing any sort of large scale JavaScript application, or you come from an unmanaged background where this is something you learn not to do from very early on - but I've been developing in a mostly managed world for a few years (C#) and creating objects doesn't carry with it the same overhead so you become quite cavalier to it.</p>

<p>I started profiling Hoverbattles a few weeks in and was surprised to find out that 70% of my CPU time was spent in a single method, that is:</p>

<pre><code>vec3.create();
</code></pre>

<p>Vec3 is an object literal from <a href="https://github.com/toji/gl-matrix">glMatrix</a> containing useful functions for manipulating and creating vectors on top of the typed arrays available in WebGL compatible browsers - these are cool for a number of reasons (performance oriented reasons mostly) and I didn't really think twice about my usage here.</p>

<p>Consider the following imaginary method called once a frame for each missile currently active in the scene.</p>

<pre><code>calculateDistanceToTarget: function() { 
  var difference = vec3.create();
  var targetDestination = this.target.position;
  vec3.subtract(targetDestination, this.position, difference);
  return vec3.length(difference);
};
</code></pre>

<p>This is a really bad idea, and I had code lying around all over the place that would do this - create a temporary float array in order to perform some calculation and then carry on.</p>

<p>The answer was to create a buffer or two on start-up for each system that needed to do things like this, then the code looks something like this.</p>

<pre><code>calculateDistanceToTarget: function() { 
  var targetDestination = this.target.position;
  vec3.subtract(targetDestination, this.position, this.sharedVec3);
  return vec3.length(this.sharedVec3);
};
</code></pre>

<p>This isn't too nice, but so long as you keep the use of this shared buffer to a single method (IE, write into it, then read out of it immediately) then there are no issues with multiple methods across the system using this data.</p>

<p>On that note though...</p>

<p><strong>Private state should remain private</strong></p>

<p>I got in the habit in Hoverbattles of being a bit cavalier about accessing state and simply doing direct property access across objects in order to perform calculations. In some cases this isn't a bad idea and keeps the code legible and fast. In most cases it's a lot of coupling added for little gain - especially if you start to write back to those fields later.</p>

<p>Just like in C#, property/field access is generally a bad idea, you should be asking objects questions which they can answer, and giving them extra information for those questions if they need it - and you should definitely be telling them to do things instead of taking that responsibility away from them.</p>

<p>The thing is, in most LOB apps this is really not that big a deal, CRUD is boring, the applications we build are boring, we can get away with this stuff. When you're dealing with a game world where dozens of things are going on 30 times a second, controlling access to state starts to become important. <em>Lesson learned.</em></p>

<p>Consider instead our earlier example of:</p>

<pre><code>calculateDistanceToTarget: function() { 
  var targetDestination = this.target.position;
  vec3.subtract(targetDestination, this.position, this.sharedVec3);
  return vec3.length(this.sharedVec3);
};
</code></pre>

<p>We could instead have:</p>

<pre><code>calculateDistanceToTarget: function() {
    return this.target.distanceFrom(this.position);
};
</code></pre>

<p>This subtle switch in logic means we're no longer accessing the supposedly private state of another object, and I'm free to change it without worrying about the rest of my code breaking.</p>

<p>I'm also able to far easier control this behaviour when writing tests (target can be a fake target if I feel it necessary to stub out the real logic).</p>

<p>In my current projects I am being a lot more strict about state access - all state is technically public due to the nature of my JavaScript objects, but I don't give into temptation and touch it (<em>that's will power yo</em>').</p>

<p>Encapsulation is really important in a project that has this much "business logic", and having a sensible object model is a big part of this.</p>

<p><strong>Push, don't pull - but sometimes pull</strong></p>

<p>I also made the mistake in Hoverbattles of trying to build components to control every aspect of a particular behaviour - this involved pulling state from various places to work out whether A or B should happen, or whether to display X on the screen or not.</p>

<p>This didn't scale, I ended up having to pull state from three sources (which means asking the world for the entities concerned), and writing methods to pull that state on the components that those entities were build out of.</p>

<p>Turns out I ended up with a system in places that looks like classic Event Sourcing; You look at high score tables, persistence, particle systems and the HUD as views on top of the single source of truth and consider that you can build those views from events being raised in the game world. Suddenly it makes sense that all state in areas with high view subscription should be built from events raised by those entities.</p>

<p>Once I had that realisation, development got a lot easier, <em>"Hey, I've been told to move, I'll  raise an event with the relevant data, subscribe to it myself to update my own state and let everybody else do the same".</em></p>

<p>I didn't go overboard with this, in Hoverbattles there are only a few places where the above is true, and even then only just and in my latest code this is much more established pattern - the world has commands coming in via input or across the network, and raises events so everything that cares can be updated.</p>

<p>Sometimes it is just more appropriate to pull the state, especially if it's hard to raise an event without duplicating data (see above the cost of creating new objects), and the trick so far has been recognising that and trying not to overly homogenise.</p>

<p><strong>Don't let network-code take over your domain</strong></p>

<p>In Hoverbattles there was a real problem when it came to writing the network code, it ended up being far too pervasive and leaked into too many aspects of the logical entity code.</p>

<p>Some of this managed to be repaired before it became too much of a mess, the main realisation was that there were only a few classes of problem involved in most of the network code, that is:</p>

<ul>
<li>User input, sent as commands to both the world and the server</li>
<li>Periodic sync, extracting state from objects and serializing across the wire to all clients</li>
<li>Protected code that can only be executed on the server, but the results of which need executing on both client and server</li>
</ul>

<p>These are actually ordered in terms of difficulty:</p>

<ul>
<li>User input can easily be sorted by sticking an intermediary between the actual input emitter and the game world (so, one object with some code in it). </li>
<li>Each component has the chance to serialize state and receive state by convention with methods called _in and _out</li>
<li>This one caused a lot of issues, trying to attach different components to entities depending on whether they were created on the server/client, etc</li>
</ul>

<p>That last one was a bit of a doosy, I ended up with about 20 objects trying to juggle only the responsibility specific to the server or to the client, it looked something like this.</p>

<pre><code>/client/
/client/firingbehaviour.js
/client/dyingbehaviour.js
/client/lockingbehaviour.js
/server/
/server/firingbehaviour.js
/server/dyingbehaviour.js
/server/lockingbehaviour.js
/shared/
/shared/firingbehaviour.js
/shared/dyingbehaviour.js
/shared/lockingbehaviour.js
</code></pre>

<p>This gave me hard to debug errors because the responsibilities for an entity's behaviour were spread all over the place, state was being mutated all over the shop and it was becoming hard not to duplicate code across the different environments.</p>

<p>All of this because I was full of pride and didn't want to write into my code anywhere the line of code:</p>

<pre><code>if(Environment.IsServer)
</code></pre>

<p>As it felt wrong. I ended up with a compromise, which is I'd do that on the main entity object (which tends to bring together these different behavourial components).</p>

<p>Here's the thing - if I was using events to update my internal state, surely I could simply suppress the events on the client if the client didn't have permission to make that decision <em>(for example, player health loss is a decision only the server can make - I don't want craft blowing up and being removed from the scene if they didn't actually die, it's a horrible visual artifact).</em></p>

<pre><code>applyDamage: function(amount) {
  var newHealth = this.health - amount;
  this.raiseServerEvent('CraftDamaged', newHealth);
},
onCraftDamaged: function(newHealth) {
  this.health = newHealth;
  if(this.health &lt; 0)
   this.raiseEvent('CraftDestroyed');
}
</code></pre>

<p>Regardless of client or server, this logic would get executed - but only on the server would the event actually get raised when a craft lost health, and that event would automatically be proxied to all the clients for the rest of the logic to be executed.</p>

<p>This leaves me with:</p>

<pre><code>/craft/
/craft/firingbehaviour.js
/craft/dyingbehaviour.js
/craft/lockingbehaviour.js
</code></pre>

<p>Because this was back-patched in over a weaker system, there are some remnants of this change left over the Hoverbattles source, but it is a lesson I'm applying in the new game to really good effect. </p>

<p>The network code in the latest project consists of about three objects primarily just routing commands and events and it is most likely going to stay that way.</p>

<p><strong>Arrays are mutable reference types</strong></p>

<p>Duh. we all know that, why bother including it? Well - remember I said that creating new objects is expensive so I was sharing them? Yeah - well that can bite too, and given that this was one of my recurring bugs (my own stupidity granted) it's worth documenting.</p>

<p>In C#, typically you don't expose mutable reference types, you'd return an IEnumerable<T> if you wanted to expose a collection from an object, which is a read-only collection fit for... well reading from the consuming code.</p>

<p>Can't quite pull off that trick in JavaScript (although the solution could exist in user-land it's a bit of a faff as it's not transparent). </p>

<p>The problem is, in a game like Hoverbattles - half of our state is in fact arrays of either length of '3', or length of '16' (vectors and matrices) and we have to be careful when receiving a vector or matrix that we don't own. Consider the following simplified code, which is <em>reminiscent</em> of an actual bug I had in Hoverbattles.</p>

<p><em>Player</em></p>

<pre><code>moveLeft: function(amount) {
  this.position[0] -= amount;
  this.raiseEvent('Moved', this.position);
}
</code></pre>

<p><em>Enemy</em></p>

<pre><code>onPlayerMoved: function(newPosition) {
  this.playerPosition = newPosition;
},
doSomeLogic: function() {
   // Some calculation that indirectly modifies the array
   this.playerPosition[0] += 5;
}
</code></pre>

<p>Okay, the above is quite obvious, but this kind of thing happened (in substantially more convoluted scenarios) with the outrageous result of player craft ending up where they should not be. (Especially in the network code where objects are receiving new state a lot of the time).</p>

<p>The answer is, if you're receiving an array from an event or command, to copy it over to your own internal value if you want to keep the state around for any length of time for future processing. (Ignore this at your peril unless you're smart and/or have lots of tests).</p>

<p><strong>Push it to the GPU</strong></p>

<p>Hoverbattles first particle system was written on the CPU, and looked something like this:</p>

<pre><code>var ParticleEngine = function(count) {
  this.particles = new Array(count);
  for(var x = 0; x &lt; count ; x++) {
    this.particles[x] = {
      x: 0,
      y: 0
      velx: 0,
      vely: 0
    }
  }
};

ParticleEngine.prototype = {
  update: function() {
    for(var x = 0; x &lt; count ; x++) {
      this.particles[x].x += this.particles[x].velx;
      // etc
    }
  }
};
</code></pre>

<p>Yeah, this didn't go too well - I wanted... no, I needed many thousands of particles, and blocking the event loop on the browser by looping through large collections of objects is a big no no.</p>

<p>If you can push processing from the CPU on the browser, to the GPU using shaders, then you should, JavaScript is slow and not a suitable place to be playing with large loops of data.</p>

<p>Besides, <a href="http://en.wikipedia.org/wiki/GLSL">GLSL</a> is quite a pretty language to do it in:</p>

<pre><code>void main(void){

    float age = (time - aCreationTime);
    vec3 position = aVertexPosition + (aVelocity * age);
    vColour = aColour;

    vec3 vectorToPoint = (position - vCamera);
    float distanceSquared = abs(dot(vectorToPoint, vectorToPoint));
    float scale = clamp(distanceSquared, 1.0, 10000.0);      

    life = 1.0 - (age / aLifetime);
    life = clamp(life, 0.0, 1.0);

    gl_PointSize = (aSize * maxsize) / (scale / 100.0);
    gl_Position =  uProjection * uView * vec4(position, 1.0);
}
</code></pre>

<p><strong>Relax</strong></p>

<p>Finally - <a href="http://codeofrob.com/entries/a-relaxed-attitude-towards-the-pragmatic-delivery-of-okay-software.html">something I covered previously</a> - relax, there is no problem you cannot solve with a bit of patience, re-factoring, profiling, and debugging. :-)</p>


]]></description><link>http://codeofrob.com/entries/lessons-learned-building-a-multiplayer-game-in-nodejs-and-webgl.html</link><guid isPermaLink="true">http://codeofrob.com/entries/lessons-learned-building-a-multiplayer-game-in-nodejs-and-webgl.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 19 Mar 2012 12:00:00 GMT</pubDate></item><item><title><![CDATA[Your container is not wanted here]]></title><description><![CDATA[<p>Finding myself embroiled in yet another debate about IOC containers on Twitter I've decided to place my current thoughts here for posterity.</p>

<p><em>I don't really like using IOC containers</em></p>

<p>There, I said it. I really don't. I used to, I did - I thought they were an excellent way to manage those dependencies, to push the effort of lifetime and scope management into something that would automatically handle those things for me so I wouldn't have to think about them.</p>

<p>I thought they were an excellent way to bootstrap of my entire application from a single place, and have all the interfaces matched with their single implementations and pushed into the relevant consumers without having to think about it.</p>

<p>But you know what? Having your entire application sucked out of a black box and then writing rules for the exceptions to those wonderful conventions and then writing new conventions and interceptors and using all the "wonderful features" of the modern IOC container started to lead to developers spending more time debugging mysterious container issues and fighting odd/conflicting lifetime issues than writing code of real value.</p>

<p>Oh, you could easily dismiss this with "Oh, Rob doesn't know how to use a container properly", but you'd be missing the point, because even if I didn't (<em>and I do by the way</em>), it's irrelevant whether I do or not.</p>

<p><em>Missing the point</em>? Missing the point because nearly every team using an IOC container <strong>IS</strong> doing it wrong, and they're doing it wrong because they <em>are</em> complicated and they give you a lot of "extensibility points" to make it <em>easy</em> to do things like interception, they make it <em>easy</em> to do things like per-request items, they make it <em>easy</em> to create singletons that aren't really singletons. and they make it <em>easy</em> to create lots of interfaces that get sucked into lots of classes (in the name of low coupling, and usually with the result of a total lack of any cohesiveness).</p>

<p><strong>It's putting the cart before the horse</strong></p>

<p>Learn to walk before you run, cart before horse, etc. The fundamental issue here, is that people are spending their times learning about IOC containers, gaining some level of test-ability because everything is an interface that talks to other interfaces via interfaces to interfaces. This is not to say that IOC containers cause this explicitly, because if you've already got a grasp of OO concepts then you aren't going to do too much damage here (except for hiding simple concepts like lifetime management up behind infrastructure that's a bit more future-career-proof).</p>

<p>My fundamental issue is that not enough time is being spent by developers learning how to just grow a testable and maintainable code-base. Throwing your lot in with a container with a centralized bootstrap process and claiming that's an advantage is missing out on a fundamental aspect of clean software development - that is, neat little packages that know how to bootstrap themselves and expose a sensible API for doing so - allowing them to be used across the code-base in an understandable and idiomatically crafted way.</p>

<p>Allowing your junior developers to "not worry about these things", because the almighty and all-knowing container will look after them and ensure that the code is testable, and that dependencies will just work automatically is simply shirking the responsibility of actually teaching those developers the useful and transferable skills that will help them deliver products across a multitude of languages and platforms. (EG. not just the two that come with a million IOC containers to choose from).</p>

<blockquote>
  <p><em>In GOOS we are extremely explicit about scope!  Java is a block</em>
<em>structured language with lexical scoping, closures and objects.</em>
<em>Blocks and objects are scopes. Variables declared in a block and</em>
<em>instance variables declared in an object are in a scope. There is no</em>
<em>need to re-implement (badly) what the language (compiler and VM)</em>
<em>already provide.</em></p>

<p>Nat Pryce</p>
</blockquote>

<p>And this, is what I believe that it all boils down to.</p>

<ul>
<li>You want per-request scoping? That's a "using statement" around the entry point to that request. </li>
<li>You want application-lifetime scoping? Just create the object on start-up and let it get cleaned up on application-close</li>
<li>You want something more fine-grained? That's just another using statement around the code concerned.</li>
</ul>

<p>Objects still don't need to know about their own scoping, of course not, and we realized that with containers early on with the removal of attributes from most frameworks. But why make all the effort of pushing scoping into a framework when it is such an intrinsic part of your application and it's relatively trivial to manage anyway? Lifetime management is not an implementation detail to be pushed away into central infrastructure code, and nothing but trouble will be had from trying to work that way <em>(nested sub-containers anyone? No - I thought not).</em></p>

<p>You want to talk about writing masses of boilerplate code? I have very little in the applications I'm actively developing now - each abstraction developed is responsible for its own set-up, and only exposes to the outside world any configuration needs that it might require and the public interfaces required to do its job. That code is written and tested <em>as part of the code-base</em>, is compile safe and is fast to bootstrap because "it's just code". Abstractions are built on top of other abstractions and are tested against other abstractions with appropriate levels of isolation depending on the test concerned and there are no problems here at all.</p>

<p>This approach does not preclude the injection of dependencies into say, the subsystem which might be created as a consequence of its construction, it merely hides that detail behind an appropriate API because the consumers of this package don't typically care about that construction.</p>

<p>You want to talk about managing deep or complex object graphs? That's not a problem - each package is only ever going to have a shallow object graph, because that's sensible software design - I don't have complicated object graphs because complicated object graphs tend to show themselves during testing and are very quickly turned into simple object graphs.</p>

<p>It's just software, and we should be spending more time learning how to deliver software and less time learning how to manipulate favourite container X.</p>


]]></description><link>http://codeofrob.com/entries/your-container-is-not-wanted-here.html</link><guid isPermaLink="true">http://codeofrob.com/entries/your-container-is-not-wanted-here.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 02 Feb 2012 12:34:00 GMT</pubDate></item><item><title><![CDATA[What does it look like when I code?]]></title><description><![CDATA[
		<p>Something like this</p>

<object width="1280" height="720"><param name="movie" value="http://www.youtube.com/v/mp_nxjhx6yY?version=3&amp;hl=en_US&amp;rel=0&amp;hd=1"><param name="allowFullScreen" value="true"><param name="allowscriptaccess" value="always"><embed src="http://www.youtube.com/v/mp_nxjhx6yY?version=3&amp;hl=en_US&amp;rel=0&amp;hd=1" type="application/x-shockwave-flash" width="1280" height="720" allowscriptaccess="always" allowfullscreen="true"></object>

<p>This is a time-lapse of me creating a game over 48 hours (a weekend), overall there is about 30 hours of screen-time packed into 3 minutes of video - it's cool to see how the game and code progress over those 30 hours.</p>

<p>What is interesting is how I always have the social elements open in a browser window on my left hand side, I'd never noticed it before - I don't think it slowed me down any - the pauses where I wasn't coding I was up making coffee or thinking about a problem</p>

<p>Still, it would be interesting to see how I'd get on without it if I was doing another of these - the next rendition of the competition is next March and I think I'll be doubling my efforts to create something cool - I might even go as far as to do a 3D effort in WebGL</p>
	]]></description><link>http://codeofrob.com/entries/what-does-it-look-like-when-i-code.html</link><guid isPermaLink="true">http://codeofrob.com/entries/what-does-it-look-like-when-i-code.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 20 Dec 2011 17:47:00 GMT</pubDate></item><item><title><![CDATA[Hoverbattles Released (and more)]]></title><description><![CDATA[
		<p>I've gone off on a tangent recently and been playing around with games development as if I was 15 again</p>
<p>I think I'm going to make a game that I actually want people to play next, but first up - three things I've released recently</p>
<h4>Hoverbattles</h4>
<p>My flagship 'game', something I've learned a <strong>lot</strong> from these past couple of months - written with a NodeJS back-end, with WebGL front-end, the code is awful in places and I think I have a few memory leaks (or third party libs do!) but I'm pretty much done with this now.</p>
<p><span style="font-weight: bold;">Note: The server this is on is not brill, so there will be lag</span><br>
</p>
<p>This can be found at <a href="http://hoverbattles.com">http://hoverbattles.com</a> - fill your boots.</p>
<p>Source can be found at <a href="https://github.com/robashton/HoverBattles">https://github.com/robashton/HoverBattles</a></p>
<p> </p>
<h4><img width="800" height="479" alt="" src="/images/codeofrob_com/hoverbattles.png"></h4>
<h4>Plane Thinking</h4>
<p>I coded this over a few days as warm-up for LD22, the 48 hour games development challenge, this is plain old Canvas (although I was playing with using WebGL to do progressive enhancement it turns out that copying buffers between the two gets expensive quickly and I didn't take it much further</p>
<p>This should work in most browsers, I really should make the effort to get it working with touch controls as it would work well on iPad</p>
<p>This can be played at <a href="http://planethinking.heroku.com/">http://planethinking.heroku.com/</a></p>
<p>Source can be found at <a href="https://github.com/robashton/plane-thinking">https://github.com/robashton/plane-thinking</a></p>
<p><a href="https://github.com/robashton/plane-thinking"><img width="800" height="650" alt="" src="/images/codeofrob_com/plane-thinking2.png"><br>
</a>  </p>
<h4>You don't have to be alone</h4>
<p>This is my entry to the 48 hour game development competition Ludum Dare - I don't really think of this as competing with anybody else, trying to build a game from scratch over 48 hours is <strong>mega hard</strong> and I'm really proud that I was able to pull it off with plot, sound, music and alternative ending galore</p>
<p>The code for this is ... suboptimal, if you play it on anything other than a really high end desktop computer in any other browser than Chrome then do so at your peril. I'll be learning from that in my next game and making an effort to keep those render calls down</p>
<p>The game can be found at: <a href="http://ld22-ashton.heroku.com/">http://ld22-ashton.heroku.com/</a></p>
<p>The source can be found at: <a href="https://github.com/robashton/ld48_22">https://github.com/robashton/ld48_22</a></p>
<p><a href="https://github.com/robashton/ld48_22"><img width="1082" height="949" alt="" src="/images/codeofrob_com/update-10.png"><br>
</a></p>
<h4>The point of all this</h4>
<p>Games development is complicated, the code in Hoverbattles is probably the most complex domain I've ever worked on, and finding ways to keep the accidental complexity low whilst keeping the technical complexity low at the same time was a big challenge</p>
<p>I've learned a lot by stepping away from ordinary business app development, and I'll be taking that back to the workplace with me, as well as carrying on in this space - never before has there been a better time for aspiring games development to noodle on in their spare time.</p>
<p>This site? Yeah I've messed this up a bit - I need to rip all these posts out and deploy them as static content and set up some re-directs, a project for a rainy weekend when I don't want to play with games :-)</p>
<p>Merry Xmas</p>
<p>Rob</p>
	]]></description><link>http://codeofrob.com/entries/hoverbattles-released-and-more.html</link><guid isPermaLink="true">http://codeofrob.com/entries/hoverbattles-released-and-more.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 20 Dec 2011 15:28:00 GMT</pubDate></item><item><title><![CDATA[A relaxed attitude towards the pragmatic delivery of 'okay' software]]></title><description><![CDATA[
		<strong>A brief middle-of-project retrospective</strong>
<p>I've not been coding in my spare time much the past few months, being seriously busy for a client - but the past couple of weeks has seen me pick up a project of mine that I started a few months ago (HoverBattles) and start pushing to some level of completion.</p>
<img width="800" height="451" alt="" src="/images/internal_codeofrob_com/currentproject.png">
<p>This has been an interesting project for me, not least of all because it's written entirely in Javascript (WebGL + JS, NodeJS and CouchDB) but because this time I made a real effort to drop any up-front <em>'zomg my code must be perfect'</em> aspirations from the get go.</p>
<p>What does this mean? Well I pretty much decided that technical debt should not be something to be overly avoided, overly organised code-bases stifle creativity and I really just wanted to <strong>deliver something.</strong></p>
<p>I also knew that as I learned more about effective JavaScript that my opinions on the 'best way to achieve things' would be changing about 20x more rapidly than it does when working in an environment I'm heavily used to, and trying to constantly maintain code at some mythical standard would prevent me from actually delivering</p>
<p>A couple of months later how does that leave me? Is the code-base a huge unmaintainable mess? I would say no - it is not. </p>
<p>There are messy bits in there but they're largely on the periphery. An avoidance of up-front framework/empire building has allowed me to be morally flexible with regards to where I put new code to Get Cool Stuff Done, and a healthy concern when going over pre-existing code to add something new has led to some easy wins when re-factoring around the pain points that naturally emerge.</p>
<p>I don't think that I've taken a cavalier approach to the project - at a macro level it's quite well structured, and for the most part there is a clean separation between the different sub-components that drive the system. In a code review there are bits I'd have to apologise for but even in projects with the greatest amount of technical debt avoidance this has been true.</p>
<p>There are some problems with the messaging/multi-player side of things, complex work-flows have emerged as a consequence of the individual components receiving some input, doing something and raising some output in orders that I did not pre-plan.</p>
<p>This has been made more complicated by the fact that some of these components only exist on the server, and yet the events they raise are still sent to the client because the client needs to react even if it is not the one doing the critical thinking.</p>
<p>This is an example of what I have come to classify as a <em>real problem</em> - that is, it is a problem that is naturally occurring and isn't one I have constructed to satisfy the whims of my inner Powerpoint Architect.</p>
<p>When I think of all the things that we work on in our line of business applications, the efforts we go to de-couple everything so it can be easily tested and maintained, the efforts we go to make sure we have the extensibility points and have our "what ifs" covered, I'm seeing a lot of that in a new light as this project goes on. </p>
<p>I don't think a lot of our 'units' in our LOB world are really units at all, they're fractions of 'units', and it's only as part of a more complex interaction that things get interesting and worth spending time fussing over.</p>
<p>Even those seeking to do more vertical testing of a unit within their system (across several internal components) aren't really testing anything meaningful, they're not really spending their time on anything really meaningful either - I wonder if we do a lot of this stuff just to make our jobs more interesting because LOB apps are at a micro-level... quite boring</p>
<p>Anyway I digress, a response could be that some of that rigidity and forward thinking is needed because we have more than one soul working on these projects and if everybody took the cavalier 'get it done' attitude we'd end up with a big mess right?</p>
<p>I'm not convinced - I think that if you have a team that can actually communicate and react to problems as they arise that a good momentum would still be possible, a lot of the technical solutions delivered in these LOB apps seem to exist as a way of avoiding the need for communication and I'm beginning to think of that as less okay than I did</p>

<p>I'm also beginning to think that a concentration on these things causes bigger balls to be dropped. There is little point in arguing over patterns if you're going to forget to apply sanitisation to user-provided input for example - or suitable defensive mechanisms against things that might go wrong (as dirty as that might make some of your code).</p>

<p>Going back to the whole CQRS thing as that was the topic of the last post, this ties in well - those things exist as solutions to complexity that already exists - not as ways of creating complexity that wasn't there before. Technical solutions should be avoided unless they're actually delivering the necessary value.</p>
<p>Random blathering I know, I'll actually start talking about the tech in the game soon I think, it's getting interesting and I think there are some things to say about it</p>
	]]></description><link>http://codeofrob.com/entries/a-relaxed-attitude-towards-the-pragmatic-delivery-of-okay-software.html</link><guid isPermaLink="true">http://codeofrob.com/entries/a-relaxed-attitude-towards-the-pragmatic-delivery-of-okay-software.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 01 Nov 2011 11:37:00 GMT</pubDate></item><item><title><![CDATA[CQRS is too complicated]]></title><description><![CDATA[
		<p>Is something I hear all too often at conferences and on Twitter, and more often or not it is said because of either a basic misunderstanding of what CQRS is or is not - or perhaps because they've dipped their toes into the hyperactive DDDCQRS mailing list and been scared away by all the white coat discussion that goes on in there a lot of the time.</p>
<p>The other day, the sentiment was yet again voiced by somebody of whose opinion I respect on Twitter and I ended up in about five minutes writing a gist explaining why I didn't think this was the case (Writing 4000 word essays is an hour's work if I'm feeling ranty), I've tidied it up a bit and decided to throw it below as it works well in a blog entry.</p>
<p><strong>A basic summary</strong></p>
<p>At the highest level CQRS just means maintaining a happy division between the reads and writes across your system - that is, having the reads in your system executed in a thin clean manner appropriate to the views you want to retrieve (one model), and your writes going through all the crazy logic you need such as validation, updating queues, third party systems, processing business rules (another model)</p>
<p>Consider the traditional and very-tongue-in-cheek N-Tier architecture I have created here in powerpoint, seen in a million "architecture" presentations in ASP.NET webforms shops across the world:</p>
<p>&nbsp;<img alt="" width="400" height="326" src="/images/internal_codeofrob_com/1.png"></p>
<p>Now modify it a little bit so that our reads haven't got to go through all that cruft, haven't got to somehow amene themselves to a bunch of "DAL objects" that are created with the very&nbsp;best intention of standardising our access to some form of database (and normally optimised for the write actions anyway).</p>
<p><img alt="" width="400" height="310" src="/images/internal_codeofrob_com/2.png"></p>
<p>We can&nbsp;instantly make our lives a lot easier by creating a pile of code optimised for creating views for our presentation layer,&nbsp;perhaps doing a bit of raw SQL or calling a sproc to generate the view for us. We can helpfully formalise this arrangement and for the most part set down a rule that the direction of travel down those two paths is one way (towards the DB for writes and away from the DB for reads).&nbsp; Funnily enough - most systems that do that <strong>BOL</strong>/BLL/DAL<strong>/OCKS</strong> stuff end up with something that looks like this anyway because it's too hard to do everything through a single model.</p>
<p>This is now a form of CQRS - at the highest level we've effectively split our system into two models&nbsp;and done something that's very similar to what we'd call CQS if we were&nbsp;doing it at the method level.&nbsp; This in itself should surely be enough to convince you&nbsp; that CQRS itself is not complicated and it might be a useful thing to look further into.</p>
<p>Of course, as you go further down the rabbit hole...</p>
<p><strong>Some examples</strong></p>
<p>CQRS can be achieved by using a document database like Raven or Couch - using your documents as a write store, using your indexes as a query store. </p>
<p>&nbsp;<img alt="" width="400" height="299" src="/images/internal_codeofrob_com/32.png"></p>
<p>It can be achieved with your favourite ORM (Even better if you can actually use that O and that M and get some good old OO going) - if you want to use your objects for encapsulating business logic and go directly to the the queries to project the data you need for views (HQL, SQL directly, SPROCS, whatever) - from the same database even, providing this remains efficient enough for your needs. <em>(Funnily enough, "our" collective weak attempts at creating domain models with NHibernate are what led to us re-discovering the need for two models in the first place in my opinion).</em></p>
<p>&nbsp;<img alt="" width="400" height="312" src="/images/internal_codeofrob_com/4.png"></p>
<p>Of course you may well end up with two databases anyway, as trying to query a database comprised of tables that represent state in your "objects" can be pretty inefficient, with the read store updated from the write store using hooks in your write system to generate pre-calculated views or data that's more applicable to generating views - this is not a bad model and can work too, it's still CQRS.</p>
<p>&nbsp;<img alt="" width="400" height="319" src="/images/internal_codeofrob_com/5.png"></p>
<p>CQRS gets the "complicated" label because people often associate it directly with event sourcing, which requires that little bit more of up-front development in order to get the level of elegance you won't find in the above scenarios. However, even event sourcing is really simple once you look at it - and is a natural progression from some of the other ways of "doing" CQRS - which can be a bit muddy (not that there is anything wrong with systems that are a bit muddy). <em>Note that I'm not mentioning DDD here At All - which is where a lot of heavy&nbsp;learning lies, and nearly none of us do anyway.</em></p>
<p>Consider hooking those events in your system to manually flatten/re-arrange data into other stores as outlined above? Does that work for that one other store? How about a reporting store? How about full text search? What about integration with third party systems and the data they want to see from you? How about the boardroom reports your CEO now wants on his desk each morning before he starts his day?</p>
<p><img alt="" width="400" height="351" src="/images/internal_codeofrob_com/6.png"></p>
<p>Youch. Deciding your single source of truth is the already written state gives you an amount of inflexibility, which you may or may not be happy with&nbsp;up to a point.</p>
<p>Updating other views of this truth after small changes can be inefficient&nbsp;and awkward. Recovering after introducing any write bugs to the system can be expensive also. Hell - even changing your model can also be expensive as database migrations are hardly the easiest things if you're trying to work with multiple stores and layers all over the place. When your powerpoint presentations start looking like this you have&nbsp;complexity issues- and these complexity issues aren't caused by CQRS, they're caused by having complex powerpont presentations.</p>
<p>Moving to events and jumping through a few hoops to make this possible <em>can</em> open up a world of simplicity, and if it's not for you there are other options open to you. CQRS is not complicated - trying to shoehorn the responsibilities of read and write through a single model is complicated. Most of us realise that going through a standard "BLL, DAL, BOL, TLA, CRA, P) layer for both reads/writes is dumb, and CQRS is a good way of formalising this decision.</p>
<p><strong>Another tdlr;</strong></p>
<p>You can see that clearly there is a natural progression from the very basics to having the need to go for a full blown event sourcing system with publishers/subscribers/servers/eventual consistency once the complexity of trying to manage a more "simple" solution starts to overwhelm.</p>
<p>Unless you have that complexity and&nbsp;that need&nbsp;then of course trying to thrust an ivory tower designed architecture onto a system that doesn't need it is going to seem complicated. Hint: If your technical solution is more complicated than your original problem you're probably doing it wrong.</p>
<p><a href="http://cre8ivethought.com/blog/index"><img alt="" width="500" height="405" src="/images/internal_codeofrob_com/DDDOverview_big.jpg"></a></p>
	]]></description><link>http://codeofrob.com/entries/cqrs-is-too-complicated.html</link><guid isPermaLink="true">http://codeofrob.com/entries/cqrs-is-too-complicated.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 28 Sep 2011 19:45:00 GMT</pubDate></item></channel></rss>