<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>NodeJS RSS Module</generator><lastBuildDate>Tue, 14 May 2013 09:13:32 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Evented Github Adventure - Crossing the streams to gain real insights]]></title><description><![CDATA[<p>Carrying on in the EventStore series...</p>

<ul>
<li><a href="/entries/playing-with-the-eventstore.html">Introduction to the EventStore</a></li>
<li><a href="/entries/pushing-data-into-streams-in-the-eventstore.html">Pushing data into the EventStore</a></li>
<li><a href="/entries/basic-projections-in-the-eventstore.html">Projections in the EventStore</a></li>
<li><a href="/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html">Re-partitioning streams in the EventStore</a></li>
<li><a href="/entries/creating-a-projection-per-stream-in-the-eventstore.html">Creating a projection per stream</a></li>
<li><a href="/entries/less-abstract,-pumping-data-from-github-into-the-eventstore.html">Pumping data from Github into the EventStore</a></li>
<li><a href="/entries/evented-github-adventure---emitting-commits-as-their-own-events.html">Emitting new events from a projection</a></li>
<li><a href="/entries/evented-github-adventure---who-writes-the-sweariest-commit-messages.html">Who is the sweariest of them all?</a></li>
<li><a href="/entries/evented-github-adventure---temporal-queries,-who-doesnt-trust-their-hardware.html">Temporal queries in the event store</a></li>
<li>Projections from multiple streams</li>
</ul>

<p>It's not enough to just create a <a href="/entries/evented-github-adventure---temporal-queries,-who-doesnt-trust-their-hardware.html">stream of 'events' from correlated actions over time</a>, although that <em>is</em> super cool, what we want to do is then use that stream to tell us something interesting about the activity of developers on Github.</p>

<p>Like, given that we have this information about paranoid pushes, how do they stack up as a percentage to pushes overall when broken down by language?</p>

<p><em>Problem</em>: This information is in completely different streams.</p>

<p>Not to worry, this is where the Event Store's ability to re-partition and consume streams in a variety of ways comes to the rescue once more, want to consume the events from two different streams? Not a problem</p>

<pre><code>fromStreams([ "github", "paranoidpushes" ])
   .when({

   })
</code></pre>

<p>First off, let's keep it simple and just find out as a percentage what the paranoid pushes are out of the overal Github stream.</p>

<pre><code>fromStreams([ "github", "paranoidpushes" ])
   .when({
     "$init": function() {
       return { paranoid: 0, total: 0 }
     },
     "ParanoidPush": function(state, ev) {
       state.paranoid++
     },
     "PushEvent": function(state, ev) {
       state.total++
     }
   })
</code></pre>

<p>So yeah, er - that was stupidly easy, I didn't even have to think about that one, we just get all the events from those streams as a unified collection and were able to generate stats from these.</p>

<p>What does the result look like?</p>

<pre><code>{"paranoid":181423,"total": 2272796}
</code></pre>

<p>So, in fact around 8% of all pushes to Github happen within 2 minutes of the previous one - that's actually quite high - and my guess is that these are either people rectifying mistakes in previous commits (actually, there's an idea for another projection) or people who are new to git.</p>

<p>Let's generate a result object by language and see what we get</p>

<pre><code>function getPerLanguageState(state, ev) {
  var language = getLanguageFromEvent(ev)
  var langState = state[language]
  if(!langState) {
    langState = { paranoid: 0, total: 0 }
    state[language] = langState
  }
  return langState
}

function getLanguageFromEvent(ev) {
  if(ev.body.repo)
    return ev.body.repo.language
  if(ev.body.first)
    return ev.body.first.body.repo.language
}

fromStreams([ "github", "paranoidpushes" ])
  .when({
   "$init": function() {
     return {}
   },
   "ParanoidPush": function(state, ev) {
     var langState = getPerLanguageState(state, ev)
     langState.paranoid++
     return state
   },
   "PushEvent": function(state, ev) {
     var langState = getPerLanguageState(state, ev)
     langState.total++
     return state
   }
  })
</code></pre>

<p>There is a lot to take in here, but we can see</p>

<ul>
<li>I can use custom functions in my projection definition to break down the work</li>
<li>The custom functions simply work out what language my event is</li>
<li>The custom functions return a per-language state object</li>
<li>The projection just adds to the values in that per-language state object</li>
</ul>

<p>Anyway, the results of this?</p>

<div id="notscaled"></div>

<p>And scaled</p>

<div id="scaled"></div>

<p>So the old school Java and C++ developers can't get enough of that push-based action,  with nearly 16% of their pushes happening within a couple of minutes of their previous push.</p>

<p>Matlab too (presumably they're not doing CI to heroku), maybe they're just worried about their university computer sessions crashing or something.</p>

<p>Not terribly interesting results, but a good example of when it makes sense to combine two streams from the EventStore together.</p>

<script type="text/javascript" src="/d3.v2.js"></script>
<script type="text/javascript">


var data = 
{"Lua":{"paranoid":710,"total":9208},"Java":{"paranoid":34212,"total":298219},"C":{"paranoid":12549,"total":121676},"AutoHotkey":{"paranoid":14,"total":278},"null":{"paranoid":35773,"total":258170},"C++":{"paranoid":21271,"total":133376},"Ruby":{"paranoid":17924,"total":227354},"undefined":{"paranoid":0,"total":4858},"Python":{"paranoid":17700,"total":205053},"JavaScript":{"paranoid":45154,"total":454877},"PHP":{"paranoid":16789,"total":187223},"Emacs Lisp":{"paranoid":828,"total":11998},"Objective-C":{"paranoid":2715,"total":36117},"Shell":{"paranoid":6792,"total":69272},"Erlang":{"paranoid":541,"total":5643},"ColdFusion":{"paranoid":156,"total":1253},"CoffeeScript":{"paranoid":1489,"total":16010},"C#":{"paranoid":3597,"total":48749},"Groovy":{"paranoid":433,"total":5500},"Go":{"paranoid":868,"total":10820},"Rust":{"paranoid":253,"total":1944},"Arduino":{"paranoid":198,"total":2353},"Standard ML":{"paranoid":819,"total":3191},"R":{"paranoid":522,"total":7247},"Perl":{"paranoid":2069,"total":25325},"Haskell":{"paranoid":719,"total":10351},"Common Lisp":{"paranoid":151,"total":2120},"Verilog":{"paranoid":95,"total":1337},"Haxe":{"paranoid":103,"total":1220},"ooc":{"paranoid":11,"total":193},"VimL":{"paranoid":1625,"total":25894},"FORTRAN":{"paranoid":104,"total":1355},"Scala":{"paranoid":1070,"total":14685},"Clojure":{"paranoid":737,"total":8938},"ActionScript":{"paranoid":365,"total":4431},"Assembly":{"paranoid":170,"total":1755},"OCaml":{"paranoid":189,"total":2563},"ASP":{"paranoid":176,"total":2160},"Puppet":{"paranoid":536,"total":5874},"OpenEdge ABL":{"paranoid":31,"total":319},"HaXe":{"paranoid":24,"total":401},"Julia":{"paranoid":110,"total":1677},"D":{"paranoid":112,"total":1778},"Tcl":{"paranoid":59,"total":502},"Visual Basic":{"paranoid":137,"total":1893},"Racket":{"paranoid":112,"total":1552},"Delphi":{"paranoid":93,"total":1578},"Matlab":{"paranoid":1393,"total":8684},"Dart":{"paranoid":199,"total":2435},"Coq":{"paranoid":32,"total":556},"Vala":{"paranoid":55,"total":435},"Gosu":{"paranoid":5,"total":88},"F#":{"paranoid":86,"total":1186},"Logtalk":{"paranoid":3,"total":73},"Scheme":{"paranoid":162,"total":2117},"Prolog":{"paranoid":82,"total":1117},"Augeas":{"paranoid":1,"total":22},"PowerShell":{"paranoid":98,"total":1366},"VHDL":{"paranoid":56,"total":874},"Turing":{"paranoid":5,"total":28},"DCPU-16 ASM":{"paranoid":1,"total":59},"Smalltalk":{"paranoid":48,"total":490},"XQuery":{"paranoid":6,"total":142},"Dylan":{"paranoid":4,"total":103},"Objective-J":{"paranoid":11,"total":215},"Factor":{"paranoid":40,"total":504},"Ada":{"paranoid":40,"total":326},"Kotlin":{"paranoid":7,"total":129},"Rebol":{"paranoid":2,"total":45},"Io":{"paranoid":5,"total":83},"Nemerle":{"paranoid":40,"total":168},"Elixir":{"paranoid":29,"total":354},"Eiffel":{"paranoid":37,"total":463},"Boo":{"paranoid":3,"total":62},"SuperCollider":{"paranoid":14,"total":260},"AppleScript":{"paranoid":24,"total":176},"Parrot":{"paranoid":4,"total":75},"Scilab":{"paranoid":7,"total":93},"Apex":{"paranoid":14,"total":236},"Ceylon":{"paranoid":2,"total":45},"Bro":{"paranoid":1,"total":8},"Pure Data":{"paranoid":17,"total":149},"Max":{"paranoid":0,"total":1},"Fancy":{"paranoid":2,"total":5},"Lasso":{"paranoid":72,"total":641},"TypeScript":{"paranoid":164,"total":2189},"XML":{"paranoid":220,"total":2649},"LiveScript":{"paranoid":23,"total":288},"Awk":{"paranoid":13,"total":110},"Mirah":{"paranoid":0,"total":4},"Xtend":{"paranoid":4,"total":62},"Ioke":{"paranoid":1,"total":12},"Monkey":{"paranoid":3,"total":41},"Logos":{"paranoid":197,"total":2704},"eC":{"paranoid":0,"total":6},"Nimrod":{"paranoid":5,"total":75},"CLIPS":{"paranoid":1,"total":43},"Arc":{"paranoid":5,"total":22},"DOT":{"paranoid":39,"total":727},"Rouge":{"paranoid":0,"total":3},"Ecl":{"paranoid":0,"total":20},"Processing":{"paranoid":157,"total":1528},"Nu":{"paranoid":15,"total":73},"Forth":{"paranoid":0,"total":9},"PogoScript":{"paranoid":1,"total":18},"Pike":{"paranoid":0,"total":13},"TXL":{"paranoid":0,"total":1},"Fantom":{"paranoid":0,"total":21},"MoonScript":{"paranoid":3,"total":50},"Ragel in Ruby Host":{"paranoid":2,"total":22},"Opa":{"paranoid":0,"total":3},"ABAP":{"paranoid":0,"total":1}}

   var filteredData = []
   for(var i in data) {
     if(data[i].total >= 5000) {
       var datum = data[i]
       datum.state = {
        paranoid: data[i].paranoid,
        total: data[i].total,
        percentage: Math.floor((data[i].paranoid / data[i].total) * 10000) / 100
       }
       datum.key = i
       filteredData.push(datum)
     }
   }
</script>

<script type="text/javascript">

  var svg = d3.select("#notscaled").append("svg")
          .attr("width", 640)
          .attr("height", 480)


   var scale = d3.scale.linear()
     .domain([0, d3.max(filteredData, function(d) { return d.state.total })])
     .range([0, 280]);

   svg.selectAll("text")
      .data(filteredData)
      .enter()
        .append("text")
        .attr("transform", function(d, i) { 
          var transform = "translate(" + i * (640 / filteredData.length) + "," + 380 + ") "
          transform += "rotate(75) "
          return transform
        })
        .attr("x", 0)
        .attr("y", 0)
        .text(function(d) { return d.key })

   svg.selectAll(".total")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "total")
         .attr("fill", '#00A')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - scale(d.state.total); })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return scale(d.state.total) })

    svg.selectAll(".paranoid")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "paranoid")
         .attr("fill", '#AAF')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - scale(d.state.paranoid); })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return scale(d.state.paranoid) })

</script>

<script type="text/javascript">

  var svg = d3.select("#scaled").append("svg")
          .attr("width", 800)
          .attr("height", 480)

   var scale = d3.scale.linear()
     .domain([0, d3.max(filteredData, function(d) { return d.state.percentage })])
     .range([0, 1]);

   var maxPercentage = d3.max(filteredData, function(d) { return d.state.percentage });

   svg.append("text")
      .attr("fill", '#000')
      .attr("x", 710)
      .attr("y", 60)
      .text(maxPercentage + "%")

   svg.append("text")
      .attr("fill", '#000')
      .attr("x", 710)
      .attr("y", 350)
      .text(0 + "%")

   svg.selectAll(".label")
      .data(filteredData)
      .enter()
        .append("text")
        .attr("class", "label")
        .attr("transform", function(d, i) { 
          var transform = "translate(" + i * (640 / filteredData.length) + "," + 380 + ") "
          transform += "rotate(75) "
          return transform
        })
        .attr("x", 0)
        .attr("y", 0)
        .text(function(d) { return d.key })

    svg.selectAll(".paranoid")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "paranoid")
         .attr("fill", '#AAF')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - (280 * scale(d.state.percentage)) })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return 280 * scale(d.state.percentage) })
</script>]]></description><link>http://codeofrob.com/entries/evented-github-adventure---crossing-the-streams-to-gain-real-insights.html</link><guid isPermaLink="true">http://codeofrob.com/entries/evented-github-adventure---crossing-the-streams-to-gain-real-insights.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 13 May 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Evented Github Adventure - Temporal queries, who doesn't trust their hardware]]></title><description><![CDATA[<p>Carrying on in the EventStore series...</p>

<ul>
<li><a href="/entries/playing-with-the-eventstore.html">Introduction to the EventStore</a></li>
<li><a href="/entries/pushing-data-into-streams-in-the-eventstore.html">Pushing data into the EventStore</a></li>
<li><a href="/entries/basic-projections-in-the-eventstore.html">Projections in the EventStore</a></li>
<li><a href="/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html">Re-partitioning streams in the EventStore</a></li>
<li><a href="/entries/creating-a-projection-per-stream-in-the-eventstore.html">Creating a projection per stream</a></li>
<li><a href="/entries/less-abstract,-pumping-data-from-github-into-the-eventstore.html">Pumping data from Github into the EventStore</a></li>
<li><a href="/entries/evented-github-adventure---emitting-commits-as-their-own-events.html">Emitting new events from a projection</a></li>
<li><a href="/entries/evented-github-adventure---who-writes-the-sweariest-commit-messages.html">Who is the sweariest of them all?</a></li>
<li>Temporal queries in the event store</li>
</ul>

<p>Doing <a href="/entries/evented-github-adventure---who-writes-the-sweariest-commit-messages.html">basic aggregations</a> is fairly easy, but actually one of the great selling points of the projections system inside the EventStore is how easy it is to do temporal queries.</p>

<p>What is a temporal query? Well the example that <a href="http://twitter.com/gregyoung">Greg Young</a> always uses is "look for all the events in Twitter where somebody mentions starbucks, coffee, and happy within five minutes of each other"</p>

<p>The clue there is "look for all the events", and we'll see why that is with this example.</p>

<p><strong>Git</strong></p>

<p>Git is great, it's great because it's a DCVS and we can do everything locally and push to a remote repo when we feel we're ready.</p>

<p>That said, some people don't do this, every commit is a push - maybe it's because they're not used to using a system where they can work offline, or maybe they're just paranoid because they're working on a laptop they don't trust.</p>

<p>Either way, this is a great example of a temporal query we could write.</p>

<p><strong>A query on Git</strong></p>

<p><em>"Find the instances of pushes within X minutes of each other from the same user and same repo", is there a trend across different languages for this kind of usage?</em></p>

<p>I would <em>not</em> enjoy doing this in a standard database, but that's neither here nor there, let's see what we have.</p>

<p>First off, the important question is "what is the unique combination we're looking for"</p>

<p>We care about <em>PushEvent</em>s for a unique <em>User</em> and <em>Repo</em>, so it makes sense that what we should do is <em>partition by UserAndRepo</em>  so we can easily keep state around per repo.</p>

<p><strong>Partition by uniqueness</strong></p>

<p>Here is how that might look:</p>

<pre><code>fromStream('github')
  .when({
    "PushEvent": function(state, ev) {
      var repo = ev.body.repo.full_name
      linkTo('pushesbyrepo-' + repo, ev)
    }
  })
</code></pre>

<p>So far so good, I now have a stream per repo called "pushesbyrepo-{reponame}" - now what?</p>

<p>Well, the key thing I mentioned above was that we're "looking for all the events where", this suggests that perhaps the thing we are looking for should be considered an event in its own right.</p>

<p>We can do this, we can for each of thse streams keep a note of when the last push was, and if we encounter another push within a certain time-frame, emit an event for this find of ours.</p>

<p><strong>Running a projection per generated stream</strong></p>

<p>How to run this for each stream? Enter fromCategory</p>

<pre><code>fromCategory('pushesbyrepo')
  foreachStream()
  .when({
    $init: // etc
  })
</code></pre>

<p>There is a built in projection in the EventStore that will automatically use the character '-' to sort a collection of streams into categories, and if we have</p>

<ul>
<li>pushesbyrepo-bob</li>
<li>pushesbyrepo-alice</li>
<li>pushesbyrepo-derpy</li>
</ul>

<p>We'll get three categories to iterate through (bob, alice, and derpy)</p>

<p><strong>Emit the events we're looking for</strong></p>

<pre><code>fromCategory('pushesbyrepo')
  foreachStream()
  .when({
    $init: function(state, ev) {
      return {}
    },
    "PushEvent": function(state, ev) {
      if(state.lastPush) {
        var newDate = new Date(ev.body.created_at)
          , lastDate = new Date(state.lastPush.body.created_at)
          , difference = (newDate.getTime() - lastDate.getTime()) / 1000

        if(difference &lt; 120) {
          emit('paranoidpushes', "ParanoidPush", {
            first: state.lastPush,
            next: ev
          })
        }
      }
      state.lastPush = ev
      return state
    }
  })
</code></pre>

<p>Seems legit, simply keep the last PushEvent around at all times, when we get a new one, check the difference and emit an event if it's less than X minutes. NICE</p>

<p>Running this, I now have a stream at </p>

<p><em>/streams/paranoidpushes</em> </p>

<p>So, how many paranoid pushes have I had in the time period I've been sampling over? (roughly three hours at time of writing)</p>

<pre><code>fromStream('paranoidpushes')
  .when({
    "$init": function(state, ev) {
      return { count: 0 }
    },
    "ParanoidPush": function(state, ev) {
      state.count++
    }
  })
</code></pre>

<p>And the result?</p>

<pre><code>{ count: 104533 }
</code></pre>

<p>Voila, that's an incredibly simply temporal query that just works and gives me the total number of pushes that happened within 2 minutes of each other to the same repository - and it's pretty easy too. We have two steps:</p>

<ul>
<li>Push out events for each instance of some temporal correlation</li>
<li>Aggregate on those events to get the result</li>
</ul>

<p>Now we have this, perhaps we can look at combining this data we have to work out how this strange use of git plays out across different language developers.</p>]]></description><link>http://codeofrob.com/entries/evented-github-adventure---temporal-queries,-who-doesnt-trust-their-hardware.html</link><guid isPermaLink="true">http://codeofrob.com/entries/evented-github-adventure---temporal-queries,-who-doesnt-trust-their-hardware.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 10 May 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Evented Github Adventure - Who writes the sweariest commit messages]]></title><description><![CDATA[<p>Okay, so now I've ran all my projections over all that crazy data and have some results to show!</p>

<ul>
<li><a href="/entries/playing-with-the-eventstore.html">Introduction to the EventStore</a></li>
<li><a href="/entries/pushing-data-into-streams-in-the-eventstore.html">Pushing data into the EventStore</a></li>
<li><a href="/entries/basic-projections-in-the-eventstore.html">Projections in the EventStore</a></li>
<li><a href="/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html">Re-partitioning streams in the EventStore</a></li>
<li><a href="/entries/creating-a-projection-per-stream-in-the-eventstore.html">Creating a projection per stream</a></li>
<li><a href="/entries/less-abstract,-pumping-data-from-github-into-the-eventstore.html">Pumping data from Github into the EventStore</a></li>
<li><a href="/entries/evented-github-adventure---emitting-commits-as-their-own-events.html">Emitting new events from a projection</a></li>
<li><a href="/entries/evented-github-adventure---database-storage-and-backing-up.html">Event store database storage</a></li>
<li>Who is the sweariest of them all?</li>
</ul>

<p>We now have a <a href="/entries/evented-github-adventure---emitting-commits-as-their-own-events.html">stream for the commits</a> inside Github, and we have information about the repos associated with those commits, now how about asking a question about those commits.</p>

<p>For reference, there are about 20 million commit messages in my event store, so I have more than enough data for this to be statistically relevant!</p>

<p><em>"Oh Github Github, in the cloud, who is the sweariest developer out loud?"</em></p>

<p>Well, this is the kind of thing we might do outside the store (after re-partitioning per-language inside the store), but I haven't got a secondary store so I'm just going to build up a view model for my charting library directly inside the event store (using the commit events I made)</p>

<pre><code>var swearwords = [ "poop", "arse", "sugarlumps" ] // Changed to protect the innocent

fromStream('github-commits')
  .when({
    "$init": function(state, ev) {
      return { }
    },
    "Commit": function(state, ev) {
      var language = ev.body.repo.language

      if(!state[language])
        state[language] = { count: 0, total: 0 }

      var languageState = state[language]
      languageState.total += 1

      for(var i = 0 ; i &lt; swearwords.length; i++) {
        var curse = swearwords[i]
        if(ev.body.commit.message.indexOf(curse) &gt;= 0)
          languageState.count += 1
      }
      return state
    }
  })
</code></pre>

<p>And the results?</p>

<p>Well, I can go to </p>

<p><em>/projection/curses/state</em></p>

<p>And get a big pile of JSON, which looks a bit like this</p>

<pre><code>{
  "ASP": { total: 1, curses: 200 },
  "OpenEdge ABL": { total: 2, curses: 0 },
  "Julia": { total: 11, curses: 0 }
}
</code></pre>

<p>Plugging this into d3, and filtering out the items without enough entries (5000 events), we get </p>

<div id="graph"></div>

<script type="text/javascript" src="/d3.v2.js"></script>

<script type="text/javascript">

  var svg = d3.select("#graph").append("svg")
          .attr("width", 640)
          .attr("height", 480)


var data = {"Lua":{"count":365,"total":14410},"Java":{"count":24321,"total":478695},"C":{"count":10997,"total":247049},"AutoHotkey":{"count":23,"total":376},"null":{"count":5493,"total":317226},"C++":{"count":11779,"total":231490},"Ruby":{"count":16148,"total":364129},"undefined":{"count":192,"total":4821},"Python":{"count":13667,"total":351107},"JavaScript":{"count":18063,"total":651759},"PHP":{"count":12383,"total":290428},"Emacs Lisp":{"count":420,"total":19623},"Objective-C":{"count":1828,"total":53214},"Shell":{"count":1976,"total":96757},"Erlang":{"count":312,"total":10949},"ColdFusion":{"count":54,"total":2065},"CoffeeScript":{"count":782,"total":25129},"C#":{"count":3706,"total":74267},"Groovy":{"count":373,"total":7892},"Go":{"count":363,"total":15837},"Rust":{"count":372,"total":6349},"Arduino":{"count":54,"total":2817},"Standard ML":{"count":20,"total":949},"R":{"count":316,"total":9411},"Perl":{"count":1764,"total":42810},"Haskell":{"count":417,"total":16458},"Common Lisp":{"count":131,"total":3284},"Verilog":{"count":69,"total":1930},"Haxe":{"count":92,"total":1672},"ooc":{"count":3,"total":208},"VimL":{"count":515,"total":34469},"Scala":{"count":1592,"total":26538},"Clojure":{"count":352,"total":14451},"FORTRAN":{"count":56,"total":2040},"ActionScript":{"count":379,"total":6599},"Assembly":{"count":108,"total":2481},"OCaml":{"count":137,"total":5293},"ASP":{"count":57,"total":2555},"Puppet":{"count":467,"total":8035},"OpenEdge ABL":{"count":24,"total":490},"HaXe":{"count":44,"total":894},"Julia":{"count":125,"total":3937},"D":{"count":163,"total":3049},"Tcl":{"count":28,"total":1038},"Visual Basic":{"count":69,"total":2225},"Racket":{"count":152,"total":3041},"Delphi":{"count":69,"total":2300},"Matlab":{"count":256,"total":10542},"Dart":{"count":112,"total":3689},"Coq":{"count":10,"total":819},"Vala":{"count":9,"total":565},"Gosu":{"count":0,"total":92},"F#":{"count":66,"total":2176},"Logtalk":{"count":4,"total":67},"Scheme":{"count":65,"total":2930},"Prolog":{"count":63,"total":1440},"Augeas":{"count":2,"total":24},"PowerShell":{"count":82,"total":1644},"VHDL":{"count":104,"total":1747},"Turing":{"count":3,"total":24},"DCPU-16 ASM":{"count":1,"total":92},"Smalltalk":{"count":87,"total":863},"XQuery":{"count":11,"total":227},"Dylan":{"count":20,"total":295},"Objective-J":{"count":31,"total":635},"Factor":{"count":55,"total":1173},"Ada":{"count":11,"total":353},"Kotlin":{"count":27,"total":314},"Rebol":{"count":4,"total":54},"Io":{"count":0,"total":135},"Nemerle":{"count":5,"total":224},"Elixir":{"count":6,"total":577},"Eiffel":{"count":70,"total":898},"Boo":{"count":5,"total":118},"SuperCollider":{"count":28,"total":312},"AppleScript":{"count":2,"total":228},"Parrot":{"count":11,"total":248},"Scilab":{"count":10,"total":109},"Apex":{"count":17,"total":282},"Ceylon":{"count":2,"total":92},"Bro":{"count":1,"total":8},"Pure Data":{"count":4,"total":213},"Max":{"count":0,"total":1},"Fancy":{"count":0,"total":5},"Lasso":{"count":40,"total":1222},"TypeScript":{"count":251,"total":5617},"XML":{"count":100,"total":4026},"LiveScript":{"count":17,"total":459},"Awk":{"count":1,"total":131},"Mirah":{"count":0,"total":5},"Xtend":{"count":9,"total":69},"Ioke":{"count":0,"total":12},"Monkey":{"count":1,"total":55},"Logos":{"count":156,"total":3502},"eC":{"count":0,"total":9},"Nimrod":{"count":4,"total":203},"CLIPS":{"count":1,"total":62},"Arc":{"count":0,"total":14},"DOT":{"count":13,"total":999},"Rouge":{"count":0,"total":3},"Ecl":{"count":0,"total":10},"Processing":{"count":61,"total":1679},"Nu":{"count":6,"total":102},"Forth":{"count":0,"total":34},"PogoScript":{"count":1,"total":20},"Pike":{"count":5,"total":37},"TXL":{"count":0,"total":2},"Fantom":{"count":0,"total":25},"MoonScript":{"count":3,"total":51},"Ragel in Ruby Host":{"count":1,"total":23},"Opa":{"count":2,"total":2},"ABAP":{"count":0,"total":1}}

   </script>

   <script type="text/javascript">

   var filteredData = []
   for(var i in data) {
     if(i === 'null') continue
     if(data[i].total >= 5000) {

       var datum = data[i]
       datum.percentage = Math.floor((datum.count / datum.total) * 10000) / 100
       datum.swears = datum.count
       datum.language = i
       filteredData.push(datum)
     }
   }

   if(filteredData.sort) {
    filteredData = filteredData.sort(function(a, b) { return a.percentage - b.percentage })
  }

   var scale = d3.scale.linear()
     .domain([0, d3.max(filteredData, function(d) { return d.total })])
     .range([0, 280]);

   svg.selectAll("text")
      .data(filteredData)
      .enter()
        .append("text")
        .attr("transform", function(d, i) { 
          var transform = "translate(" + i * (640 / filteredData.length) + "," + 380 + ") "
          transform += "rotate(75) "
          return transform
        })
        .attr("x", 0)
        .attr("y", 0)
        .text(function(d) { return d.language })

   svg.selectAll(".total")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "total")
         .attr("fill", '#00A')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - scale(d.total); })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return scale(d.total) })

    svg.selectAll(".curse")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "curse")
         .attr("fill", '#AAF')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - scale(d.swears); })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return scale(d.swears) })

</script>

<p>Actually, let's normalise this for the lols and see who is actually the sweariest, normalised from about 0% to 7% (the majority of developers are quite clean about things ;) )</p>

<p><strong>% of commit messages containing curse words</strong></p>

<div id="normalised"></div>

<script type="text/javascript">

  var svg = d3.select("#normalised").append("svg")
          .attr("width", 800)
          .attr("height", 480)

   var scale = d3.scale.linear()
     .domain([0, d3.max(filteredData, function(d) { return d.percentage })])
     .range([0, 1]);

   var maxPercentage = d3.max(filteredData, function(d) { return d.percentage });

   svg.append("text")
      .attr("fill", '#000')
      .attr("x", 710)
      .attr("y", 60)
      .text(maxPercentage + "%")

   svg.append("text")
      .attr("fill", '#000')
      .attr("x", 710)
      .attr("y", 350)
      .text(0 + "%")

   svg.selectAll(".label")
      .data(filteredData)
      .enter()
        .append("text")
        .attr("class", "label")
        .attr("transform", function(d, i) { 
          var transform = "translate(" + i * (640 / filteredData.length) + "," + 380 + ") "
          transform += "rotate(75) "
          return transform
        })
        .attr("x", 0)
        .attr("y", 0)
        .text(function(d) { return d.language })

    svg.selectAll(".curse")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "curse")
         .attr("fill", '#AAF')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - (280 * scale(d.percentage)) })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return 280 * scale(d.percentage) })

</script>

<p>I'll leave you to draw your own conclusions about this chart, but I can't say that it comes as a huge surprise judging from the various developers on <em>my</em> Twitter feed ;-)</p>

<p>Scala developers are ducking <em>filthy</em>, but the lisp programmers probably save their curse words for Emacs rather than the language they're using. <em>Seems legit.</em></p>

<p>Projections are a great way to analyse streams to generate knowledge about what is going on, of course simply doing aggregations over data over time is something we can achieve in most systems, in the next entry we'll look at something more interesting.</p>]]></description><link>http://codeofrob.com/entries/evented-github-adventure---who-writes-the-sweariest-commit-messages.html</link><guid isPermaLink="true">http://codeofrob.com/entries/evented-github-adventure---who-writes-the-sweariest-commit-messages.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 08 May 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Evented github adventure - database storage and backing up]]></title><description><![CDATA[<p>If you're joing us after the bank holiday weekend in the UK, then we're on the Event Store and looking at Github data.</p>

<ul>
<li><a href="/entries/playing-with-the-eventstore.html">Introduction to the EventStore</a></li>
<li><a href="/entries/pushing-data-into-streams-in-the-eventstore.html">Pushing data into the EventStore</a></li>
<li><a href="/entries/basic-projections-in-the-eventstore.html">Projections in the EventStore</a></li>
<li><a href="/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html">Re-partitioning streams in the EventStore</a></li>
<li><a href="/entries/creating-a-projection-per-stream-in-the-eventstore.html">Creating a projection per stream</a></li>
<li><a href="/entries/less-abstract,-pumping-data-from-github-into-the-eventstore.html">Pumping data from Github into the EventStore</a></li>
<li><a href="/entries/evented-github-adventure---emitting-commits-as-their-own-events.html">Emitting new events from a projection</a></li>
</ul>

<p>I actually wrote all of these blog entries several months ago, and then queued them up because I wanted to get some real data before running my projections.</p>

<p><em>Problem: I ran the events into the store on my EC2 "small" instance and now have 25gb of data sat there to run projections over.</em></p>

<p>I can't actually run my projections on that much data on that small instance without either waiting for a bazillion years or taking everthing else down on that box.</p>

<p>I quickly realise that I'm not going to be able to push the next blog post out on time either way, and decide to write this post and have a look at what I need to do to move my data onto a new EC2 machine.</p>

<p><strong>Step 1: Create an AMI of the current EC2 instance</strong></p>

<p><img src="/img/create_ami.png" title="creating an AMI" /></p>

<p><strong>Step 2: Create an xlarge instance from this AMI</strong></p>

<p><img src="/img/event_store.png" title="Creating xlarge" /></p>

<p><strong>Step 3: Log in and give this instance access to the old instance</strong></p>

<ul>
<li>ssh-keygen <em>etc</em></li>
<li>copy the public key and add it to the old EC2 authorized_keys</li>
<li>ssh from new machine to old machine to make sure it works</li>
</ul>

<p><strong>Step 4: Get that data onto the new machine</strong></p>

<p>This is interesting, if you look in the folder I pointed the EventStore at to store its information it looks like this:</p>

<p><img src="/img/data_storage.png" title="raw files for storage"></p>

<p>Apparently all I have to do is copy this folder over and I do this with SCP like so</p>

<p><img src="/img/backing_up.png" title="backing up" /></p>

<p>And then I'm able to run the already-built event store because that came with the AMI I made. Everything works great and I celebrate.</p>

<p><strong>Step 5: Wait</strong></p>

<p>There may be some gaps in my blog entries from this point on as I run the projections over the events to get the results, there is a lot of data and patience is required...</p>

<p><img src="/img/running_projections.png" title="running hte projections" /></p>]]></description><link>http://codeofrob.com/entries/evented-github-adventure---database-storage-and-backing-up.html</link><guid isPermaLink="true">http://codeofrob.com/entries/evented-github-adventure---database-storage-and-backing-up.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 07 May 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Evented Github Adventure - Emitting Commits as their own events]]></title><description><![CDATA[<p>I'm <a href="/entries/less-abstract,-pumping-data-from-github-into-the-eventstore.html">ploughing all the events from Github into the EventStore</a> as is, but that doesn't mean they're instantly available for querying.</p>

<p>Lets say I want to write a few projections analysing the commits made across Github and performing some correlations off the back of that.</p>

<p>Well, currently there is no such thing as a CommitEvent - what we actually have is a PushEvent which contains a list of Commits in the payload like so</p>

<pre><code>{
   type: "PushEvent",
   repo: { // repo info },
   payload: {
     commits: [
      {
        sha: "etc",
        author: { //etc },
        message: "I am a banana"
      },
      {
        sha: "etc",
        author: { //etc },
        message: "My spoon is too big"
      },
      {
        sha: "etc",
        author: { //etc },
        message: "Tuesday's coming, did you bring your coat?"
      }
     ]
   }
}
</code></pre>

<p>Let's say I want to build up projections off the the stream of commits, in each of my projections I'd have to write the following code</p>

<pre><code>fromStream("github")
  .when({
    "$init": function(state, ev) {
      return {}
    },
    "PushEvent": function(state, ev) {
      for(var i = 0 ; i &lt; ev.body.payload.commits.length; i++) {
        var commit = ev.body.payload.commits[i]
        var repo = ev.body.repo

        // do stuff
      }
    }
  })
</code></pre>

<p>This doesn't cause a huge problem, but it is irritating having to do this for every projection and if I particularly cared about CPU it's also unnecessary work to be doing.</p>

<p>It would be much better if I could just have a stream of commits to read from when creating these projections.</p>

<pre><code>fromStream("github-commits")
  .when({
    "$init": function(state, ev) {

    },
    "Commit": function(state, ev) {
      var commit = ev.body.commit
      var repo = ev.body.repo

      // Do stuff
    }
  })
</code></pre>

<p>Well in fact we can, and that's a good place to use the 'emit' function. Let's say we have our original projection which loops over those commits:</p>

<pre><code>fromStream("github")
  .when({
    "$init": function(state, ev) {
      return {}
    },
    "PushEvent": function(state, ev) {
      for(var i = 0 ; i &lt; ev.body.payload.commits.length; i++) {
        var commit = ev.body.payload.commits[i]
        var repo = ev.body.repo
        emit("github-commits", "Commit", {
          commit: commit,
          repo: repo
        })
      }
    }
  })
</code></pre>

<p>And lo, we now have a new stream caled "github-commits", with a pile of "Commit" events with the commit and the repo information for that commit.</p>

<p><em>/streams/github-commits</em></p>

<pre><code>{
  title: "github-commits #2266",
  id: "http://127.0.0.1:2113/streams/github-commits/2266",
  updated: "2013-03-02T15:20:04.207363Z",
  author: {
    name: "EventStore"
  },
  summary: "Entry #2266",
  links: [
  {
    uri: "http://127.0.0.1:2113/streams/github-commits/2266",
    relation: "edit"
  },
  {
    uri: "http://127.0.0.1:2113/streams/github-commits/event/2266?format=text",
    type: "text/plain"
  },
  {
    uri: "http://127.0.0.1:2113/streams/github-commits/event/2266?format=json",
    relation: "alternate",
    type: "application/json"
  },
  {
    uri: "http://127.0.0.1:2113/streams/github-commits/event/2266?format=xml",
    relation: "alternate",
    type: "text/xml"
  }
  ]
},
</code></pre>

<p>Now, unlike "linkTo", this actually creates new events - as can be seen by the URIs in the above sample, and this decision comes with its own considerations but this is what I'll roll with for now and see where it gets me.</p>]]></description><link>http://codeofrob.com/entries/evented-github-adventure---emitting-commits-as-their-own-events.html</link><guid isPermaLink="true">http://codeofrob.com/entries/evented-github-adventure---emitting-commits-as-their-own-events.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 03 May 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Less abstract, pumping data from Github into the EventStore]]></title><description><![CDATA[<p>It's all very well and good <a href="/entries/playing-with-the-eventstore.html">talking</a> <a href="/entries/pushing-data-into-streams-in-the-eventstore.html">events</a> <a href="/entries/basic-projections-in-the-eventstore.html">in</a> <a href="/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html">the</a> <a href="/entries/creating-a-projection-per-stream-in-the-eventstore.html">abstract</a>, but there is only so long I can blather about ponies before I run out of the kind of data I can ask interesting questions about.</p>

<p>We turn to the <a href="http://developer.github.com/v3/activity/events/#list-public-events">Github Events API</a>, something I have a <a href="/entries/github-live.html">bit of experience</a> with for inspiration and start dumping all the events into the event store.</p>

<p>What does this look like?</p>

<p>Well, I'm interested in the public events stream, which can be polled up to 5000 times an hour (at current rates, it needs polling about every 10 seconds in order to keep up, so I'll not be able to get them all)</p>

<p>What this looks like</p>

<pre><code> var request = https.get(
 { host: 'api.github.com', path: '/events' + auth }, 
 function(res) {
    var data = ''
    res.on('data', function (chunk) {
      data += chunk
    });
    res.on('end', function() {
      processData(data)
    })
  })
  .on('error', function(e) {
    console.error(e)
  }).end()

  var processData = function(data) {
    var eventArray = JSON.parse(data)
    for(var i = eventArray.length-1 ; i &gt;= 0; i--) {
      processEvent(eventArray[i])
    }
  }
</code></pre>

<p>An event looks like this</p>

<pre><code>{
  id: "somelongid",
  type: "PushEvent",
  actor: { // info about the user },
  repo: { // info about the repo }
  payload: { // the event itself }
}
</code></pre>

<p>I'm going to be shoving these events 'as is' into the EventStore, and using their ids 'as is' too, this means I don't need to do any de-duping or anything like that.</p>

<p>Now, because of the kind of question I want to ask, it isn't enough for me to have the scant info about a repo that the event stream gives me (it looks like this)</p>

<pre><code>{
 "id": 3,
 "name": "octocat/Hello-World",
 "url": "https://api.github.com/repos/octocat/Hello-World"
}
</code></pre>

<p>So I'm going to augment each event with repo information (this is quite common in the eventing world, augmenting events with useful information for query purposes), and therefore my processEvent method looks something like this:</p>

<pre><code>function processEvent(ev) {
  if(ev.repo) {
    fetchRepoInfo(ev.repo.name, function(repo) {
      ev.repo = repo
      pushEventIntoEventStore(ev)
    })
  } else {
    pushEventIntoEventStore(ev)
  }
}
</code></pre>

<p>So, I'm not altering any of the events in any way, except by adding repo information to them, therefore if you're interested in the structure of any of the events I'm using you can easily look them up in the API.</p>

<p>By the time the code is readable there'll be some rate management code in there because I can't go looking up repo information for every single event and not go over the rate limit, but it's safe to say we'll be getting ~50% of the events from Github and that's a reasonable amount.</p>

<p>My script simply sits there running in the background and throws events into the event store and this little experiment is going to be about creating projections and asking questions of those events as we go along. Capiche? :)</p>]]></description><link>http://codeofrob.com/entries/less-abstract,-pumping-data-from-github-into-the-eventstore.html</link><guid isPermaLink="true">http://codeofrob.com/entries/less-abstract,-pumping-data-from-github-into-the-eventstore.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 02 May 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Creating a projection per stream in the EventStore]]></title><description><![CDATA[<p><a href="/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html">Now I have a stream per pony</a>, I want to create a projection per pony, but how do we do this?</p>

<p>Well, so far we've seen these two methods to get the events for our projection</p>

<ul>
<li>fromAny: Give us the events from all the streams</li>
<li>fromStream: Give us the event from a specific stream</li>
</ul>

<p>Well, now is the time to introduct another method we have at our disposal</p>

<ul>
<li>fromCategory: Run this for each "category"</li>
</ul>

<p>Well, what on earth IS a category? Turns out that the EventStore is quite clever and one of the default projections is hard at work looking at streams and categorising them.</p>

<p>I called my streams pony-PONYNAME for good reason, because this default projection will have gone "Hey, there is a dash in that stream, I'm going to create a category called pony, and each entry in that category is going to be a PONYNAME"</p>

<p>That leaves us with</p>

<pre><code>fromCategory('pony')
  .foreachStream()
  .when({
    "$init": function(state, ev) {
      return { count: 0 }
    },
    "PonyJumped": function(state, ev) {
      state.count++
    }
  })
</code></pre>

<p>For each stream in the category "pony", please run this projection code!</p>

<p><strong>Reading back the state</strong></p>

<p>We can now look at the state per pony by visiting the /state and passing in the partition we care about in the query string</p>

<p><em>/projection/jumpingponies2/state?partition=rainbowdash</em></p>

<pre><code>{
  count: 2000
}
</code></pre>

<p><em>/projection/jumpingponies2/state?partition=pinkiepie</em></p>

<pre><code>{
  count: 300
}
</code></pre>

<p><em>/projection/jumpingponies2/state?partition=derpy</em></p>

<pre><code>{
  count: 10
}
</code></pre>

<p><strong>NOTE</strong></p>

<p>It's at this point, people usually ask "How about giving me a list of ponies so I can look up the state for each of them", this is <em>not</em> what you use the EventStore for. </p>

<p>The list of ponies is something that should exist in your domain and be stored in a database (whether this be a document or relational database), and then used to look up values in the event store.</p>

<p>This could either be a fixed list in one of those stores, or you could run through the streams in the EventStore and build up that list as a read model in that external store. <em>This is the only time I'm going to mention this in this series :)</em></p>]]></description><link>http://codeofrob.com/entries/creating-a-projection-per-stream-in-the-eventstore.html</link><guid isPermaLink="true">http://codeofrob.com/entries/creating-a-projection-per-stream-in-the-eventstore.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 01 May 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Re-partitioning streams in the Event Store for better projections]]></title><description><![CDATA[<p>We're able to do <a href="/entries/basic-projections-in-the-eventstore.html">aggregations of a stream's content by writing a projection</a>, and that's great - if we want to know about every jump every pony has performed over the entire stream. This is unlikely to be what we actually want though, people are narccisstic and ponies are no different, Rainbow Dash probably wants to know about just her jumping activity and Pinkie Pie wants to know about her own too, Derpy Hooves is probably too busy eating muffins to care, but we'll include her anyway.</p>

<ul>
<li>We've got a stream, which we have "all events for all ponies", we called it "ponies" because we're imaginative.</li>
<li>We've got a projection that can run over that stream and give us a total jump count for that stream</li>
<li>We want a projection for each pony that gives us the total jump count for that pony</li>
<li>We therefore want a stream for each pony, so we can generate a projection for that pony</li>
</ul>

<p>It turns out that this isn't too hard, let's look at how we do this:</p>

<p>Let's start with a basic projection over our ponies stream that doesn't do anything:</p>

<pre><code>fromStream('ponies')
.whenAny(function(state, ev) {

})
</code></pre>

<p>To re-iterate what we learned last time, this projection says "From the stream 'ponies', please invoke this callback for every event in the stream regardless of what the EventType is"</p>

<p>What we can actually do is create a new stream per pony, but link back to the original events from those new streams. </p>

<pre><code>fromStream('ponies')
.whenAny(function(state, ev) {
  linkTo('pony-' + ev.data.PonyName, ev)
})
</code></pre>

<p>linkTo takes two arguments</p>

<ul>
<li>The name of the stream to link the event to</li>
<li>The event itself</li>
</ul>

<p>For this projection, I "enable emits" beacuse that's what we're doing here</p>

<p>In our case, we're going to have a stream created for each pony, called pony-PONYNAME (so pony-rainbowdash, pony-derpyhooves, pony-pinkiepie), let's look at this to verify</p>

<p><em>/streams/pony-rainbowdash</em></p>

<pre><code>{
  title: "ponies #5502",
  id: "http://127.0.0.1:2113/streams/ponies/5502",
  updated: "2013-03-02T12:39:12.322785Z",
  author: {
    name: "EventStore"
  },
  summary: "Entry #5502",
  links: [
    {
      uri: "http://127.0.0.1:2113/streams/ponies/5502",
      relation: "edit"
    },
    {
      uri: "http://127.0.0.1:2113/streams/ponies/event/5502?format=text",
      type: "text/plain"
    },
    {
      uri: "http://127.0.0.1:2113/streams/ponies/event/5502?format=json",
      relation: "alternate",
      type: "application/json"
    },
    {
      uri: "http://127.0.0.1:2113/streams/ponies/event/5502?format=xml",
      relation: "alternate",
      type: "text/xml"
    }
  ]
}
</code></pre>

<p>This is just one of the events in that stream, but we can see an important point here, that <em>a new event was not created, the links are the original events from the original stream</em>. Cool!</p>

<p>If I look through the list of all streams, I can see that I now have a stream for each pony (in my case this is)</p>

<ul>
<li>/streams/pony-rainbowdash</li>
<li>/streams/pony-pinkiepie</li>
<li>/streams/pony-derpyhooves</li>
</ul>

<p>Now what I want to do is create a projection for each of these streams, so I can ask "how far has each of these ponies jumped", that's next :)</p>]]></description><link>http://codeofrob.com/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html</link><guid isPermaLink="true">http://codeofrob.com/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 30 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Basic projections in the EventStore]]></title><description><![CDATA[<p>Being able to <a href="/entries/pushing-data-into-streams-in-the-eventstore.html">shove events in and out</a> is great for our event sourced apps, but actually - if we have these streams, it's really useful to be able to consistently manipulate the events as they come in and either query those events or re-organise them so they can be queried.</p>

<p>To do this, we have the notion of projections, which are chunks of code that can be executed over a stream (with persisted state) as events are added to it. Now, in reality this isn't actually too different to what we'd be doing outside the event store when building up view models, and I foresee lots of bad things being done by people are the line between these different ways of reading streams are blurred and fought over.</p>

<p>I'm actually quite interested in these projections as a way of building up state for reports/charts, or re-partitioning into streams for different consumers - let's have a look how the most basic of these could work. </p>

<p>Let's say I've got a few events in the general structure of</p>

<pre><code>{
  EventType: "PonyJumped",
  Data: {
    Pony: "Derpy Hooves",
    Height: 10,
    Distance: 13
  }
}
</code></pre>

<p>and</p>

<pre><code>{
  EventType: "PonySpoke",
  Data: {
    Sentence: "This is the best day ever",
    Pony: "Pinkie Pie"
  }
}
</code></pre>

<p>And I'm putting all of these events into a single stream <em>ponies</em></p>

<p>Let's say that I've thrown a few hundred thousand of these events through the event store and I want to know something really basic, like how many times the ponies in my world have jumped since time began.</p>

<p>There is a Web UI available for managing projections in the event store (by default available at 127.0.0.1:2113). This is still subject to change though so I'll just be describing the ideas behind this concept.</p>

<p>There are some attributes of a projection that we can choose when creating a projection via HTTP or the UI</p>

<ul>
<li>Name: This is the name of the projection, I'll use this to look up the state</li>
<li>Source: This is the code to be executed</li>
<li>Emit Enabled: Projections can emit (or link) events if this is enabled</li>
<li>Enabled: Is this projection going to run?</li>
</ul>

<p>My options</p>

<ul>
<li>Name: "PonyJumpCount"</li>
<li>Source: TBC</li>
<li>Emit Enabled: Leaving this false (we'll cover usage of this later)</li>
<li>Enabled: Yes please!</li>
</ul>

<p>Now for the source, we'll start with the most basic projection which looks like this:</p>

<pre><code>fromAll()
  .whenAny(function(state,event) { 
     return null; 
  });
</code></pre>

<p>Basically, we have to select which streams we're going to be reading our events from, that "fromAll" bit means we're going to be reading from all of the streams, I'm going to go ahead and change that to "fromStream" and select our "ponies" stream.</p>

<pre><code>fromStream("ponies")
  .whenAny(function(state,event) { 
     return null; 
  });
</code></pre>

<p>How about that next bit "whenAny", well we've already matched which stream we want events from, well this is the bit we get to use to select which events from that stream we're interested in - "whenAny" just means "all the events in the stream".</p>

<p>I'm going to go ahead and change that to a when, which takes in a map of the events we're interested in and the callback to process the event with (pattern-matching on the EventType)</p>

<pre><code>fromStream("ponies")
  .when({
    "PonyJumped": function(state, event) {
      return null;
    })
</code></pre>

<p>Now for that callback - we have "state" and "event", the former being the state we're building up for this projection, and the latter being the event we're going to be adding to that state.</p>

<p>To begin with, we haven't actually got any state, but we can rectify that by chucking in an "$init" handler (anything starting with a dollar is something built in to the event store)</p>

<pre><code>fromStream("ponies")
  .when({
    $init: function() {
      return { count: 0 }
    },
    "PonyJumped": function(state, event) {
      return state
    }
  })
</code></pre>

<p>And now, the actual bit of code for building up our projection</p>

<pre><code>fromStream("ponies")
   .when({
        $init: function() {
           return { count: 0 }
        },
        "PonyJumped": function(state, event) {
          state.count += 1
        }
  })
</code></pre>

<p>If I hit save and navigate to</p>

<p><em>http://127.0.0.1:2113/projection/PonyJumpCount/state</em></p>

<pre><code>{
  count: 1337
}
</code></pre>

<p>I get some wonderful state.</p>

<p>Well, that was very basic, next time we'll look at how we could generate one of these projections for each pony we have in our world.</p>]]></description><link>http://codeofrob.com/entries/basic-projections-in-the-eventstore.html</link><guid isPermaLink="true">http://codeofrob.com/entries/basic-projections-in-the-eventstore.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 29 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Pushing data into streams in the EventStore]]></title><description><![CDATA[<p>I'm <a href="/entries/playing-with-the-eventstore.html">playing with the EventStore</a> and I need to push some data into it in the form of streams.</p>

<p>What does this look like? Well I'm using NodeJS, and naturally that means using JSON and object literals:</p>

<p>So, if I have an event</p>

<pre><code>// An Event
{
  Data: {
    PonyName: "Rainbow Dash",
    TrampStamp: "Rainbow",
    Date: "January 2013"
  },
  EventType: "PonyBorn"
}
</code></pre>

<p>And I want to get this into a stream, well first I want to package it up</p>

<pre><code>// A package with the event in it
{
  CorrelationId: "something-i-know",
  ExpectedVersion: "last-version-i-knew-about",
  Events: [ ev ]
}
</code></pre>

<p>And serialise it</p>

<pre><code>var body = JSON.stringify(package)
</code></pre>

<p>I can POST it to the event store with the following code</p>

<pre><code>var req = http.request({
  host: "127.0.0.1",
  port: 2113,
  path: "/streams/ponies",
  method: "POST",
  headers: {
    "Accept": "application/json",
    "Content-Type": "application/json",
    "Content-Length": body.length
  }
}, function(res) {
  // Handle this
})

req.write(body)
req.end()
</code></pre>

<p>What do we notice about the data?</p>

<ul>
<li>We can supply a correlation id for our own convenience</li>
<li>We supply an expected version so our event can be rejected if things are not as they should be</li>
<li>We can send a collection of events to be committed all as one</li>
<li>EventType can be sent in alongside the event data</li>
</ul>

<p>And what do we notice about the request?</p>

<ul>
<li>We choose which stream to post to as part of the URL</li>
<li>We specify the content types we expect and are sending (because it can accept XML etc)</li>
</ul>

<p>What happens once I've done this?</p>

<p>Well, we'll see that I have a ponies stream</p>

<p><em>/streams</em></p>

<pre><code>{
  title: "ponies",
  uri: "http://127.0.0.1:2113/streams/ponies",
  accepts: [
    {
      type: "text/xml"
    },
    {
      type: "application/atom+xml"
    },
    {
      type: "application/json"
    },
    {
      type: "application/atom+x.json"
    }
  ]
},
</code></pre>

<p>And that if we go to this ponies stream via the URI specified we'll see</p>

<p><em>/streams/ponies</em></p>

<pre><code>[
  {
    title: "ponies #1",
    id: "http://127.0.0.1:2113/streams/ponies/1",
    updated: "2013-03-01T22:30:11.790066Z",
    author: {
      name: "EventStore"
    },
    summary: "Entry #1",
    links: [
      {
        uri: "http://127.0.0.1:2113/streams/ponies/1",
        relation: "edit"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/1?format=text",
        type: "text/plain"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/1?format=json",
        relation: "alternate",
        type: "application/json"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/1?format=xml",
        relation: "alternate",
        type: "text/xml"
      }
    ]
  },
  {
    title: "ponies #0",
    id: "http://127.0.0.1:2113/streams/ponies/0",
    updated: "2013-03-01T22:30:11.79004Z",
    author: {
      name: "EventStore"
    },
    summary: "Entry #0",
    links: [
      {
        uri: "http://127.0.0.1:2113/streams/ponies/0",
        relation: "edit"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/0?format=text",
        type: "text/plain"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/0?format=json",
        relation: "alternate",
        type: "application/json"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/0?format=xml",
        relation: "alternate",
        type: "text/xml"
      }
    ]
  }
]
</code></pre>

<p>We have two events, navigating to them we can see that one of them is for the creation of the stream</p>

<p><em>/streams/ponies/event/0?format=json</em></p>

<pre><code>{
  eventStreamId: "ponies",
  eventNumber: 0,
  eventType: "$stream-created-implicit",
  data: "",
  metadata: ""
}
</code></pre>

<p>And the other one is the event we pushed</p>

<p><em>/streams/ponies/event/1?format=json</em></p>

<pre><code>{
  eventStreamId: "ponies",
  eventNumber: 1,
  eventType: "PonyBorn",
  data: {
    PonyName: "Rainbow Dash",
    TrampStamp: "Rainbow",
    Date: "January 2013"
  },
  metadata: ""
}
</code></pre>

<p>Neato, I guess we notice a few things here then</p>

<ul>
<li>The stream doesn't contain the actual events, just links to the events</li>
<li>The stream is pageable, and contains the links to the pages (well, it's AtomPub)</li>
<li>Each event has its own unique uri, because events are immutable these can be cached by any intermdiate proxy</li>
</ul>

<p>And indeed, if we look at the header on a HTTP request for one of these events we'll see</p>

<pre><code>Cache-Control:max-age=31556926
</code></pre>

<p>That's cool, we've discovered that</p>

<ul>
<li>We can throw events into the event store with a default partitioning (the stream name specified)</li>
<li>We can get them back out again by paging through the links in that stream</li>
<li>Events are infinitely cacheable</li>
<li>Everything is AtomPub</li>
<li>Everything is easily navigable</li>
</ul>

<p>Now, if we were building a standard event sourced model we'd be able to page through these streams to build up our snapshots/viewmodels and that's all very neat and tidy and that would be the end of our story.</p>

<p>Next up however, it's more interesting to go and have a look at projections now, and see what questions we can ask of those streams in the event store itself.</p>]]></description><link>http://codeofrob.com/entries/pushing-data-into-streams-in-the-eventstore.html</link><guid isPermaLink="true">http://codeofrob.com/entries/pushing-data-into-streams-in-the-eventstore.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 26 Apr 2013 09:30:00 GMT</pubDate></item></channel></rss>