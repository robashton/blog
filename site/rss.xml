<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>NodeJS RSS Module</generator><lastBuildDate>Thu, 14 Feb 2013 13:49:45 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Getting rid of temporary indexes in RavenDB]]></title><description><![CDATA[<p>I talked about RavenDB's new ability to promote and demote automatically created indexes <a href="/entries/auto-idling-auto-indexes-in-ravendb.html">yesterday</a>, but what are the implications of this?</p>

<p>I mentioned that the process in RavenDB for managing dynamically created indexes is as thus:</p>

<ul>
<li>Look for appropriate index to use in query</li>
<li>If found, return the most appropriate index</li>
<li>If not found, create an index that will deal with the query</li>
<li>Return that index as a Temporary</li>
<li>If that index is used enough, promote it into an Auto index</li>
<li>If that index is not used enough, delete it</li>
</ul>

<p>Well, we now have a way of marking indexes as idle and therefore not taking up needless resources, we can <em>remove temporary indexes entirely</em>.</p>

<p>That's actually a lot of code we can remove, in fact a pile of code that I wrote over two years ago, that's kinda cool, as it means entire code-path that doesn't need maintaining any more.</p>

<p>Obviously we can still remove auto indexes that were only queried once or twice, but that can take part with the algorithm that marks them as idle, and to make things even better we can add some functionality to the Studio to manage these idle indexes or delete them.</p>

<p>Now, this still isn't as awesome as it could be, but we've laid the ground work for a pretty awesome feature, I'll talk about that tomorrow.</p>]]></description><link>http://codeofrob.com/entries/getting-rid-of-temporary-indexes-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/getting-rid-of-temporary-indexes-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 14 Feb 2013 12:34:00 GMT</pubDate></item><item><title><![CDATA[Auto idling auto indexes in RavenDB]]></title><description><![CDATA[<p><a href="/entries/adding-idle-indexes-to-ravendb.html">Last entry</a> I talked about the addition of a priority flag on indexes to save resources on un-important indexes.</p>

<p>This is great news for those indexes that are created and managed manually (once Raven Studio has the UI for it anyway), but a lot of customers are using auto indexes (a feature I'm proud to say I had a hand in <a href="http://ayende.com/blog/4667/ravens-dynamic-queries">All those years ago</a>).</p>

<p>What does this therefore mean for this type of index? Well, the way RavenDB currently works for those unfamiliar with it, is if you make a query for all the ponies with rainbow in their name like so:</p>

<pre><code>session.Query&lt;Pony&gt;().Where(pony =&gt; pony.Name.Contains("Rainbow"))
</code></pre>

<p>There is a query optimiser which will try to find an appropriate index to use for this query, and if it fails it will create an index for you at the following URL:</p>

<pre><code>/Index/Temp/PonyWithName
</code></pre>

<p>Or something similar (I forget the exact conventions). After a period of time, the index will be deleted unless it is used within a certain threshold of activity.</p>

<p>On top of this, we now have idle indexes - so what does this mean? We can actually do a lot of this automatically now too, if we select the least-used indexes in the system <em>(for example, order all the auto-indexes by the last time they were queried, and if there is a big gap between the last index and the penultimate index, then demote the index automatically)</em></p>

<p>If the index is queried against after this, we can promote it again - happy days, thus the following scenarios:</p>

<ul>
<li>Manual indexes get left alone unless managed in the studio</li>
<li>Auto indexes get made idle if they're not queried very much</li>
<li>Auto indexes get promoted if they're then queried</li>
</ul>

<p>Having the database make these decisions for you keeps away any of the possible complexity of maintaining a well behaving RavenDB implementation.</p>

<p>I left off yesterday by talking about the Forced flag, the idea behind this is you can force an index to keep its current state by using the Studio and not have any of this fancy magic stuff happen  for you. I expect most people won't use it, but it's always good to give customers the ability to assert control.</p>

<p>Now, with this done - the next natural cause of action is obvious really, what would that be...? Stay tuned for my next entry to find out.</p>]]></description><link>http://codeofrob.com/entries/auto-idling-auto-indexes-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/auto-idling-auto-indexes-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 13 Feb 2013 12:34:00 GMT</pubDate></item><item><title><![CDATA[Adding idle indexes to RavenDB]]></title><description><![CDATA[<p>As I mentioned <a href="/entries/working-at-hibernating-rhinos.html">yesterday</a>, I'm currently doing a week or so of work at Hibernating Rhinos (more specifically on RavenDB).</p>

<p>One of the first things I was asked to look at was the indexing system in RavenDB, as there was a backlog of tasks and requests on these, which tie into each other in numerous ways.</p>

<p>I don't like working on more than one thing at once when I'm Getting Things Done, and while it was tempting to jump right in and say <em>"We need to do the feature where dynamic indexes can be turned off, deleted and compacted over time"</em>, the task was broken up into a few discrete features - some which had been requested individually anyway.</p>

<p>That brings me to the first feature we added in the first few hours of starting work at the office, I sat down with <a href="http://twitter.com/ayende">@ayende</a> and added the capability for indexes to be idle.</p>

<h2>What does that mean? Why would we want to do it? </h2>

<p>In RavenDB, querying is cheap because the answers have already been pretty much worked out by the indexing process. The indexing process has to crawl over every document as they're added and run user-logic over those documents, this is a process that tends to be IO bound as well as using up a few CPU cycles.</p>

<p>Thus, the more indexes you have, the more work the database has to do during heavy write periods - and as some customers have many indexes and also undergo heavy write periods, it has been requested more than once that indexes be prioritisable - this feature is a big step in that direction. </p>

<p><img src="/img/idlewis.png" alt="" title="" /></p>

<p>Indexes on the server now have a new flag, "Priority", which can take the following values (Normal | Idle | Forced), the idea being that the user can use the administration console to set indexes that aren't as important to not be run during busy write periods, and instead only be processed during idle time.</p>

<p>The forced flag? Well, I'll write about that tomorrow when I cover how idle indexes have been used to make auto-indexing a bit cleverer.</p>]]></description><link>http://codeofrob.com/entries/adding-idle-indexes-to-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/adding-idle-indexes-to-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 12 Feb 2013 12:34:00 GMT</pubDate></item><item><title><![CDATA[Working at Hibernating Rhinos]]></title><description><![CDATA[<p>After a week off in the Western Isles, I've started a stint on my <a href="/entries/i-am-not-looking-for-a-job.html">adventures</a> working in Israel for <a href="http://hibernatingrhinos.com">Hibernating Rhinos</a>.</p>

<p>Most of you are familiar with this company, but for those that aren't, it's <a href="http://twitter.com/ayende">@ayende</a>'s company, and they make the profilers for various ORMS and that document database we all love, <a href="http://ravendb.net">RavenDB</a>.</p>

<p><img src="/img/ravendb.png" alt="" title="" /></p>

<p>This is a good one for me,  I've never been to Israel before so that's a big+1, I'm already pretty familiar with the product and code-base having spent a while talking about it and contributing over the years - and as I've just spent a holiday doing no code I'm pretty excited to be getting some work done.</p>

<p>I made it through security at about 1am after being asked too many times "what are you doing in Israel" and being unable to think of a truthful answer that didn't make people suspicious. "I'm on a working holiday" led to questions of payment and of course I'm currently free as in beer so that's something I need to work on if I'm going to any other countries with strict entry requirements.</p>

<p>Anyway, I've got a car while I'm here and an apartment for the next week and I'm doing work on RavenDB, what work you ask? Well, like any good employer, Ayende has created a to-do list and let me get on with it how I like.</p>

<p>I quite like this way of working, "Here is a pile of stuff that needs doing, get to it and ask if you need any help", no long meeting to align on vision and share synergies with stakeholders, no complicated requirements document or architecture plans - just a list of bullet points and the expectation that I'll go and seek the information that I need to get the job done. (Managers take note!).</p>

<p>This is also a very productive way of working, I'll talk more about the actual work I'm doing in the next post, but what I can say is that I've cleared most of what I was expected to do in the whole time I'm here in the first couple of days of arriving. That's what Getting Things Done is all about and it aligns well with my aims of working on travelling.</p>

<p>How we are working is nice, as I said - there is a to-do list, that's publicly visible on <a href="http://issues.hibernatingrhinos.com">issues.hibernatingrhinos.com</a> under the tag "Rob's sprint", I'm working off a fork of the main project and keeping a pull request open as I go through - the current pull request can be found <a href="https://github.com/ravendb/ravendb/pull/502">here</a>, and here is a screenshot of that so far:</p>

<p><img src="/img/hrpr.png" alt="" title="" /></p>

<p>And this is the issues list so far (green means 'done')</p>

<p><img src="/img/hryt.png" alt="" title="" /></p>

<p>I've got plans of tourism on Friday and Saturday (Sunday is a work day in Israel - that's something new I found out), maybe I'll put some photos online of me floating in the dead sea.</p>

<p>I'll write about the actual work I'm doing in the next few entries.</p>]]></description><link>http://codeofrob.com/entries/working-at-hibernating-rhinos.html</link><guid isPermaLink="true">http://codeofrob.com/entries/working-at-hibernating-rhinos.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 11 Feb 2013 12:34:00 GMT</pubDate></item><item><title><![CDATA[Lots of small things]]></title><description><![CDATA[<p><strong>Questions:</strong></p>

<ul>
<li>"But how do you maintain large JS codebases..."</li>
<li>"How do I build Enterprise Scale JS applications"</li>
<li>"How do I refactor across an entire project in JS"</li>
</ul>

<p><strong>Answers:</strong></p>

<ul>
<li>You don't</li>
<li>Lots of small things</li>
<li>Build small things that do one thing well</li>
<li>You shouldn't build large JS codebases</li>
</ul>

<p>Etc</p>

<p>I almost started a drinking game at NodeDublin, "take a drink every time somebody mentions the Unix Philosophy or one of the above statements", I'm glad I did not - it was held in the Guinness Storehouse and I'd have not lasted beyond the first couple of sessions had I gone through with it.</p>

<p>These are sentiments uttered at conferences, in meeting rooms, in blog comments, in blog entries and pretty much whenever the subject of large code-bases in JS come up. Normally uttered with a self-satisfied smirk and with little to no further guidance on how exactly one might go about it.</p>

<p>Sure, you can always fall back to Typescript or Coffeesript or KoolaidScript, sure you can leverage awesome IDEs like Webstorm, Visual Studio, etc, but we've been building Enterprise Systems in C# and Java for years in this way, and the wheels of progress eventually stop turning because iteration becomes expensive, maintenance becomes 90% of the job and every meeting boils down to a question of "legacy", "compromise" and  "we are where we are".</p>

<p>So, this is what I am doing, this is my current recipe, a collection of the rules of thumb I am using for building an open source game engine (PrimoJS) in JavaScript in a way that doesn't make my brain run out of my ears whenever I want to write a new feature. (Caveat: I haven't "released" this engine, I am merely pulling it together out of code already written to help me do Ludum Dares faster)</p>

<p>This is client side JavaScript only in this project, all of this is equally applicable to JS in ASP.NET MVC projects, in J2EE-whatevs projects and probably your Ruby on Rails projects too.</p>

<p>TLDR: Browserify + npm + github = success</p>

<h2>NodeJS</h2>

<p>I don't care if you're not writing NodeJS for whatever reason, the command line tooling being built up in this area to help with JS is fantastic, and trying to use the copy-cat tooling being built up in your favourite Enterprise environment is just setting yourself up for frustration and trouble in the future. It's just an exe, get it and integrate it with your toolchain, make your life better today.</p>

<h2>Browserify</h2>

<p>Okay, I'm a convert - I've been talking AMD for a while now, and the idea of having to run a build script had put me off Browserify for a while - it turns out the development experience is pretty good and by the time you get to the browser to hit refresh, this is generally done already anyway. AMD is now dead to me.</p>

<pre><code>npm install -g browserify
</code></pre>

<p>Once you have it, if you write your JS with node-flavoured CommonJS style require calls, you can package JS up for the client by running Browserify as part of your build script.</p>

<p><strong>app.js</strong></p>

<pre><code>var windowing = require('./windowing')
  , messaging = require('./messaging')


messaging.on('foo', function(message) {
  windowing.showMessage(message)
})
</code></pre>

<p><strong>Then build</strong></p>

<pre><code>browserify site/app.js &gt; site/app-built.js
</code></pre>

<p>This might be alarming at first, because it seems like concatenating these files might make the debug experience a thing of nightmares, but that's what the --debug flag is for:</p>

<pre><code>browserify site/app.js -o site/app-built.js --debug
</code></pre>

<p>This inserts special directives into the JS so the browser knows what the original files were and they can therefore be opened and debugged in their original state.</p>

<p>I have a Makefile I copied from VoxelJS - it looks like this</p>

<pre><code>all: concat

concat:
  browserify site/app.js &gt; site/app-built.js

watch:
  browserify site/app.js -o site/app-built.js --watch --debug
</code></pre>

<p>During development of my application, I type</p>

<pre><code>make watch
</code></pre>

<p>and I don't have to think about this ever again.</p>

<p>Now, the cool part. With RequireJS I was always having to set up elaborate configuration scripts, "You can find underscore over here, you can find jQuery over here, you can find this other legacy JS over here, please do these things with them", this was, in short, a ball-ache.</p>

<p>Browserify eschues this way of thinking, and simply says "if it's a relative path, I'll use it, if it's a global path I'll look in node_modules"</p>

<h2>NPM</h2>

<p>Here comes and important learning: <em>it is not enough</em> to simply use a require system, split your JS across multiple files in a folder and say "my files are small and therefore I am building small things", having all your code in a single project is not sufficient encouragement to think about the boundaries between those files and before long you will find yourself with 10,000 lines of spaghetti JS across 100 files in a folder with relative include paths and feel the pain it causes when trying to change anything at all inside of that.</p>

<p><strong>NPM has the answer</strong></p>

<p>By saying "I am going to build independent modules, and require them from my application as needed", you are making a statement of intent that those modules will have some fairly important qualities.</p>

<ul>
<li>A module should be re-writeable in a day without affecting the rest of the system</li>
<li>A module should export a single function that has clearly described responsibilities</li>
<li>A module is independently versioned &amp; published to the registry as its own thing</li>
<li>A module should therefore not be coupled to any of the modules that consume it, relationships should be uni-directional</li>
<li>A module has its own git repository and history</li>
</ul>

<p>For example, the biggest module in the PrimoJS eco-system is the core engine, at 700LOC, and that is <em>too big</em>, I am still harvesting that original codebase into smaller modules - this takes time because it is hard to go from big to small, it is hard to go from coupled to uncoupled and it is harder still when you are trying to be always making changes that roll forward, rather than backwards in terms of progress.</p>

<p>Nevertheless, PrimoJS is currently split across 16 modules, all of which fit the above list of requirements, they could all be used independently of each other, or more likely brought into a project that has pulled in the core engine and wants the additional functionality that these modules bring.</p>

<p>What does this look like in reality? This is the package.json of one of my 'example' projects, the actual application using PrimoJS</p>

<pre><code>{
  "name": "centipede2013",
  "version": "1.0.0",
  "dependencies": {
    "send": "~0.1.0",
    "express": "~3.0.3",
    "underscore": "~1.4.3"
  },
  "devDependencies": {
    "primo": "",
    "primo-animation": "",
    "primo-text": "",
    "primo-boundary": "",
    "primo-rigidbody": "",
    "primo-events": "",
    "primo-audio": ""
  },
  "engines": {
    "node": "0.8.x",
    "npm": "1.1.x"
  }
}
</code></pre>

<p>The core engine is brought in, and then other components are brought in for use with that project, it is important to note that none of these components have a dependency on that core primo module, or vice versa - they are independent and could be used independently. 
What does this look like? Well, I can use NPM list to show me the dependency graph, which goes something like this:</p>

<pre><code>├─┬ primo@0.1.1
│ ├── primo-camera@0.0.0
│ ├── primo-canvas@0.0.0
│ ├── primo-counter@0.0.0
│ ├── primo-events@1.0.2
│ ├── primo-spritemap@0.0.0
│ └── primo-timer@0.0.0
├─┬ primo-animation@0.0.1
│ └─┬ primo-spritemap@0.0.1
│   ├── primo-canvas@0.0.0
│   └── primo-events@1.0.2
├── primo-boundary@0.0.0
├── primo-audio@0.0.6
├── primo-events@1.0.2
├─┬ primo-rigidbody@0.0.2
│ └── primo-utils@0.0.0
├── primo-text@0.0.0
</code></pre>

<p>We'll notice that the spritemap is used several times, as is primo-events and primo-canvas. If I was using relative paths, this would be pretty messy and hard to trace, but with a package manager the relationship is clear and it is obvious that those modules are independent.</p>

<p>Fine, so what now? I have a folder on my hard drive that has a pile of other folders in them, each has its own package.json, its own git repository and can be developed independently - but this is hardly ideal from a development point of view is it?</p>

<p>An obvious question to be asked now, is "If you have a bug in primo-animation that impacts your centipede application, how do you fix, test, verify and iterate on that bug without copying JS around and making a mess of things. (How often have you downloaded the source of NHIbernate in .NET and had to debug an issue with it that happens in your code base? It's not fun is it)</p>

<p>That's where NPM really shines, we have NPM link - one of the finest commands in the history of package management.</p>

<pre><code>cd components/animation
  /usr/local/lib/node_modules/primo-animation -&gt; /home/robashton/src/primo/components/animation
cd ../../examples-centipede
npm link primo-animation
/home/robashton/src/primo/examples-centipede/node_modules/primo-animation -&gt; /usr/local/lib/node_modules/primo-animation -&gt; /home/robashton/src/primo/components/animation
</code></pre>

<p>NPM can set up symlinks, so editing the files in primo animation <em>in place</em>, will result in the changes being visible in the application as you make these changes.</p>

<p>This tells you a few things</p>

<ul>
<li>This is an explicit step, you have to conciously choose to edit across module boundaries</li>
<li>You shouldn't be doing this often on a stable system</li>
<li>Ideally, you'd have a test harness so you can iterate and develop fixes/etc independently of the usage of the module itself</li>
</ul>

<p>Now, as the ever-pragmatic developer, I know that Primo right now is open to a lot of churn and I'm happy to be editing across these boundaries occasionally (especially with new modules), but as modules become mature I shouldn't be touching them any more - and later on I might choose to swap one out for another that does it better anyway.</p>

<p>What's even better about the use of NPM is that I can pretty much forgoe that whole thing where I have a folder called 'libs' with all sorts of crazy JS in it. That's a pretty sweet deal and something I can whole-heartedly get behind on.</p>

<h2>The Caveats</h2>

<p><strong>NPM</strong></p>

<p>It is worth pointing out that for client-side JS package management, the whole ecosystem is very much in the air -  we have Bower, Volo, Yeoman, Jam, etc. Each come with their own idea of a manifest, linking, dev etc.</p>

<p>For now, I don't see the point - NPM works really well and has already solved most of the problems inherent to a pure world of JS (We're not talking other kinds of deps such as HTML/CSS/etc - and for that Bower might still hold the answer)</p>

<p>The problem with NPM is that you're never sure which modules are client-side or server-side, not everything works everywhere - for example, the jQuery package in NPM is the server-side jQuery which makes life pretty confusing for now.</p>

<p><strong>Folder hell</strong></p>

<p>I have lots of folders, each with their own git repository, their own package.json, their own published state etc. This shouldn't bother me, because they're indepdendent and work done on these things should be independent - but that's not really the case when adding new features to a game that requires new code in primo-pritemap that requires new code in primo-canvas.</p>

<p>This shouldn't happen very often (and it doesn't, because having things that do one thing and needing it to do two things means you probably want two things, that second thing being a new thing), but when it does, and you're offline, you end up with folders that are out of date with regards to the published state of the package and the only way I can see to manage this is to go through all these folder and check manually whether I need to push and/or publish. This could be solved by tooling - any takers?</p>

<p><strong>Package hell</strong></p>

<p>I have lots of packages, each with their own git repo - but the primary use case is for usage within the PrimoJS eco-system - when you pull down primo for use in a new game you only get the core, and a lot of the time you might want animations, audio, physics etc.</p>

<pre><code>&gt; npm install primo --save
</code></pre>

<p>There is nothing here to tell the developer that they might also want to do</p>

<pre><code>&gt; npm install primo-animations primo-audio primo-rigidbody --save
</code></pre>

<p>I think this can be solved with documentation and tooling, maybe a command line script ala RoR for generating a new game's folder structure</p>

<pre><code>&gt; primo-create mynewgame
do you want all the default components available? (y/n)
&gt; y
do you want a level editor (y/n)
&gt; n
do you want a browserify build script? (y/n)
&gt; y
</code></pre>

<p><strong>Module discovery + documentation</strong></p>

<p>Again, lots of small modules - where does the documentation go? Where does the user go to find answers to his questions when he has them? where does the user go to work out which module is for what?</p>

<p>I think this varies across projects, are your modules all part of the same eco-system? Are they truly standalone and usable wherever? I think for each 'tree' of modules, a single <em>source</em> of information is useful - even if the sub-categories are just links to the documentation for the specific modules. Making the user go searching for the right module and the right documentation is just asking for trouble down the line. (So, in my case, it would be primojs.com and links to the available modules.</p>

<h2>Summary</h2>

<p>This is just one way of tackling this, but it is real world and it does work quite nicely (apart from the solveable caveats above). It will be interesting to see which direction client side dependency management will go over time, but CommonJS is not going anywhere anytime soon and is a safe bet to be building your project on (regardless of whether it is Browserify or Stitch/etc doing the packaging for you)</p>

<p>The most important part of all of this is creating the the modules to be standalone so you don't <em>have</em> to traverse across them when building new features or fixing bugs. Replacing folders with modules is for nought if you don't actually make modules.</p>

<h2>Links</h2>

<ul>
<li>Browserify <a href="http://github.com/substack/node-browserify">http://github.com/substack/node-browserify</a></li>
<li>NodeJS <a href="http://nodejs.org">http://nodejs.org</a></li>
<li>NPM <a href="http://npmjs.org">http://npmjs.org</a></li>
<li>PrimoJS (not "released" yet) <a href="http://github.com/robashton/primojs">http://github.com/robashton/primojs</a></li>
<li>VoxelJS <a href="http://github.com/maxogden/voxel">http://github.com/magogden/voxel</a></li>
</ul>]]></description><link>http://codeofrob.com/entries/lots-of-small-things.html</link><guid isPermaLink="true">http://codeofrob.com/entries/lots-of-small-things.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 25 Jan 2013 12:34:00 GMT</pubDate></item></channel></rss>