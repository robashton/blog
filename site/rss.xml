<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>RSS for Node</generator><lastBuildDate>Wed, 28 Oct 2020 10:14:50 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><author><![CDATA[Rob Ashton]]></author><item><title><![CDATA[Purerl Updates - Message Routing From Legacy Code]]></title><description><![CDATA[<p>We&#39;ve covered the essential upgrades to Pinto and Stetson, so now we&#39;ll cover a quick bonus topic which is one of the concepts thrown into Pinto to help with all of this work.</p>
<h1 id="previous-purerl-posts">Previous Purerl posts</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="updates">Updates</h1>
<ul>
<li><a href="/entries/updates-to-pinto+stetson---purerl-in-progress.html">Nix overlays for Purerl/etc</a></li>
<li><a href="/entries/purerl-updates---typed-routes-in-stetson.html">Typed routing for Stetson</a></li>
<li><a href="/entries/purerl-updates---arbitrary-messages-and-handle_info-in-gen-servers.html">Arbitrary messages and handle_info in gen_servers</a></li>
<li><a href="/entries/purerl-updates---arbitrary-messages-and-stetson-handlers.html">Arbitrary messages and Stetson handlers</a></li>
<li><a href="/entries/purerl-updates---monitors-in-stetson-and-pinto.html">Monitors for arbitrary pids from Gen servers + Stetson handlers</a></li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<h1 id="the-problem">The problem</h1>
<p>A <em>lot</em> of legacy Erlang code (ours included) will have something along the lines of </p>
<pre><code class="language-erlang">
cool_api:do_something().
</code></pre>
<p>That behind the scenes will almost immediately do a call to <em>self()</em> to get the caller pid and then probably spin up some more processes and start sending messages back to us.</p>
<pre><code class="language-erlang">
  do_something() -&gt;
    Self = self(),
    spawn_link(<span class="hljs-keyword">fun</span> Fun() -&gt;
      <span class="hljs-keyword">receive</span>
        _ -&gt;  ok
      <span class="hljs-keyword">after</span> <span class="hljs-number">1000</span> -&gt;
         Self ! hi
         Fun()
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>).
</code></pre>
<p>In this case, we&#39;ve got a native function called do_something() that captures the current pid, spins up a process which will stop if it receives anything and otherwise every second send a message back to the parent (hi).</p>
<p>If we were to write FFI for this, it&#39;d look a lot like this:</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> doSomething :: <span class="hljs-type">Effect</span> <span class="hljs-type">Pid</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> stop :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>

</code></pre>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">doSomething</span><span class="hljs-params">()</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
    cool_api:do_something()
  <span class="hljs-keyword">end</span>.

<span class="hljs-function"><span class="hljs-title">stop</span><span class="hljs-params">(Pid)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
    Pid ! this_will_stop_you_cos_you_received_something
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>We would immediately start receiving atoms of &#39;hi&#39; to the calling process, which unless we happen to be very specific and careful, won&#39;t know how to receive them, for example in a gen server.</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = {}</span>

<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span> <span class="hljs-type">Atom</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">Local</span> $ atom <span class="hljs-string">"listener"</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> =
  <span class="hljs-type">Gen</span>.buildStartLink serverName init $ <span class="hljs-type">Gen</span>.defaultStartLink { handleInfo = handleInfo }

<span class="hljs-title">init</span> :: <span class="hljs-type">Gen</span>.<span class="hljs-type">Init</span> <span class="hljs-type">State</span> <span class="hljs-type">Atom</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  <span class="hljs-type">Gen</span>.lift <span class="hljs-type">CoolApi</span>.doSomething
  pure $ {}

<span class="hljs-title">handleInfo</span> :: <span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">HandleInfo</span> <span class="hljs-type">State</span> <span class="hljs-type">Atom</span>
<span class="hljs-title">handleInfo</span> msg state = <span class="hljs-keyword">do</span>
  <span class="hljs-comment">-- got an atom, woo</span>
  <span class="hljs-comment">-- not much to do with it</span>
  pure <span class="hljs-type">CastNoReply</span> state
</code></pre>
<p>This will work, it&#39;s a gen server that knows how to receive atoms - but it&#39;s unlikely we&#39;ll want to write a gen server that only receives atoms and nothing else - as soon as we add a timer, monitor or subscribe to anything else we&#39;ll want to change our message type into an ADT so that we can dispatch over the various message types.</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">CoolApiMsg</span> <span class="hljs-type">Atom</span></span>
         | <span class="hljs-type">Tick</span>
</code></pre>
<p>So we&#39;re going to need some way to map this. </p>
<p><em>The old way</em>: We&#39;d register a mapping function with the gen server that would recognise the cool_api messages and convert them into the right type for us, this was janky AF and has been deleted in the latest Pinto</p>
<p><em>the new way</em>: Proxy process that receives the message, translates it and then sends it on to the main process</p>
<p>That proxy process is a burden to create because if we start spawning processes in Erlang, we need to make sure we monitor the parent so we terminate when it does, yada yada yada what a mess. Thankfully this is what <em>MessageRouter</em> in Pinto is for, it neatly wraps up this common pattern safely so we don&#39;t have to.</p>
<h1 id="pintomessagerouter">Pinto.MessageRouter</h1>
<p>The message router exports three functions of interest, one of which invokes a router on top of a process that will always start, and one on top of a process that might fail, the third takes a RouterRef (returned on success) and terminates the router.</p>
<pre><code class="language-haskell">
    startRouter :: <span class="hljs-keyword">forall</span> handle msg. <span class="hljs-type">Effect</span> handle -&gt; (handle -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>) -&gt; (msg -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>) -&gt;  <span class="hljs-type">Effect</span> (<span class="hljs-type">RouterRef</span> handle)

    maybeStartRouter = maybeStartRouterImpl <span class="hljs-type">RouterRef</span>

    stopRouter  :: <span class="hljs-keyword">forall</span> handle. <span class="hljs-type">RouterRef</span> handle -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
</code></pre>
<p>We&#39;ll focus on the simple case. </p>
<ul>
<li>Given an <em>Effect handle</em> - ie something that returns some reference to whatever is created (in our case a pid)</li>
<li>Given a function that given that handle, terminates the process</li>
<li>Given a callback that takes &#39;whatever is received&#39; and &#39;does something to it&#39; (<em>Effect Unit</em>)</li>
<li>We&#39;ll get an <em>Effect</em> of <em>(RouterRef handle)</em> back (which we can hold onto in order to terminate the whole show by calling stopRouter)</li>
</ul>
<p>Wrapping our legacy API is &quot;simple&quot; now that we&#39;ve already written the FFI for it</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">import</span> Pinto.MessageRouting <span class="hljs-keyword">as</span> MR

<span class="hljs-title">wrappedDoSomething</span> :: <span class="hljs-keyword">forall</span>. (<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>) -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">MR</span>.<span class="hljs-type">RouterRef</span> <span class="hljs-type">Pid</span>)
<span class="hljs-title">wrappedDoSomething</span> recv = <span class="hljs-type">MR</span>.startRouter <span class="hljs-type">CoolApi</span>.doSomething <span class="hljs-type">CoolApi</span>.stop recv

</code></pre>
<p>With this, we can re-write our gen server with the message lifted into the appropriate type</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = {}</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">Tick</span> | <span class="hljs-type">DoSomething</span> <span class="hljs-type">Atom</span></span>

<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">Local</span> $ atom <span class="hljs-string">"listener"</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> =
  <span class="hljs-type">Gen</span>.buildStartLink serverName init $ <span class="hljs-type">Gen</span>.defaultStartLink { handleInfo = handleInfo }

<span class="hljs-title">init</span> :: <span class="hljs-type">Gen</span>.<span class="hljs-type">Init</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  self &lt;- <span class="hljs-type">Gen</span>.self
  <span class="hljs-type">Gen</span>.lift <span class="hljs-type">Wrapper</span>.wrappedDoSomething $ send self &lt;&lt;&lt; <span class="hljs-type">DoSomething</span>
  pure $ {}

<span class="hljs-title">handleInfo</span> :: <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">HandleInfo</span> <span class="hljs-type">State</span> <span class="hljs-type">Atom</span>
<span class="hljs-title">handleInfo</span> msg state = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
    <span class="hljs-type">Tick</span> -&gt; ...
    <span class="hljs-type">DoSomething</span> msg -&gt; ...
</code></pre>
<p>It means an extra process per router, so isn&#39;t something we want to be using if we&#39;re going to be spinning up 1000s of short lived versions of it, but for that sort of thing we&#39;re in specialist territory where we&#39;d be using a look up table or dropping to plain ol&#39; Erlang. (See also <em>Pinto.Timer</em> which just uses the underlying mechanisms to send messages of the right type directly without an intermediary process.</p>
<p>The point is that wrapping up legacy code that sends us arbitrary messages has been turned into a relatively small amount of work as a result of these changes, so long as we supply a start function and a stop function and a callback that knows what to do with the messages we can transform and then send accordingly. This has been used across our codebases with great success (as well as in Pinto itself) and has enabled our gen servers and web handlers to remain clean and receive the right typed messages.</p>
]]></description><link>http://codeofrob.com/entries/purerl-updates---message-routing-from-legacy-code.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl-updates---message-routing-from-legacy-code.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 14 Jul 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purerl Updates - Monitors in Stetson and Pinto]]></title><description><![CDATA[<p>We&#39;ve managed to get nicely typed arbitrary messages into our web handlers and gen servers, now it&#39;s time to look at Monitors.</p>
<h1 id="previous-purerl-posts">Previous Purerl posts</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="updates">Updates</h1>
<ul>
<li><a href="/entries/updates-to-pinto+stetson---purerl-in-progress.html">Nix overlays for Purerl/etc</a></li>
<li><a href="/entries/purerl-updates---typed-routes-in-stetson.html">Typed routing for Stetson</a></li>
<li><a href="/entries/purerl-updates---arbitrary-messages-and-handle_info-in-gen-servers.html">Arbitrary messages and handle_info in gen_servers</a></li>
<li><a href="/entries/purerl-updates---arbitrary-messages-and-stetson-handlers.html">Arbitrary messages and Stetson handlers</a></li>
<li>Monitors for arbitrary pids from Gen servers + Stetson handlers</li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<h1 id="monitors">Monitors</h1>
<p>A reasonably common pattern for monitors in some of our code is</p>
<ul>
<li>Internal server manages a collection of pids that are recipients of data streams</li>
<li>web handlers open and register with this server to receive those data streams</li>
</ul>
<p>In this case <em>sometimes</em></p>
<ul>
<li>It&#39;s useful for the internal server to monitor the subscribers and remove the pids when they become invalid</li>
<li>It&#39;s useful for the web handler to monitor the server, so it can close the connection if that goes away</li>
</ul>
<p>This isn&#39;t always the case, sometimes a static message bus is a better option, sometimes pids can be checked ad-hoc, but for the purpose of this example we&#39;ll assume that this is exactly what we want as it&#39;ll be a nice end-to-end example of message passing and monitoring in Purerl.</p>
<h1 id="the-internal-server">The internal server</h1>
<p>So we&#39;ll define a basic gen server that keeps a state that&#39;s a map of pids to functions that receive data <em>(Binary -&gt; Effect Unit)</em>, and set up a timer to send us a <em>Tick</em> message after 500ms - our message type will therefore just be either that <em>Tick</em> message, or a message telling us that a client has disconnected. We&#39;ll configure the gen server to use a <em>handleInfo</em> function when these come in (explored further below).</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = {
  <span class="hljs-title">handlers</span> :: <span class="hljs-type">Map</span>.<span class="hljs-type">Map</span> <span class="hljs-type">Pid</span> <span class="hljs-type">MessageHandler</span>
}</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">MessageHandler</span> = (<span class="hljs-type">Binary</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>)</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">ClientDisconnected</span> <span class="hljs-type">Pid</span></span>
         | <span class="hljs-type">Tick</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookWatchingStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.buildStartLink serverName (init args) $ <span class="hljs-type">Gen</span>.defaultStartLink { handleInfo = handleInfo }

<span class="hljs-title">init</span> :: <span class="hljs-type">BookWatchingStartArgs</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">Init</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  self &lt;- <span class="hljs-type">Gen</span>.self
  void $ <span class="hljs-type">Gen</span>.lift $ <span class="hljs-type">Timer</span>.sendAfter <span class="hljs-number">500</span> <span class="hljs-type">Tick</span> self
  pure $ {
    handlers: <span class="hljs-type">Map</span>.empty
  }
</code></pre>
<p>We can export a function <em>registerClient</em> for clients to invoke in order to start receiving data, while we&#39;re still in the process that called us we can get its pid by calling out to &#39;<em>Pinto.self</em>&#39;, and then in the context of the gen server, we&#39;ll get our own pid so we can add the monitor in the next function <em>addHandler</em>.</p>
<p>As we have the pid of our calling process, we can invoke <em>Monitor.pid</em>, and pass in a callback that disregards the message given to us when the monitor pops and just sends a message with the handler pid back to our <em>handleInfo</em>. Once we&#39;re monitoring the handler, we can add it to our map using the pid as a key so we can easily remove it later when we get the message telling us it went down.</p>
<pre><code class="language-haskell">
<span class="hljs-title">registerClient</span> :: <span class="hljs-type">MessageHandler</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">registerClient</span> handler = <span class="hljs-keyword">do</span>
  handlerPid &lt;- <span class="hljs-type">Pinto</span>.self
  <span class="hljs-type">Gen</span>.doCall serverName \state -&gt; <span class="hljs-keyword">do</span>
     self &lt;- <span class="hljs-type">Gen</span>.self
     newState &lt;- <span class="hljs-type">Gen</span>.lift $ addHandler handler self handlerPid state
     pure $ <span class="hljs-type">CallReply</span> unit newState

<span class="hljs-title">addHandler</span> :: <span class="hljs-type">MessageHandler</span> -&gt; <span class="hljs-type">Process</span> <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Pid</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">addHandler</span> handler self handlerPid state@{ handlers } = <span class="hljs-keyword">do</span>
  void $ <span class="hljs-type">Logger</span>.info1 <span class="hljs-string">"Adding handler ~p as it has connected"</span> handlerPid
  void $ <span class="hljs-type">Monitor</span>.pid handlerPid (\_ -&gt; self ! <span class="hljs-type">ClientDisconnected</span> handlerPid)
  pure $ state { handlers = <span class="hljs-type">Map</span>.insert handlerPid handler handlers }
</code></pre>
<p>All that is left therefore, is to handle the messages we might receive into the handleInfo we configured earlier as part of startLink. </p>
<ul>
<li>If we get a ClientDisconnected, we simply remove the handler from our map so we no longer send any data to it</li>
<li>If we get a Tick, we invoke sendData on the map of handlers, before scheduling another tick for 500ms time</li>
</ul>
<pre><code class="language-haskell">
<span class="hljs-title">handleInfo</span> :: <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">HandleInfo</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">handleInfo</span> msg state@{ handlers  } = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
     <span class="hljs-type">ClientDisconnected</span> handlerPid -&gt; <span class="hljs-keyword">do</span>
        void $ <span class="hljs-type">Gen</span>.lift $ <span class="hljs-type">Logger</span>.info1 <span class="hljs-string">"Removing ~p as it disconnected"</span> handlerPid
        pure $ <span class="hljs-type">CastNoReply</span> $ state { handlers = <span class="hljs-type">Map</span>.delete handlerPid handlers }
     <span class="hljs-type">Tick</span> -&gt; <span class="hljs-keyword">do</span>
        <span class="hljs-type">Gen</span>.lift $ sendData handlers
        self &lt;- <span class="hljs-type">Gen</span>.self
        void $ <span class="hljs-type">Gen</span>.lift $ <span class="hljs-type">Timer</span>.sendAfter <span class="hljs-number">500</span> <span class="hljs-type">Tick</span> self
        pure $ <span class="hljs-type">CastNoReply</span> $ state 
</code></pre>
<p>Sending data is easy, seeing as the handlers are just a list of effectful callbacks of <em>(Binary -&gt; Effect Unit)</em></p>
<pre><code class="language-haskell">
<span class="hljs-title">sendData</span> :: <span class="hljs-type">Map</span>.<span class="hljs-type">Map</span> <span class="hljs-type">Pid</span> <span class="hljs-type">MessageHandler</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">sendData</span> handlers = <span class="hljs-keyword">do</span>
  freshData &lt;- getDataFromSomeNativeCode
  void $ traverse (\handler -&gt; <span class="hljs-keyword">do</span> handler freshData) $ <span class="hljs-type">Map</span>.values handlers 
  pure unit
</code></pre>
<p>So that&#39;s an entire gen server, which </p>
<ul>
<li>Allows the registration of callbacks that&#39;ll accept data</li>
<li>Monitors the pids of the calling process, and removes the callbacks when the monitor pops</li>
<li>Ticks every 500ms and traverses over the callbacks to send the data</li>
</ul>
<p>Note: Because of the callback/pids there is nothing stopping us using this code from any other Purerl (or indeed Erlang). None of this is Pinto specific and this is very much by design.</p>
<h1 id="subscribing-and-monitoring-from-stetson">Subscribing (and monitoring) from Stetson</h1>
<p>Speaking of other Purerl, a lot of Purerl gets written using Stetson to support Rest/Websockets/Streams/etc; so that&#39;s where we&#39;ll subscribe to this data. We&#39;ll also then add a monitor to that streaming process that closes the connection when it goes away. (We could also just block while we wait for it to restart for example).</p>
<p>So, we&#39;ll define a data type for our messages, we&#39;re either receiving data that needs to be streamed, our data source died, or our data source was already down when we tried to connect to it.</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">DataStreamMessage</span> = <span class="hljs-type">Data</span> <span class="hljs-type">Binary</span></span>
                       | <span class="hljs-type">DataSourceDied</span>
                       | <span class="hljs-type">DataSourceAlreadyDown</span>

</code></pre>
<p>We&#39;ll just kick off our handler with <em>Loop.handler</em>, start a streamed reply with a status code 200 and make sure that Stetson knows we&#39;re doing a Loop, we&#39;re typed as a <em>StetsonHandler DataStreamMessage Unit</em> because we receive <em>DataSteamMessage</em> and don&#39;t store any state of our own.</p>
<pre><code class="language-haskell">
<span class="hljs-title">dataStream</span> :: <span class="hljs-type">StetsonHandler</span> <span class="hljs-type">DataStreamMessage</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">dataStream</span> =
  <span class="hljs-type">Loop</span>.handler (\req -&gt; <span class="hljs-keyword">do</span>
               req2 &lt;- streamReply (<span class="hljs-type">StatusCode</span> <span class="hljs-number">200</span>) <span class="hljs-type">Map</span>.empty req
               <span class="hljs-type">Loop</span>.initResult req2 unit)
</code></pre>
<p>In our <em>Loop.init</em>, we&#39;ll get our own typed process <em>(Process DataStreamMessage)</em>, invoking &#39;<em>Process.send</em>&#39; on this gives us a function of type (Msg -&gt; Effect Unit) so we&#39;ll compose that with a constructor for our own data type (Data) giving us the correct function type of <em>(Binary -&gt; Effect Unit)</em></p>
<p>Using <em>Gen.monitor</em> with the server name of <em>MonitorExample</em>, we can detect when that process dies - there are two effectful callbacks for this, one for when the process dies and one for if the process is already down (there is no pid to monitor). </p>
<pre><code class="language-haskell">
    # <span class="hljs-type">Loop</span>.init (\req state -&gt; <span class="hljs-keyword">do</span> 
                      self &lt;- <span class="hljs-type">Loop</span>.self
                      void $ <span class="hljs-type">Loop</span>.lift $ <span class="hljs-type">MonitorExample</span>.registerClient $ send self &lt;&lt;&lt; <span class="hljs-type">Data</span>
                      void $ <span class="hljs-type">Loop</span>.lift $ <span class="hljs-type">Gen</span>.monitor <span class="hljs-type">MonitorExample</span>.serverName (\_ -&gt; send self <span class="hljs-type">DataSourceDied</span>) (send self <span class="hljs-type">DataSourceAlreadyDown</span>)
                      pure unit)
</code></pre>
<p>We receive those messages in the <em>Loop.info</em> callback</p>
<ul>
<li>if we get data then we can stream that directly to the client and carry on looping</li>
<li>if the data source died then we unceremoniously terminate the stream</li>
<li>if the data source is already down then we unceremoniously terminate the stream</li>
</ul>
<pre><code class="language-haskell">    # <span class="hljs-type">Loop</span>.info (\msg req state -&gt;  <span class="hljs-keyword">do</span>
                <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
                     <span class="hljs-type">Data</span> binary -&gt; <span class="hljs-keyword">do</span>
                        _ &lt;- <span class="hljs-type">Loop</span>.lift $ streamBody binary req
                        pure $ <span class="hljs-type">LoopOk</span> req state

                     <span class="hljs-type">DataSourceDied</span> -&gt;  <span class="hljs-keyword">do</span>
                       pure $ <span class="hljs-type">LoopStop</span> req state

                     <span class="hljs-type">DataSourceAlreadyDown</span> -&gt;  <span class="hljs-keyword">do</span>
                       pure $ <span class="hljs-type">LoopStop</span> req state
</code></pre>
<p>And that&#39;s that, we have a gen server running which will send data to any subscribers and clean up when those subscribers terminate, and we have a loop handler that&#39;ll subcribe to that data source and clean up if that data source dies. There is a lot going on here but it&#39;s worth unpicking as there are a lot of useful concepts here neatly packaged into a single example.</p>
<p>By sticking to plain ol&#39; pids and callbacks, all of this code remains portable and not tied to either of these libraries, which is handy because at some point somebody smarter than I will write something more Purerl idiomatic for web serving and OTP wrapping and we&#39;ll probably want to switch to those things..</p>
]]></description><link>http://codeofrob.com/entries/purerl-updates---monitors-in-stetson-and-pinto.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl-updates---monitors-in-stetson-and-pinto.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 09 Jul 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purerl Updates - Arbitrary messages and Stetson handlers]]></title><description><![CDATA[<p>An extra post was required on this topic..</p>
<h1 id="previous-purerl-posts">Previous Purerl posts</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="updates">Updates</h1>
<ul>
<li><a href="/entries/updates-to-pinto+stetson---purerl-in-progress.html">Nix overlays for Purerl/etc</a></li>
<li><a href="/entries/purerl-updates---typed-routes-in-stetson.html">Typed routing for Stetson</a></li>
<li><a href="/entries/purerl-updates---arbitrary-messages-and-handle_info-in-gen-servers.html">Arbitrary messages and handle_info in gen_servers</a></li>
<li>Arbitrary messages and Stetson handlers</li>
<li>Monitors for arbitrary pids from Gen servers + Stetson handlers</li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<h1 id="the-story-so-far">The story so far</h1>
<p>Stetson was thrown together at the same time as Pinto to enable me to start building real products in Purerl and I didn&#39;t have a lot of use for websockets at that time. When the need occurred in a client project, I added a new handler (WebSocketHandler) to Stetson to deal with this with an &#39;emitter&#39; function as part of the &#39;init&#39; callback and got on with my life.</p>
<pre><code class="language-haskell">
<span class="hljs-title">busEvents</span> :: <span class="hljs-type">ReceivingStetsonHandler</span> <span class="hljs-type">ExternalMessage</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">busEvents</span> =

  <span class="hljs-type">WebSocket</span>.handler (\req -&gt; <span class="hljs-type">WebSocket</span>.initResult req unit)
  # <span class="hljs-type">WebSocket</span>.init (\emitter s -&gt;  <span class="hljs-keyword">do</span>
                             <span class="hljs-type">Bus</span>.callback msg <span class="hljs-type">ExternalMessages</span>.bus $ emitter &lt;&lt;&lt; <span class="hljs-type">ExternalMsg</span>
                             pure $ <span class="hljs-type">NoReply</span> s
                             )
  # <span class="hljs-type">WebSocket</span>.handle (\msg state -&gt; pure $ <span class="hljs-type">NoReply</span> state)
  # <span class="hljs-type">WebSocket</span>.info (\msg state -&gt; pure $ <span class="hljs-type">Reply</span> ((<span class="hljs-type">TextFrame</span> $ writeJSON msg) : nil) state)
  # <span class="hljs-type">WebSocket</span>.yeeha
</code></pre>
<p>While I was &quot;getting on with my life&quot;, people were writing code on top of this, and a pull request came into Stetson to add a mapper for arbitrary messages being received into the process that I accepted without a second thought. </p>
<pre><code class="language-haskell">

<span class="hljs-title">nativeMapper</span> :: <span class="hljs-keyword">forall</span> msg. msg -&gt; <span class="hljs-type">ExternalMessage</span>

<span class="hljs-title">_</span> &lt;- (<span class="hljs-type">Stetson</span>.registerMapper $ nativeMapper <span class="hljs-type">SomeConstructor</span> <span class="hljs-type">SomeOtherConstructor</span>)
<span class="hljs-title">_</span> &lt;- subscribeToNativeEvents
</code></pre>
<p>At some point a month ago, I was asked about the Loop handler and streaming in Stetson by a colleague, I gazed apon the abomination that was external mapping and realised that it was time to do a proper job of unifying these handlers (a single type for all of them, meaning the death of &#39;yeeha&#39; sadly), deleting the ability to register external mappers and providing the ability to switch from a Rest handler into a Loop handler as part of content negotiation.  The actual means of doing this isn&#39;t worth covering in this post, but the end result is that we now had three namespaces for building handlers over the top of a single record and a standard pattern of being supplied an &#39;emitter&#39; function in the init callback for Loop and WebSocket for sending typed messages into the handler.</p>
<h1 id="straight-rest">Straight Rest</h1>
<pre><code class="language-haskell">
<span class="hljs-title">rest</span> :: <span class="hljs-type">StetsonHandler</span> {}
<span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-type">Rest</span>.initResult req {})
  # <span class="hljs-type">Rest</span>.serviceAvailable (\req s -&gt; <span class="hljs-type">Rest</span>.result true req s)
    # <span class="hljs-type">Rest</span>.allowedMethods (\req url -&gt; <span class="hljs-type">Rest</span>.result (<span class="hljs-type">Stetson</span>.<span class="hljs-type">HEAD</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">GET</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">OPTIONS</span> : nil) req s)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\s url -&gt; <span class="hljs-type">Rest</span>.result (jsonWriter : nil) req s)
</code></pre>
<h1 id="rest-into-loop">Rest into Loop</h1>
<pre><code class="language-haskell">
<span class="hljs-title">eventsFirehoseRest</span> :: <span class="hljs-type">StetsonHandler</span> <span class="hljs-type">EventsWsMsg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">eventsFirehoseRest</span> =
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-type">Rest</span>.initResult req unit)
    # <span class="hljs-type">Rest</span>.allowedMethods (\req state -&gt; <span class="hljs-type">Rest</span>.result (<span class="hljs-type">Stetson</span>.<span class="hljs-type">HEAD</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">GET</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">OPTIONS</span> : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (streamEvents : nil) req state)
    # <span class="hljs-type">Loop</span>.init (\emitter req state -&gt; <span class="hljs-keyword">do</span>
                              _ &lt;- <span class="hljs-type">SimpleBus</span>.subscribe <span class="hljs-type">BookLibrary</span>.bus $ <span class="hljs-type">BookMsg</span> &gt;&gt;&gt; emitter
                              pure state)
    # <span class="hljs-type">Loop</span>.info (\(<span class="hljs-type">BookMsg</span> msg) req state -&gt;  <span class="hljs-keyword">do</span>
          _ &lt;- streamBody (stringToBinary $ writeJSON msg) req
          pure $ <span class="hljs-type">LoopOk</span> req state)
    <span class="hljs-keyword">where</span>
          streamEvents = tuple2 <span class="hljs-string">"application/json"</span> (\req state -&gt; <span class="hljs-keyword">do</span>
                         req2 &lt;- streamReply (<span class="hljs-type">StatusCode</span> <span class="hljs-number">200</span>) <span class="hljs-type">Map</span>.empty req
                         <span class="hljs-type">Rest</span>.switchHandler <span class="hljs-type">LoopHandler</span> req2 state)
</code></pre>
<h1 id="straight-loop">Straight Loop</h1>
<pre><code class="language-haskell">
<span class="hljs-title">eventsFirehoseLoop</span> :: <span class="hljs-type">StetsonHandler</span> <span class="hljs-type">EventsWsMsg</span> {}
<span class="hljs-title">eventsFirehoseLoop</span> =
   <span class="hljs-type">Loop</span>.handler (\req -&gt; <span class="hljs-type">Loop</span>.initResult req {})
    # <span class="hljs-type">Loop</span>.init (\emitter req state -&gt; <span class="hljs-keyword">do</span>
                              _ &lt;- <span class="hljs-type">SimpleBus</span>.subscribe <span class="hljs-type">BookLibrary</span>.bus $ <span class="hljs-type">BookMsg</span> &gt;&gt;&gt; emitter
                              pure s{})
    # <span class="hljs-type">Loop</span>.info (\(<span class="hljs-type">BookMsg</span> msg) req s -&gt; <span class="hljs-keyword">do</span>
          _ &lt;- streamBody (stringToBinary $ writeJSON msg) req
          pure $ <span class="hljs-type">LoopOk</span> req s)
</code></pre>
<h1 id="websocket">WebSocket</h1>
<pre><code class="language-haskell">
<span class="hljs-title">eventsWs</span> :: <span class="hljs-type">StetsonHandler</span> <span class="hljs-type">EventsWsMsg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">eventsWs</span> =
  <span class="hljs-type">WebSocket</span>.handler (\req -&gt; <span class="hljs-type">WebSocket</span>.initResult req unit)
  # <span class="hljs-type">WebSocket</span>.init (\emitter req s -&gt;  <span class="hljs-keyword">do</span>
                              _ &lt;- <span class="hljs-type">SimpleBus</span>.subscribe <span class="hljs-type">BookLibrary</span>.bus $ <span class="hljs-type">BookMsg</span> &gt;&gt;&gt; emitter
                              pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">NoReply</span> s
                             )
  # <span class="hljs-type">WebSocket</span>.handle (\frame state -&gt; pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">NoReply</span> state)
  # <span class="hljs-type">WebSocket</span>.info (\(<span class="hljs-type">BookMsg</span> msg) state -&gt; pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">Reply</span> ((<span class="hljs-type">TextFrame</span> $ writeJSON msg) : nil) state)
</code></pre>
<p>Similarly to the <a href="/entries/purerl-updates---arbitrary-messages-and-handle_info-in-gen-servers.html">last post</a>, doing this as an emitter function made sense on first pass, but this was swiftly replaced with a plain ol&#39; pid because it played nicer with monitors, existing APIs, etc.</p>
<h1 id="passing-in-a-pid-instead">Passing in a Pid instead</h1>
<pre><code class="language-haskell">
<span class="hljs-title">eventsWs</span> :: <span class="hljs-type">StetsonHandler</span> <span class="hljs-type">EventsWsMsg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">eventsWs</span> =
  <span class="hljs-type">WebSocket</span>.handler (\req -&gt; <span class="hljs-type">WebSocket</span>.initResult req unit)
  # <span class="hljs-type">WebSocket</span>.init (\self s -&gt;  <span class="hljs-keyword">do</span>
                              _ &lt;- <span class="hljs-type">SimpleBus</span>.subscribe <span class="hljs-type">BookLibrary</span>.bus $ <span class="hljs-type">BookMsg</span> &gt;&gt;&gt; send self
                              pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">NoReply</span> s
                             )
  # <span class="hljs-type">WebSocket</span>.handle (\frame state -&gt; pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">NoReply</span> state)
  # <span class="hljs-type">WebSocket</span>.info (\(<span class="hljs-type">BookMsg</span> msg) state -&gt; pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">Reply</span> ((<span class="hljs-type">TextFrame</span> $ writeJSON msg) : nil) state)
</code></pre>
<p>This all said, requiring this pid to be passed in as an argument is quite awkward, having to stash it in state if we want to access it from outside of our init function etc, once again StateT was employed so that the API for Stetson and Pinto would be aligned.</p>
<pre><code class="language-haskell">
<span class="hljs-title">eventsWs</span> :: <span class="hljs-type">StetsonHandler</span> <span class="hljs-type">EventsWsMsg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">eventsWs</span> =
  <span class="hljs-type">WebSocket</span>.handler (\req -&gt; <span class="hljs-type">WebSocket</span>.initResult req unit)
  # <span class="hljs-type">WebSocket</span>.init (\req s -&gt;  <span class="hljs-keyword">do</span>
                              self &lt;- <span class="hljs-type">WebSocket</span>.self
                              _ &lt;- <span class="hljs-type">WebSocket</span>.lift $ <span class="hljs-type">SimpleBus</span>.subscribe <span class="hljs-type">BookLibrary</span>.bus $ <span class="hljs-type">BookMsg</span> &gt;&gt;&gt; send emitter
                              pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">NoReply</span> s
                             )
  # <span class="hljs-type">WebSocket</span>.handle (\frame state -&gt; pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">NoReply</span> state)
  # <span class="hljs-type">WebSocket</span>.info (\(<span class="hljs-type">BookMsg</span> msg) state -&gt; pure $ <span class="hljs-type">Stetson</span>.<span class="hljs-type">Reply</span> ((<span class="hljs-type">TextFrame</span> $ writeJSON msg) : nil) state)
</code></pre>
<p>This then allows Stetson to stash internal state in the underlying implementation and surface an API over this; indeed there is no way of accidentally calling the wrong &#39;self&#39; and sending messages to the wrong process much like in Pinto. Every callback takes place within a typed  context that enforces what &#39;state&#39; and &#39;msg&#39; are - pretty neat.</p>
]]></description><link>http://codeofrob.com/entries/purerl-updates---arbitrary-messages-and-stetson-handlers.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl-updates---arbitrary-messages-and-stetson-handlers.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 07 Jul 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purerl Updates - Arbitrary messages and handle_info in gen servers]]></title><description><![CDATA[<p>A continuation of progress updates on Pinto/Stetson then..  </p>
<h1 id="previous-purerl-posts">Previous Purerl posts</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="updates">Updates</h1>
<ul>
<li><a href="/entries/updates-to-pinto+stetson---purerl-in-progress.html">Nix overlays for Purerl/etc</a></li>
<li><a href="/entries/purerl-updates---typed-routes-in-stetson.html">Typed routing for Stetson</a></li>
<li>Arbitrary messages and handle_info in gen_servers</li>
<li>Monitors for arbitrary pids from Gen servers + Stetson handlers</li>
<li>WebSocket handlers in Stetson</li>
<li>Streaming handlers in Stetson</li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<h1 id="the-story-so-far">The story so far</h1>
<p>The code for dealing with handle_info was very hand-wavey and involved the creation and registration of mappers and receivers within the gen server itself. This also ended up abusing gen_server:cast in order to function correctly and it wasn&#39;t really obvious where messages were coming from. It was a ticking time bomb as far as supporting the increasing amounts of code we are writing in Purescript goes.</p>
<p>There was <em>some</em> good in this approach, in that the type of the Gen Server specified both the State of the Gen Server and the type of the Msg it would receive, and the handleInfo function could  be supplied  in Gen.init, forcibly typed with this server name.</p>
<pre><code class="language-haskell">
  <span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">Tick</span> | <span class="hljs-type">SomethingHappened</span> <span class="hljs-type">String</span></span>

  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = { 
      <span class="hljs-comment">-- some stuff </span>
  }</span>

  serverName :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
  serverName = <span class="hljs-type">Local</span> $ atom <span class="hljs-string">"my_server"</span>

  startLink :: <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
  startLink = <span class="hljs-type">Gen</span>.startLink init handleInfo

  init :: <span class="hljs-type">Effect</span> <span class="hljs-type">State</span> 
  init = <span class="hljs-keyword">do</span>
    <span class="hljs-type">SomethingElse</span>.registerForEvents serverName <span class="hljs-type">SomethingHappened</span>
    pure {}


  handleInfo :: <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">CastResult</span> <span class="hljs-type">State</span>)
  handleInfo msg = <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
      <span class="hljs-type">Tick</span> -&gt; doTIck
      <span class="hljs-type">SomethingHappened</span> id -&gt; handleSomething id

</code></pre>
<p>Having to provide serverName as part of the registration function is clunky AF, under the hood this places the responsibility of mapping messages to the external module and  there is a disconnect between <em>that</em> and the handleInfo we supplied  as part of startLink. </p>
<h1 id="a-first-pass-emitter-functions">A first pass, emitter functions</h1>
<p>The code was changed so that an emitter function would be extractable from within a gen server, this would be typed around ServerName automatically and only the right type of messages would be capable of being passed into it.</p>
<pre><code class="language-haskell">
<span class="hljs-title">init</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">State</span> = <span class="hljs-keyword">do</span>
<span class="hljs-title">init</span> = <span class="hljs-keyword">do</span>
    emitter &lt;- <span class="hljs-type">Gen</span>.emitter serverName
    <span class="hljs-type">SomethingElse</span>.registerForEvents $ emitter &lt;&lt;&lt; <span class="hljs-type">SomethingHappened</span>
    pure {}
</code></pre>
<p>This is somewhat an improvement, as it could at this point be assumed that anything passed into that function would automatically be the right type for handle_info and the mapping code from inside the gen server could be removed entirely. It requires the use of proxy processes to intercept messages, and I spent a day or two upgrading nearly all of our company Purescript over to this new model because it felt good.</p>
<p>It didn&#39;t feel <em>great</em> after doing that though, once again we&#39;re relying on convention to create that emitter with the right &#39;serverName&#39; and it&#39;s not very &#39;Erlang&#39;, in theory it also means that code could be written to send messages to arbitrary gen servers providing you have access to the serverName and thats a bit naff.</p>
<h1 id="second-pass-making-it-more-erlang">Second pass, making it more Erlang</h1>
<p>The type of &#39;emitter&#39; was changed to <em>Process Msg</em> (A welcome suggestion from <a href="@louispilfold">http://twitter.com/louispilfold</a> when I was putting code samples out for feedback). This maps under the hood to a new type of a plain ol&#39; pid and is therefore compatible automatically with classic Erlang APIs. (Specifically erlang monitors and such being a useful end-goal here).</p>
<pre><code class="language-haskell">
<span class="hljs-title">init</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">State</span> = <span class="hljs-keyword">do</span>
<span class="hljs-title">init</span> = <span class="hljs-keyword">do</span>
    self &lt;- <span class="hljs-type">Gen</span>.self serverName
    self ! <span class="hljs-type">DoSomeStuffAfterStartup</span>
    <span class="hljs-type">SomethingElse</span>.registerForEvents $ send self &lt;&lt;&lt; <span class="hljs-type">SomethingHappened</span>
    pure {}
</code></pre>
<p>This was still not ideal however, the call to Gen.self included a runtime check (below) to ensure that the caller was indeed the &quot;self&quot; we were looking at to prevent external clients from abusing the API (if you provide an API, it <em>will</em> be abused and I&#39;d already seen some &quot;interesting&quot; code already written around these APIs while I was upgrading just our own code!)</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">selfImpl</span><span class="hljs-params">(Name)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
    Pid  = where_is_name(Name),
    Self = erlang:self(),
    <span class="hljs-keyword">if</span>
      Self =:= Pid -&gt; Self;
      <span class="hljs-literal">true</span> -&gt;
        exit(Self, {error, &lt;&lt;<span class="hljs-string">"Gen.self was called from an external process, this is not allowed"</span>&gt;&gt;})
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>.

</code></pre>
<h1 id="third-pass-making-it-more-purescript">Third pass, making it more Purescript</h1>
<p>Sod it, StateT it is. We&#39;d been discussing moving the Gen callbacks into a state monad since I first wrote Pinto, the only obstacle being that I didn&#39;t understand state monads, which sounds stupid on retrospect but it&#39;s the truth <em>shrug</em>. I read a few tutorials, had a mild &quot;aha&quot; moment and things became a bit clearer.</p>
<p>What we really want is that all the callbacks to automatically</p>
<ul>
<li>Be typed around ServerName, so that all calls to Pinto APIs automatically assume this type</li>
<li>have access to the &#39;internal&#39; state in the Pinto gen_server implementation, so no casts ever have to be made again</li>
</ul>
<p>We had quite a bit of code in Gen.purs (our gen server wrapper) that relied on making casts to modify its state, monitors and such - removing all of this was just a sensible idea -  the idea being that if the callbacks to client coded operated within the context of that state, it could be retrieved and modified (optionally) as part of those callbacks.</p>
<pre><code class="language-haskell">
<span class="hljs-title">startLink</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> = <span class="hljs-type">Gen</span>.startLink init handleInfo

<span class="hljs-title">init</span> :: <span class="hljs-type">Gen</span>.<span class="hljs-type">Init</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">init</span> = 
  self &lt;- <span class="hljs-type">Gen</span>.self
  <span class="hljs-type">Gen</span>.lift $ <span class="hljs-type">SomethingElse</span>.registerForEvents $ send self  &lt;&lt;&lt; <span class="hljs-type">SomethingHappened</span>
  pure {}

<span class="hljs-title">handleInfo</span> :: <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">HandleInfo</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">handleInfo</span> msg state =
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
    <span class="hljs-type">Tick</span> -&gt; <span class="hljs-type">CastNoReply</span> &lt;$&gt; handleTick state
    <span class="hljs-type">SomethingHappened</span> ev -&gt; <span class="hljs-type">CastNoReply</span> &lt;$&gt; handleSomethingHappened ev state

</code></pre>
<p>On the surface of this it isn&#39;t that different, but we&#39;ve done away with the need to constantly refer to &#39;serverName&#39; because we&#39;re operating in the context of a state monad (Gen.Init and Gen.HandleInfo are type aliass to help refer to the fairly wordy type used behind the scenes in Pinto).</p>
<p>Gen.self doesn&#39;t need to do anything other than pull state out of that state monad and return it to the client code (implementation below), this means that unless your code is being executed in the context of the state monad (IE: the gen server) you can&#39;t call it and the runtime checks and side effects can go away.</p>
<pre><code class="language-haskell">
  self :: <span class="hljs-keyword">forall</span> state msg. <span class="hljs-type">StateT</span> (<span class="hljs-type">GenContext</span> state msg) <span class="hljs-type">Effect</span> (<span class="hljs-type">Process</span> msg)
  self = <span class="hljs-keyword">do</span>
    <span class="hljs-type">GenContext</span> { pid } &lt;- <span class="hljs-type">State</span>.get
    pure pid
</code></pre>
<p>Similarly, Gen.Cast and Gen.Call are provided for <em>those</em> callbacks too, and all code executed  within the context of a Pinto Genserver has access to the internal state via the API so in theory things like trapExit/handleInfo/config can be modified safely from within that context without doing weird things around async casts back to that gen server.</p>
<p>That&#39;s a lot of words to say that Gen Servers and arbitrary messages are now very pretty indeed in Purerl. Example below of a gen server subscribing to a message bus from the <a href="https://github.com/id3as/demo-ps/blob/master/server/src/HandleInfoExample.purs">demo_ps</a> web project. You&#39;ll note that the actual API used in startLink has evolved to include a builder for setting the initial handlers/etc - there are a number of optional things to tweak about a gen server and it made sense to do this rather than accept an endlessly growing list of arguments.</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">BookWatchingStartArgs</span> = {}</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = {}</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">BookMsg</span> <span class="hljs-type">BookEvent</span> </span>

<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">Local</span> $ atom <span class="hljs-string">"handle_info_example"</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookWatchingStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.buildStartLink serverName (init args) $ <span class="hljs-type">Gen</span>.defaultStartLink { handleInfo = handleInfo }

<span class="hljs-title">init</span> :: <span class="hljs-type">BookWatchingStartArgs</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">Init</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  self &lt;- <span class="hljs-type">Gen</span>.self
  _ &lt;- <span class="hljs-type">Gen</span>.lift $ <span class="hljs-type">SimpleBus</span>.subscribe <span class="hljs-type">BookLibrary</span>.bus $ <span class="hljs-type">BookMsg</span> &gt;&gt;&gt; send self
  pure $ {}

<span class="hljs-title">handleInfo</span> :: <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">HandleInfo</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">handleInfo</span> msg state = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
    <span class="hljs-type">BookMsg</span> bookEvent -&gt; 
      <span class="hljs-type">Gen</span>.lift $ handleBookEvent bookEvent state

<span class="hljs-title">handleBookEvent</span> :: <span class="hljs-type">BookEvent</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">CastResult</span> <span class="hljs-type">State</span>)
<span class="hljs-title">handleBookEvent</span> ev state =
  <span class="hljs-keyword">case</span> ev <span class="hljs-keyword">of</span>
    <span class="hljs-type">BookCreated</span> isbn -&gt; <span class="hljs-keyword">do</span>
      _ &lt;- <span class="hljs-type">Logger</span>.info1 <span class="hljs-string">"Book created ~p"</span> isbn
      pure $ <span class="hljs-type">CastNoReply</span> state
    <span class="hljs-type">BookDeleted</span> isbn -&gt; <span class="hljs-keyword">do</span>
      _ &lt;- <span class="hljs-type">Logger</span>.info1 <span class="hljs-string">"Book deleted ~p"</span> isbn
      pure $ <span class="hljs-type">CastNoReply</span> state
    <span class="hljs-type">BookUpdated</span> isbn -&gt; <span class="hljs-keyword">do</span>
      _ &lt;- <span class="hljs-type">Logger</span>.info1 <span class="hljs-string">"Book updated ~p"</span> isbn
      pure $ <span class="hljs-type">CastNoReply</span> state
</code></pre>
<p>I&#39;ll insert another item to the list of &#39;new things&#39; to the bullet points currently being traversed as my next post will be about the corresponding message handling implementation in <a href="https://github.com/id3as/purescript-erl-stetson">Stetson</a>, which unsurprisingly uses the State monad to improve our lives there as well. Once you learn how to use a hammer, everything looks like a nail I guess.</p>
]]></description><link>http://codeofrob.com/entries/purerl-updates---arbitrary-messages-and-handle_info-in-gen-servers.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl-updates---arbitrary-messages-and-handle_info-in-gen-servers.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 02 Jul 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purerl updates - Typed routes in Stetson]]></title><description><![CDATA[<p>A continuation of progress updates on Pinto/Stetson then..</p>
<h1 id="previous-purerl-posts">Previous Purerl posts</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="updates">Updates</h1>
<ul>
<li><a href="/entries/updates-to-pinto+stetson---purerl-in-progress.html">Nix overlays for Purerl/etc</a></li>
<li>Typed routing for Stetson</li>
<li>Emitter based messages for handle_info in Gen Server</li>
<li>Monitors for arbitrary pids from Gen servers + Stetson handlers</li>
<li>WebSocket handlers in Stetson</li>
<li>Streaming handlers in Stetson</li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<h1 id="how-it-was">How it was</h1>
<p>The initial blast of <a href="https://github.com/id3as/purescript-erl-stetson">Stetson</a> was thrown up around <a href="https://github.com/ninenines/cowboy">Cowboy</a> with the express goal of &quot;getting me started on our first client project written in Purerl&quot;. As such it wasn&#39;t fancy and routing/dispatch looked like this.</p>
<pre><code class="language-haskell">
<span class="hljs-type">Stetson</span>.configure
    # <span class="hljs-type">Stetson</span>.route <span class="hljs-string">"/api/books"</span> books
    # <span class="hljs-type">Stetson</span>.route <span class="hljs-string">"/api/books/:isbn"</span> book
    # <span class="hljs-type">Stetson</span>.static <span class="hljs-string">"/assets/[...]"</span> (<span class="hljs-type">PrivDir</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/assets"</span>)
    # <span class="hljs-type">Stetson</span>.static <span class="hljs-string">"/[...]"</span> (<span class="hljs-type">PrivFile</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/index.html"</span>)
</code></pre>
<p>Where a handler operating over  &#39;id&#39; to get a specific item might look like this</p>
<pre><code class="language-haskell">
<span class="hljs-title">book</span> :: <span class="hljs-type">StetsonHandler</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">book</span> = 
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-keyword">do</span>
                          <span class="hljs-keyword">let</span> id = binding (atom <span class="hljs-string">"isbn"</span>) req
                          book &lt;- maybe (pure <span class="hljs-type">Nothing</span>) <span class="hljs-type">BookLibrary</span>.findByIsbn id
                          <span class="hljs-type">Rest</span>.initResult req book)
    # <span class="hljs-type">Rest</span>.allowedMethods (\req state -&gt; <span class="hljs-type">Rest</span>.result (<span class="hljs-type">Stetson</span>.<span class="hljs-type">HEAD</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">PUT</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">DELETE</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">GET</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">OPTIONS</span> : nil) req state)
    # <span class="hljs-type">Rest</span>.resourceExists (\req state -&gt; 
                             <span class="hljs-type">Rest</span>.result (isJust state) 
                             (maybe (setBody <span class="hljs-string">"This book does not exist"</span> req) (\_ -&gt; req) state)
                             state)
    # <span class="hljs-type">Rest</span>.deleteResource (\req state -&gt; <span class="hljs-keyword">do</span>
                              _ &lt;- maybe (pure unit) (\book -&gt; <span class="hljs-type">BookLibrary</span>.delete book.isbn) state
                              <span class="hljs-type">Rest</span>.result true req state)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (jsonWriter : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesAccepted (\req state -&gt; <span class="hljs-type">Rest</span>.result ((tuple2 <span class="hljs-string">"application/json"</span> acceptJson) : nil) req state)
</code></pre>
<p>Urgh, so we&#39;ve got <em>:isbn</em> as a binding in our route, which we&#39;re pulling out as a <em>Maybe String</em> in our init handler, more hand waving here than at a Tory party conference. To compound matters, our client is building these urls like so</p>
<pre><code class="language-haskell">
<span class="hljs-title">getBook</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>
<span class="hljs-title">getBook</span> id = fetchJson <span class="hljs-string">"/api/books/"</span> &lt;&gt; id
</code></pre>
<p>This was fine for a year or so, but once you&#39;ve got a few real applications running on top of this stuff and a great many URLs indeed you start running into issues where typos, incorrect types, etc start rearing their head - especially if you&#39;re making changes. (Quiet down at the back if you mention rest, url discovery and client independence to me I&#39;ll throw something at you, this isn&#39;t that).</p>
<p>Thankfully, we have <a href="http://twitter.com/nwolverson">nwolverson</a> working with us and he&#39;s unafraid of the wonders of <a href="https://pursuit.purerl.fun/packages/typelevel-prelude/3.0.0/docs/Type.Data.Symbol">Data.Symbol.SProxy</a> and spent a chunk of time re-working <a href="https://github.com/natefaubion/purescript-routing-duplex">routing-duplex</a> from the client world so that it compiles/works/is-usable in the world of Purerl and Stetson.  Did I ever mention that the great thing about re-purposing an existing language/toolset for Erlang is that code already exists for most things you&#39;d want to do in that language? I&#39;ll mention it again here because it&#39;s pretty great.</p>
<p>Gone is the hand-waving, for our apps now have a shared module twixt client and server describing the routes available and the types they accept and no mistakes will be accepted by the compiler.</p>
<p><em>Our routes</em></p>
<p>Our routes exist as an ADT describing the various  options and the typed parameters they expect.</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Route</span></span>
  = <span class="hljs-type">Books</span>
  | <span class="hljs-type">Book</span> <span class="hljs-type">Isbn</span>
  | <span class="hljs-type">Assets</span> (<span class="hljs-type">Array</span> <span class="hljs-type">String</span>)
  | <span class="hljs-type">Index</span>
  | <span class="hljs-type">Index2</span> <span class="hljs-type">String</span> (<span class="hljs-type">Array</span> <span class="hljs-type">String</span>)
</code></pre>
<p><em>How the routes map to paths</em></p>
<p>Using the type RouteDuplex&#39; with this ADT, we are required  to fill out each of the options with a path with the args expected  in the ADT. None  of these  are optional and we&#39;ll get type errors (more on this in a bit) if we don&#39;t supply all of the args or routes expected.</p>
<pre><code>
-- | This combinator transforms <span class="hljs-literal">a</span> codec over `String` into one that operates on the `Isbn` type.
<span class="hljs-symbol">isbn ::</span> RouteDuplex' String -&gt; RouteDuplex' Isbn
isbn = asNewtype

<span class="hljs-symbol">apiRoute ::</span> RouteDuplex' Route
apiRoute = path <span class="hljs-string">""</span> $ sum
  { <span class="hljs-string">"Books"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"books"</span> / noArgs
  , <span class="hljs-string">"Book"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"books"</span> / isbn segment
  , <span class="hljs-string">"EventsWs"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"events"</span> / <span class="hljs-string">"ws"</span>
  , <span class="hljs-string">"EventsFirehose"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"events"</span> / <span class="hljs-string">"firehose"</span>
  , <span class="hljs-string">"Assets"</span> : <span class="hljs-string">"assets"</span> / rest
  , <span class="hljs-string">"Index"</span> : noArgs
  , <span class="hljs-string">"Index2"</span> : segment / rest
  }

</code></pre><p>Note that our Newtype &#39;isbn&#39; is an integrated part of both of these APIs, <em>Book</em> is a route that is available over <em>api/books/:isbn</em> where <em>:isbn</em> is of type <em>Isbn</em>. No messing around; yes it&#39;s just a newtype in this case, but there is nothing stopping us doing more elaborate parsing here into more complicated types. We can&#39;t accidentally miss any routes off, those strings are checked against the record at compile type thanks to the magic of SProxy and such.</p>
<p><em>On the server</em></p>
<p>Rather than try and make this stuff optional in Stetson, we decided to just lump it in as core code - why would you choose strings with more strings and hand waving when you&#39;ve got types at your disposal? We&#39;re not Javascript programmers after all - this means that these routes are accepted as a first class citizen in this world.</p>
<pre><code class="language-haskell">
<span class="hljs-title">_</span> &lt;- <span class="hljs-type">Stetson</span>.configure
    # <span class="hljs-type">Stetson</span>.routes
      <span class="hljs-type">Routes</span>.apiRoute {
          <span class="hljs-string">"Book"</span>: book
        , <span class="hljs-string">"Books"</span>: books
        , <span class="hljs-string">"EventsWs"</span>: eventsWs
        , <span class="hljs-string">"EventsFirehose"</span>: eventsFirehose
        , <span class="hljs-string">"Assets"</span>: <span class="hljs-type">PrivDir</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/assets"</span>
        , <span class="hljs-string">"Index"</span>: <span class="hljs-type">PrivFile</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/index.html"</span>
        , <span class="hljs-string">"Index2"</span>: (\(_ :: <span class="hljs-type">String</span>)  -&gt; <span class="hljs-type">PrivFile</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/index.html"</span>)
      }

</code></pre>
<p>We can see here that once again we are supplying a record with the names from the ADT and these are once again type-checked against that ADT so you can&#39;t miss any out or get the types wrong. What types you ask? Well this is the &#39;book&#39; handler from earlier. (If you&#39;re not familiar with Purescript you might see the strings in our record above and go &#39;whaaaaa??&#39;, don&#39;t worry about it; because of the ADT &#39;Route&#39; and the fact that our &#39;RoutingDuplex&#39; has that as a type parameter, these strings are checked at a compile time against that ADT - it&#39;s a neat feature that has great potential when API building.</p>
<pre><code class="language-haskell">

<span class="hljs-title">book</span> :: <span class="hljs-type">Isbn</span> -&gt; <span class="hljs-type">StetsonHandler</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">book</span> id =
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-keyword">do</span>
                          book &lt;- <span class="hljs-type">BookLibrary</span>.findByIsbn id
                          <span class="hljs-type">Rest</span>.initResult req book)
    # <span class="hljs-type">Rest</span>.allowedMethods (\req state -&gt; <span class="hljs-type">Rest</span>.result (<span class="hljs-type">Stetson</span>.<span class="hljs-type">HEAD</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">PUT</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">DELETE</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">GET</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">OPTIONS</span> : nil) req state)
    # <span class="hljs-type">Rest</span>.resourceExists (\req state -&gt;
                             <span class="hljs-type">Rest</span>.result (isJust state)
                             (maybe (setBody <span class="hljs-string">"This book does not exist"</span> req) (\_ -&gt; req) state)
                             state)
    # <span class="hljs-type">Rest</span>.deleteResource (\req state -&gt; <span class="hljs-keyword">do</span>
                              _ &lt;- maybe (pure unit) (\book -&gt; <span class="hljs-type">BookLibrary</span>.delete book.isbn) state
                              <span class="hljs-type">Rest</span>.result true req state)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (jsonWriter : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesAccepted (\req state -&gt; <span class="hljs-type">Rest</span>.result ((tuple2 <span class="hljs-string">"application/json"</span> acceptJson) : nil) req state)
</code></pre>
<p>Say what now? Because we define</p>
<pre><code class="language-haskell">
  | <span class="hljs-type">Book</span> <span class="hljs-type">Isbn</span>
</code></pre>
<p>in our Routes ADT, we have </p>
<pre><code class="language-haskell">
  , <span class="hljs-string">"Book"</span>: <span class="hljs-string">"api"</span> / <span class="hljs-string">"books"</span> / isbn segment
</code></pre>
<p>in our RouteDuplex definition, and we have</p>
<pre><code class="language-haskell">
  <span class="hljs-string">"Book"</span>: book
</code></pre>
<p>In our Stetson routes, the compiler knows that &#39;book&#39; needs to be a function that accepts an &#39;Isbn&#39; and returns a StetsonHandler. So what if I change the type of &#39;book&#39; to integer? to integer? to integer? to integer?</p>
<pre><code class="language-haskell">  book :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">StetsonHandler</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
  book id =</code></pre>
<pre><code><span class="hljs-builtin-name">Error</span> found:
<span class="hljs-keyword">in</span> module BookWeb
at src/BookWeb.purs:122:58 - 122:60 (line 122, column 58 - line 122, column 60)

  Could <span class="hljs-keyword">not</span> match<span class="hljs-built_in"> type
</span>
    Int

  with<span class="hljs-built_in"> type
</span>
    Isbn
</code></pre><p>hot damn yes, and what if I do a typo in my handlers?</p>
<pre><code class="language-haskell">
      <span class="hljs-type">Routes</span>.apiRoute {
          <span class="hljs-string">"B00k"</span>: book
        , <span class="hljs-string">"Books"</span>: books
        , <span class="hljs-string">"EventsWs"</span>: eventsWs
</code></pre>
<p>Well</p>
<pre><code>
  Could <span class="hljs-keyword">not</span> match<span class="hljs-built_in"> type
</span>
    ( <span class="hljs-string">"Book"</span> :: t0
    <span class="hljs-built_in">..</span>.
    | t1
    )

  with<span class="hljs-built_in"> type
</span>
    ( <span class="hljs-string">"Assets"</span> :: StaticAssetLocation
    , <span class="hljs-string">"B00k"</span> :: Isbn -&gt; StetsonHandler Unit (Maybe <span class="hljs-built_in">..</span>.)
</code></pre><p>You get the picture, by up-front defining the routes and the types they expect as input to the handler functions, we&#39;ve just done away with the handwaving and given ourselves a pile of safety.</p>
<p><em>On the client</em></p>
<p>Remember our <em>getBook :: String -&gt; Maybe Book</em>? </p>
<pre><code class="language-haskell">
<span class="hljs-title">routeUrl</span> :: <span class="hljs-type">Route</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">routeUrl</span> = <span class="hljs-type">RouteDuplex</span>.print apiRoute

<span class="hljs-title">getBook</span> :: <span class="hljs-type">Isbn</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>
<span class="hljs-title">getBook</span> id = fetchJson $ routeUrl (<span class="hljs-type">Book</span> id)
</code></pre>
<p>No more strings, no more guessing, thanks Nick!</p>
]]></description><link>http://codeofrob.com/entries/purerl-updates---typed-routes-in-stetson.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl-updates---typed-routes-in-stetson.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 30 Jun 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Updates to Pinto+Stetson - Purerl In Progress]]></title><description><![CDATA[<p>Whew, a lot of things have happened over the last year and nearly all of it in private Github repos for work as we carry on doing &quot;everything&quot; in Purerl.</p>
<p>These posts are a reminder of where we were last time we poked our heads over the parapet, although some of their content is now a tad out of date the demo code they link to is thankfully updated (I&#39;ve been busy).</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<p>So what has changed?  </p>
<ul>
<li>Nix overlays for Purerl/etc</li>
<li>Typed routing for Stetson</li>
<li>Emitter based messages for handle_info in Gen Server</li>
<li>Monitors for arbitrary pids from Gen servers + Stetson handlers</li>
<li>WebSocket handlers in Stetson</li>
<li>Streaming handlers in Stetson</li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<p>Some of these things existed in one form or another last year, indeed it is hard to write a substantial amount of Erlang without requiring them, however as we started building more and more critical functionality on top of Purerl, the warts in the existing implementations started becoming apparent and eventually needed dealing with.</p>
<p>The advantage to eating our own dog food is that we have a lot of mouths to feed and the dog food needs to taste good if we&#39;re to keep on going with it.</p>
<p>For those that are super keen, the updated demo code can be found <a href="https://github.com/id3as/demo-ps">here</a> for perusal, for those who want an explanation, the following blog posts will cover them, for now  I&#39;ll quickly cover the various nix packages that are available for us about the place and the tools we are currently using to do our builds.</p>
<h1 id="nix-packages--development-stack">Nix Packages + Development Stack</h1>
<p>The demo-ps project has been &#39;nixified&#39;, with a <a href="https://nixos.org/download.html">nix-shell</a> and <a href="https://direnv.net/">direnv</a> or similar, a fully operational development environment will appear (and yes it works on MacOS).</p>
<p>Our entry point can be found <a href="https://github.com/id3as/demo-ps/blob/master/env/common/shell.nix">here</a>, dumped below for convenience.</p>
<pre><code><span class="hljs-keyword">let</span>
  <span class="hljs-attr">erlangReleases</span> = <span class="hljs-built_in">builtins</span>.fetchTarball https://github.com/nixerl/nixpkgs-nixerl/archive/v1.<span class="hljs-number">0.4</span>-devel.tar.gz;

  <span class="hljs-attr">pinnedNix</span> =
    <span class="hljs-built_in">builtins</span>.fetchGit {
      <span class="hljs-attr">name</span> = <span class="hljs-string">"nixpkgs-pinned"</span>;
      <span class="hljs-attr">url</span> = <span class="hljs-string">"https://github.com/NixOS/nixpkgs.git"</span>;
      <span class="hljs-attr">rev</span> = <span class="hljs-string">"cc6cf0a96a627e678ffc996a8f9d1416200d6c81"</span>;
    };

  <span class="hljs-attr">pursPackages</span> =
    <span class="hljs-built_in">builtins</span>.fetchGit {
      <span class="hljs-attr">name</span> = <span class="hljs-string">"purerl-packages"</span>;
      <span class="hljs-attr">url</span> = <span class="hljs-string">"git@github.com:purerl/nixpkgs-purerl.git"</span>;
      <span class="hljs-attr">rev</span> = <span class="hljs-string">"5da0a433bcefe607e0bd182b79b220af980a4c78"</span>;
    };


  <span class="hljs-attr">nixpkgs</span> =
    <span class="hljs-built_in">import</span> pinnedNix {
      <span class="hljs-attr">overlays</span> = [
        (<span class="hljs-built_in">import</span> erlangReleases)
        (<span class="hljs-built_in">import</span> pursPackages)
        (<span class="hljs-built_in">import</span> ./.)
      ];
    };

  <span class="hljs-keyword">inherit</span> (nixpkgs.stdenv.lib) optionals;
  <span class="hljs-keyword">inherit</span> (nixpkgs)stdenv;
<span class="hljs-keyword">in</span>

<span class="hljs-keyword">with</span> nixpkgs;

mkShell {
  <span class="hljs-attr">buildInputs</span> = <span class="hljs-keyword">with</span> pkgs; [

    nixerl.erlang-<span class="hljs-number">22</span>-<span class="hljs-number">3</span>.erlang
    nixerl.erlang-<span class="hljs-number">22</span>-<span class="hljs-number">3</span>.rebar3

    purerl.purerl-<span class="hljs-number">0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">5</span>

    demo_ps.purescript-<span class="hljs-number">0</span>-<span class="hljs-number">13</span>-<span class="hljs-number">6</span>
    demo_ps.spago-<span class="hljs-number">0</span>-<span class="hljs-number">12</span>-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>
    demo_ps.dhall-json-<span class="hljs-number">1</span>-<span class="hljs-number">5</span>-<span class="hljs-number">0</span>
   ];
}</code></pre><p><a href="https://github.com/nixerl/nixpkgs-nixerl">nixerl/nixpkgs-nixerl</a> is maintained  by <a href="http://twitter.com/philipstears">@philipstears</a>, <a href="https://github.com/purerl/nixpkgs-purerl">purerl/nixpkgs-purerl</a> is maintained by the purerl org (<a href="http://twitter.com/nwolverson">nick</a>) - the demo-ps project itself  provides some  overlays for purescript/spago/dhall because we want specific versions of them.</p>
<p>I strongly recommend investigating Nix for development workflows based on the last year or so of using it in earnest as a team, we have built our own internal packages for native/shared dependencies across our projects and have started  looking into using it to aid in our deployment as well. It is not without its pain points (it&#39;s a lot easier if you just run Nixos like half the team), but it has made managing our dependencies a lot easier. As a way of getting a sensible Purerl development environment up and running it&#39;s probably the easiest avenue.</p>
<p>We&#39;ve pretty much set ourselves on using</p>
<ul>
<li>dhall-json for our package sets</li>
<li>Spago for building</li>
<li>Purescript is the main compiler</li>
<li>Purerl is the backend for the compiler</li>
<li>Rebar3 is the build engine for our Erlang projects</li>
<li>Erlang is the compiler/VM for... well, Erlang</li>
</ul>
<p>Getting all of these installed is probably a journey that is going to be differ wildly depending on the host OS and Nix at least gets that solved for us.</p>
<h1 id="dhall">Dhall</h1>
<p>There are two dhall files per Purescript project at the moment, there is packages.dhall which describes the package set we are using to pull packages, and then spago.dhall which describes which packaages from that package set we want to use.</p>
<p>At the time of writing, our package set looks like this</p>
<pre><code><span class="hljs-keyword">let</span> <span class="hljs-attr">upstream</span> = https://github.com/purerl/package-sets/releases/download/erl-<span class="hljs-number">0.13</span>.<span class="hljs-number">6</span>-<span class="hljs-number">20200402</span>/packages.dhall sha256:<span class="hljs-number">5442</span>e50aa76c20bd60b2770ab41c68bae80f6ec96f2df1cfaea310673de567d1

<span class="hljs-keyword">let</span> <span class="hljs-attr">overrides</span> =
      { <span class="hljs-attr">erl-cowboy</span> =
          { <span class="hljs-attr">dependencies</span> = [ <span class="hljs-string">"erl-modules"</span> ]
          , <span class="hljs-attr">repo</span> = <span class="hljs-string">"https://github.com/id3as/purescript-erl-cowboy.git"</span>
          , <span class="hljs-attr">version</span> = <span class="hljs-string">"4ee391f0349c00d92f68e4331425174eb8bdff9e"</span>
          },

      <span class="hljs-attr">erl-pinto</span> =
          { <span class="hljs-attr">dependencies</span> = [ <span class="hljs-string">"erl-process"</span> ]
          , <span class="hljs-attr">repo</span> = <span class="hljs-string">"ssh://git@github.com/id3as/purescript-erl-pinto.git"</span>
          , <span class="hljs-attr">version</span> = <span class="hljs-string">"59fd04bb0215f532b984909b3cd52bbaf1c10e6a"</span>
          },

      <span class="hljs-attr">erl-stetson</span> =
          { <span class="hljs-attr">dependencies</span> = [<span class="hljs-string">"erl-atom"</span> , <span class="hljs-string">"erl-binary"</span> , <span class="hljs-string">"erl-lists"</span> , <span class="hljs-string">"erl-maps"</span> , <span class="hljs-string">"erl-tuples"</span> , <span class="hljs-string">"erl-modules"</span> , <span class="hljs-string">"foreign"</span> , <span class="hljs-string">"maybe"</span> , <span class="hljs-string">"prelude"</span> , <span class="hljs-string">"transformers"</span> , <span class="hljs-string">"routing-duplex"</span>]
          , <span class="hljs-attr">repo</span> = <span class="hljs-string">"ssh://git@github.com/id3as/purescript-erl-stetson.git"</span>
          , <span class="hljs-attr">version</span> = <span class="hljs-string">"2244181d4905c16f7a62ead62a12a2056eb0c975"</span>
          }
      }

<span class="hljs-keyword">let</span> <span class="hljs-attr">extras</span> = {
       <span class="hljs-attr">erl-simplebus</span> =
          { <span class="hljs-attr">dependencies</span> =
              [ <span class="hljs-string">"erl-process"</span>
              , <span class="hljs-string">"effect"</span>
              ]
          , <span class="hljs-attr">repo</span> = <span class="hljs-string">"ssh://git@github.com/id3as/purescript-erl-simplebus.git"</span>
          , <span class="hljs-attr">version</span> = <span class="hljs-string">"14b5bd5971e7f2eeba99b51f1c6d4f43761b5376"</span>
          }
  }

<span class="hljs-keyword">in</span>  upstream  overrides extras
</code></pre><p><a href="https://github.com/id3as/purescript-erl-simplebus">erl-simplebus</a> is a new package not yet added to the <a href="https://github.com/purerl/package-sets">purerl package-sets</a> so that&#39;s been defined as an &#39;extra&#39;, and our cowboy/pinto/stetson repos are a moving target so we&#39;re using git commit hashes for them as the versions in the package set are out of date. In general our packages.dhall breath a little as we work on core libraries, stabilise changes and then get official releases pushed into the official package set.</p>
<p>With all of this defined, we can define our build package spago.dhall</p>
<pre><code>{-
-}
{ <span class="hljs-attr">name</span> = <span class="hljs-string">"demo"</span>
, <span class="hljs-attr">dependencies</span> =
    [ <span class="hljs-string">"console"</span>
    , <span class="hljs-string">"effect"</span>
    , <span class="hljs-string">"erl-cowboy"</span>
    , <span class="hljs-string">"erl-pinto"</span>
    , <span class="hljs-string">"erl-stetson"</span>
    , <span class="hljs-string">"psci-support"</span>
    , <span class="hljs-string">"simple-json"</span>
    , <span class="hljs-string">"erl-simplebus"</span>
    ]
, <span class="hljs-attr">packages</span> = ./packages.dhall
, <span class="hljs-attr">sources</span> = [ <span class="hljs-string">"src/**/*.purs"</span>, <span class="hljs-string">"test/**/*.purs"</span> ]
, <span class="hljs-attr">backend</span> = <span class="hljs-string">"purerl"</span>
}</code></pre><p>This allows us to use spago build on the CLI, which will pull down all of our packages and build them and our Erlang. Note the presence of &#39;backend&#39; for compiling to Erlang rather than JavaScript - this is a fairly recent change to the Purescript env and definitely differs from my previous blog posts on the subject (We&#39;ve done away with psc-package for starters).</p>
<h1 id="anyway">Anyway</h1>
<p>Look into Nix or install all the dependencies manually, I know which I&#39;d pick these days. Presumably it could be done in a docker container too, but docker is old hat, don&#39;t be old hat.</p>
]]></description><link>http://codeofrob.com/entries/updates-to-pinto+stetson---purerl-in-progress.html</link><guid isPermaLink="true">http://codeofrob.com/entries/updates-to-pinto+stetson---purerl-in-progress.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 25 Jun 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purerl - Some questions from #CodeMeshLdn]]></title><description><![CDATA[<p>Talk at CodeMesh now given, because of a demo god intervention (I discovered a Purerl compiler bug mid-demo, how&#39;s that for luck?) I didn&#39;t have time to receive questions during my actual session, but I kept a note of questions asked afterwards and will cover them here for those not present during their discussion.</p>
<p>I&#39;ll carry on linking these Purerl posts from each other before that however, &#39;cos it serves as a handy indexing mechanism in lieu of having a real blog engine..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
<li><a href="/entries/codemesh-2019---purerl-and-otp-talk.html">Codemesh 2019 - Purerl and OTP</a></li>
</ul>
<h1 id="useful-links">Useful links</h1>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<h1 id="some-questions-then">Some questions then.</h1>
<ul>
<li>What if I use the wrong types in my FFI</li>
<li>What if I don&#39;t use Effect in my FFI</li>
<li>How do you map complex union types back into Purerl when doing FFI (specifically, errors)</li>
<li>Are there any situations where you feel the types in Purescript would get in the way and you&#39;d just write Erlang instead?</li>
</ul>
<h1 id="wrong-types">Wrong types</h1>
<p>In one demo I did a very simple import of the base64 module from base Erlang:</p>
<pre><code class="language-erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(cool@foreign)</span>.

<span class="hljs-keyword">-export</span><span class="hljs-params">([base64/<span class="hljs-number">1</span>])</span>.

<span class="hljs-function"><span class="hljs-title">base64</span><span class="hljs-params">(String)</span> -&gt;</span> base64:encode(String).
</code></pre>
<p>Consumed in purescript with the following import</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> base64 :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
</code></pre>
<p>And all is right and proper, from the erlang shell, I can call this function</p>
<pre><code class="language-bash">Eshell V10.5  (abort with ^G)
1&gt; l(cool@ps).
{module,cool@ps}
2&gt; cool@ps:base64(&lt;&lt;<span class="hljs-string">"foo"</span>&gt;&gt;).
&lt;&lt;<span class="hljs-string">"Zm9v"</span>&gt;&gt;
3&gt;</code></pre>
<p>So.. what if we lie about the types at play here?</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> base64 :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Int</span>
</code></pre>
<p>Well, the result of calling the purescript function from Erlang isn&#39;t going to change because it doesn&#39;t care about types</p>
<pre><code class="language-bash">Eshell V10.5  (abort with ^G)
1&gt; l(cool@ps).
{module,cool@ps}
2&gt; cool@ps:base64(&lt;&lt;<span class="hljs-string">"foo"</span>&gt;&gt;).
&lt;&lt;<span class="hljs-string">"Zm9v"</span>&gt;&gt;
3&gt;</code></pre>
<p>How about using it in a purescript application?</p>
<pre><code class="language-haskell">
<span class="hljs-title">doSomething</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">doSomething</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> result = base64 <span class="hljs-string">"wow"</span>
  _ &lt;- <span class="hljs-type">Console</span>.log $ show result
  pure unit
</code></pre>
<pre><code class="language-bash">
&gt; (cool@ps:doSomething())().
** exception error: bad argument
     <span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span>  integer_to_binary/1
        called as integer_to_binary(&lt;&lt;<span class="hljs-string">"d293"</span>&gt;&gt;)
     <span class="hljs-keyword">in</span> call from data_show@foreign:showIntImpl/1 (output/Data.Show/data_show@foreign.erl, line 4)
     <span class="hljs-keyword">in</span> call from main@ps:<span class="hljs-string">'-doSomething/0-fun-0-'</span>/1 (/home/robashton/talks/purescript_beam/demo_2/src/Main.purs, line 19)
</code></pre>
<p>Passing the variable around in Purescript land, nothing cares - it is assumed that if you&#39;ve said something is a certain type, that it is that type and all type checking will be done on that basis - sooner or later, every bit of data will end up getting somewhere where it needs to be serialized whether for display, storage or transmission and that will involve passing the data into code that makes assumptions based on the type being passed in and you&#39;ll get a runtime crash.</p>
<p>So obviously the answer is &quot;don&#39;t do it&quot; - when building FFI, getting types correct is essential - definitely something worth testing.</p>
<h1 id="what-if-i-dont-use-effect-in-my-ffi">What if I don&#39;t use Effect in my FFI</h1>
<p>You maniac, why would you want to lie about side effects??! Well it turns out to not actually be a big deal, the main reason you&#39;re telling the type system about side effects is for your own benefit and if you choose to lie then at some point you will be hoisted on your own petard and we will all laugh at you. An example of places where this could happen is with legacy code and logging, I guess, probably, maybe.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-module</span><span class="hljs-params">(cool@foreign)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([ add/<span class="hljs-number">2</span> ])</span>.

<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(X,Y)</span> -&gt;</span>
  io:format(user, <span class="hljs-string">"WOW, I AM ADDING ~p and ~p"</span>, [ X, Y ]),
  X + Y.
</code></pre>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> add :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>

<span class="hljs-title">doSomething</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">doSomething</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> result = add <span class="hljs-number">5</span> <span class="hljs-number">6</span>
  _ &lt;- <span class="hljs-type">Console</span>.log $ show result
  pure unit
</code></pre>
<pre><code class="language-bash">8&gt; (main@ps:doSomething())().
WOW, I AM ADDING 5 and 611
unit</code></pre>
<p>Is this the future you want to be a part of? No I didn&#39;t think so - friends don&#39;t let friends write effectful code without declaring it as effectful.</p>
<h1 id="how-do-you-map-complex-union-types-back-into-purerl">How do you map complex union types back into Purerl </h1>
<p>Consider the <a href="http://erlang.org/documentation/doc-6.2/lib/kernel-3.0.3/doc/html/file.html#list_dir-1">read_dir API</a> in classic Erlang: </p>
<pre><code class="language-erlang">  list_dir(Dir) -&gt; {ok, Filenames} | {error, Reason}

  Types:

  Dir = name_all()
  Filenames = [filename()]
  Reason = posix()
         | badarg
         | {no_translation, Filename :: unicode:latin1_binary()}
</code></pre>
<p>There are some decisions to be made when writing code that exposes this API to the Purerl world, and none of them are <em>wrong</em> per se. The default position is usually &quot;Map the exact API across as it is, and if you don&#39;t like it then fix it by writing a somewhat more Purescripty wrapper&quot;.</p>
<p>So that would be.</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">module</span> Erl.File <span class="hljs-keyword">where</span>

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>Which means then passing in the constructors to the FFI so this can be constructed in Erlang without knowing about these types at the top level.</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> <span class="hljs-type">ListDir_</span> :: (<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">ListDirFailure</span>)  
                            -&gt; <span class="hljs-type">ListDirFailure</span> 
                            -&gt; (<span class="hljs-type">Binary</span> -&gt; <span class="hljs-type">ListDirFailure</span>) 
                            -&gt; <span class="hljs-type">ListDirFailure</span> -&gt; (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
                            -&gt; (<span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>)))
                            -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
<span class="hljs-title">listDir</span> = listDir_ <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">ListDirBadArg</span> <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Left</span> <span class="hljs-type">Right</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>Youch that&#39;s a mouthful, obviously we can make that a bit more legible with</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> <span class="hljs-type">ListDir_</span> :: (<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">ListDirFailure</span>)  
                            -&gt; <span class="hljs-type">ListDirFailure</span> 
                            -&gt; (<span class="hljs-type">Binary</span> -&gt; <span class="hljs-type">ListDirFailure</span>) 
                            -&gt; <span class="hljs-type">ListDirFailure</span> -&gt; <span class="hljs-type">ListDirResult</span>
                            -&gt; (<span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; <span class="hljs-type">ListDirResult</span>
                            -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">ListDirResult</span>

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
<span class="hljs-type">ListDir</span> = listDir_ <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">ListDirBadArg</span> <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Left</span> <span class="hljs-type">Right</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ListDirResult</span> = <span class="hljs-type">Either</span> <span class="hljs-type">ListDirResult</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>And the FFI then looks like</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">listDir_</span><span class="hljs-params">(ListDirPosixFailure, ListDirBadArg, NoTranslationError, Failure, Success, Dir)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
    <span class="hljs-keyword">case</span> file:list_dir(Dir) <span class="hljs-keyword">of</span>
      { ok, Filenames } -&gt; Success(Filenames);
      { error, { no_translation, Encoded } } -&gt; Failure(NoTranslationError(Encoded));
      { error, badarg } -&gt; Failure(ListDirBadArg);
      { error, Posix } -&gt; Failure(ListDirPosixFailure(Posix));
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>If you wanted a nicer API on top of this, let&#39;s call it &quot;CoolFileApi&quot; for example, you&#39;d then wrap <em>that</em> binding with something nicer - having at least type-safe-ified the original API in all of its glory, and then you&#39;re doing the work in Purescript rather than Erlang, I haven&#39;t ran this through a compiler so I probably got it a bit wrong but you&#39;ll get picture..</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> CoolFileApi <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Erl.File <span class="hljs-keyword">as</span> File
<span class="hljs-keyword">import</span> Data.Newtype (<span class="hljs-title">unwrap</span>, <span class="hljs-title">wrap</span>)

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Filepath</span> = <span class="hljs-type">Filepath</span> <span class="hljs-type">String</span></span>
<span class="hljs-title">derive</span> <span class="hljs-keyword">instance</span> ntFilepath :: <span class="hljs-type">Newtype</span> <span class="hljs-type">Filepath</span> _

<span class="hljs-type">ListDir</span> :: <span class="hljs-type">Filepath</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">CoolListDirFailureReason</span> (<span class="hljs-type">List</span> <span class="hljs-type">Filepath</span>))
<span class="hljs-type">ListDir</span> <span class="hljs-type">Filepath</span> = <span class="hljs-keyword">do</span>
  result &lt;- <span class="hljs-type">File</span>.<span class="hljs-type">ListDir</span> $ unwrap <span class="hljs-type">Filepath</span>
  pure $ either (<span class="hljs-type">Left</span> &lt;&lt;&lt; nativeFailureToShinyFailure) (<span class="hljs-type">Right</span> &lt;&lt;&lt; wrap)


<span class="hljs-title">nativeFailureToShinyFailure</span> :: <span class="hljs-type">File</span>.<span class="hljs-type">ListDirFailure</span> -&gt; <span class="hljs-type">CoolListDirFailureReason</span>
<span class="hljs-title">nativeFailureToShinyFailure</span> reason =
  <span class="hljs-keyword">case</span> reason <span class="hljs-keyword">of</span>
    <span class="hljs-type">ListDirBadArg</span> -&gt; <span class="hljs-type">CoolListDirBadArg</span>
    <span class="hljs-type">ListDirNoTranslation</span> filename -&gt; <span class="hljs-type">CoolListDirNoTranslation</span> filename
    <span class="hljs-type">ListDirPosixFailure</span> a -&gt; <span class="hljs-type">CoolListDirPosixFailure</span> (atomToCool a)

<span class="hljs-title">atomToCool</span>  :: <span class="hljs-type">Erl</span>.<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">CoolListDirPosixFailure</span>
<span class="hljs-title">atomToCool</span> a = 
  <span class="hljs-keyword">case</span> a <span class="hljs-keyword">of</span>
    (atom <span class="hljs-string">"eacces"</span>) -&gt; <span class="hljs-type">Eaccess</span>
    (atom <span class="hljs-string">"enoent"</span>) -&gt; <span class="hljs-type">Enoent</span>
    <span class="hljs-comment">--- etc</span>
</code></pre>
<p>Essentially getting rid of those arbitary atoms and Erlang data types and representing them as native Purerl data types. You <em>could</em> just write your binding directly in this way from the get-go, but it&#39;s considered polite to write the low level bindings as directly as possible to the original API because it saves on mental load (and doing as little work as possible in the Erlang code), the documentation for the original API is then applicable to the low level bindings too.</p>
<h1 id="arent-types-a-huge-pain-in-the-ass">Aren&#39;t types a huge pain in the ass?</h1>
<p>I mean that&#39;s what I heard for this question, and it&#39;s a bit of a loaded one - people that aren&#39;t used to working in a sensibly typed environment tend to look at the typed environment as being a form of burden, instead of an aid to help you write better code. Some of the conversation around this was about whether we&#39;d be re-writing some of our core functionality in Purescript, and whether that would even be desirable as the types might get in the way of productivity.</p>
<p>I think that actually there is a lot of desire internally for us to do our next re-write of our orchestration logic in Purerl for example, but because  we&#39;re in a different language with a different way of looking at the world, the API and even the design of that would probably not look anything like the original (and the same goes for our media workflow engine too). We&#39;re not afraid of re-writes, we write code  to be thrown away after all - but usually when doing a re-write of a module, you get to learn from the previous iterations and Do It Better this time - the pendulum of compensation from past mistakes slowly zeroes in around an ideal design and by version 3 or 4 you&#39;re laughing.</p>
<p>The main pain of having to do things differently is while there will be some lessons that can be passed into the rewrites into Purescript, a lot of the design decisions don&#39;t come through to the new world and you&#39;re essentially going back to version 1/2 again for that component. That&#39;ll be the pain that we&#39;ll go through but we&#39;ll come out the other side as better Purescript developers so we&#39;re not afraid of that.</p>
<p>I really can&#39;t see a point where I&#39;d say that types are going to get in the way of Just Getting Stuff Done, in my experience so far, the type system is just a more honest way of looking at effort, when you&#39;re working in a sloppy-typed environment you can pretend that it&#39;s really easy and fun and you&#39;re dead smart so it&#39;s okay, but you end up paying the cost in bugs and mistakes eventually - the upfront cost might not be there but you&#39;ve just shifted it elsewhere. Types also typically enable you to write better abstractions to lessen the load of repeated operations - you can be a lot more clever when the compiler has your back.</p>
<p>It&#39;s very hard to currently view what a typed version of some of our core IP would look like, but that&#39;s down to our inexperience rather than it being an impossible task; it&#39;ll come in time.</p>
<h1 id="anyway">Anyway</h1>
<p>That&#39;s some answers, if you have more questions about Purerl/Stetson/Pinto <a href="http://twitter.com/robashton">hit me up on Twitter</a> and I&#39;ll do my best to help..</p>
]]></description><link>http://codeofrob.com/entries/purerl---some-questions-from-codemeshldn.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl---some-questions-from-codemeshldn.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 07 Nov 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Codemesh 2019 - Purerl and OTP talk]]></title><description><![CDATA[<p>Just a note that I&#39;ll be appearing at <a href="https://www.codemesh.io/conferences/code-mesh-ldn/">Codemesh</a> on Thursday (11:25) to give a talk where I go over some of the stuff we&#39;ve been working on at <a href="https://www.id3as.com/home">Work</a>(tm) this year - with a focus on some of the implementation details and nitty gritty/etc.</p>
<p>I silently blogged some of this recently, basically showing off how we&#39;ve now got the ability to write OTP applications in Purescript these days, and indeed are. The posts are all linked below for the majority of folk who are sensible enough not to not subscribe to this sorry excuse for a blog.</p>
<p>Here is a sneaky peek as to what a gen server looks like in this world, tasty no?</p>
<pre><code class="language-haskell">
<span class="hljs-title">findByIsbn</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findByIsbn</span> isbn = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    result &lt;- <span class="hljs-type">Redis</span>.get (dbId isbn) connection
    pure $ <span class="hljs-type">CallReply</span> result state

<span class="hljs-title">findAll</span> :: <span class="hljs-type">Effect</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findAll</span> = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    books &lt;- <span class="hljs-type">Redis</span>.findAll dbPrefix connection
    pure $ <span class="hljs-type">CallReply</span> books state

<span class="hljs-comment">-- Nothing special about this, just a function that returns a certain type</span>
<span class="hljs-comment">-- We can supply arbitrary arguments to this via the gensup</span>
<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.startLink serverName $ init args

<span class="hljs-comment">-- And those arguments can then end up in here, which just needs to return an effect of our State type</span>
<span class="hljs-title">init</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  connection &lt;- <span class="hljs-type">Redis</span>.open args.connectionString
  pure $ { connection }
</code></pre>
<h1 id="the-blog-entries">The blog entries</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="useful-links">Useful links</h1>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
]]></description><link>http://codeofrob.com/entries/codemesh-2019---purerl-and-otp-talk.html</link><guid isPermaLink="true">http://codeofrob.com/entries/codemesh-2019---purerl-and-otp-talk.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 05 Nov 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purescript interop with native Erlang - Interacting with Redis]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<p>We&#39;ve handwaved over the contents of the <a href="https://github.com/id3as/demo-ps/blob/master/server/src/Native/Redis.purs">Redis</a> module so far in the demo app, showing only that we can use it from our <a href="https://github.com/id3as/demo-ps/blob/master/server/src/BookLibrary.purs">BookLibrary.purs</a> like any other module as follows.</p>
<pre><code class="language-haskell">
<span class="hljs-title">update</span> :: <span class="hljs-type">Book</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">String</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">update</span> book =
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-type">Redis</span>.put (dbId book.isbn) book connection
    pure $ <span class="hljs-type">CallReply</span> (<span class="hljs-type">Right</span> book) state
</code></pre>
<p>That&#39;s pretty tidy, so let&#39;s look at the type of that function so we understand the Purescript side of things first and foremost</p>
<pre><code class="language-haskell">
<span class="hljs-title">put</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">DbId</span> -&gt; a -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
</code></pre>
<p>For any type &#39;a&#39; that implements WriteForeign, we&#39;re a function that takes a DbId, an A and a RedisConnection to produce an Effect of type Unit - this pretty much makes sense on the surface, DbId is just a newtype around String, and given a Key and a Value (which we can get from calling writeJSON on our type &#39;a&#39;), we can dump stuff in Redis - but how?</p>
<p>Let&#39;s take a step back a moment and approach this from the <em>other</em> end.</p>
<p>There is an application for accessing Redis in Erlang, called <a href="https://github.com/wooga/eredis">eredis</a> imaginatively enough, the usage of which looks a little like this.</p>
<pre><code class="language-erlang">
   { ok, C } = eredis:start_link(ConnectionString),

   eredis:q(C, [ &lt;&lt;<span class="hljs-string">"SET"</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">"key"</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">"value"</span>&gt;&gt; ]).
</code></pre>
<p>So what we want to do is surface this meaningfully to Purescript is define some foreign imports in our <em>Redis.purs</em>, which map onto their native counterparts in our <em>Redis.erl.</em></p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">ConnectionString</span> :: <span class="hljs-type">Type</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">RedisConnection</span> :: <span class="hljs-type">Type</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> open :: <span class="hljs-type">ConnectionString</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">RedisConnection</span>
</code></pre>
<p>By importing a foreign type, we&#39;re saying to Purescript &quot;Hey, this thing exists in Erlang but we don&#39;t know what is inside it, but we want to model it as something we can pass around thanks&quot;, the ConnectionString comes from sys.config and the RedisConnection is actually a Pid but we don&#39;t need to know that.</p>
<p>By importing a foreign function, we&#39;re saying that there is a function in Erlang with this name and signature and we&#39;d like to call it from Purescript. The &quot;open&quot; function we&#39;re importing from Erlang takes one of those ConnectionStrings and produces an Effect of type RedisConnection.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(ConnectionString)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, C } = eredis:start_link(ConnectionString),
      C
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>We wrap our actual functionality in a function, because that&#39;s how an Effect is modelled in Purerl, and we can return our &#39;Connection&#39; as an opaque type to Purescript when this Effect is processed. I&#39;ve made the decision here to match directly on <em>{ ok, C }</em> which means we&#39;ll crash at runtime if we can&#39;t open a connection - an alternative API could look like this.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">open_</span><span class="hljs-params">(ConnectionString, Just, Nothing)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, C } = <span class="hljs-keyword">case</span> eredis:start_link(ConnectionString) <span class="hljs-keyword">of</span>
                    { ok, C } -&gt; Just(C);
                    _ -&gt; Nothing
                    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>where</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> open_ :: <span class="hljs-type">ConnectionString</span> -&gt; (<span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>) -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>  -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>)

<span class="hljs-title">open</span> :: <span class="hljs-type">ConnectionString</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">RedisConnection</span>
<span class="hljs-title">open</span> connectionString = open_ connectionString <span class="hljs-type">Just</span> <span class="hljs-type">Nothing</span>
</code></pre>
<p>I&#39;ve chosen to &quot;let it crash&quot;, as that fits with how I&#39;d build the supervsion tree in Erlang around this (Restart periodically every 30s until the connection works please), but either approach is valid and not one I have strong opinions on at this time. (an Either with the failure reason would also be an option).</p>
<p>Anyway, going back to that <em>put</em> function with all of this in mind, we want to keep the Erlang pretty minimal, so some transformation on the Purescript side will be required. </p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> put_ :: <span class="hljs-type">DbId</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>

<span class="hljs-title">put</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">DbId</span> -&gt; a -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">put</span> id obj conn =
  put_ id (writeJSON obj) conn
</code></pre>
<p>Purescript knows how to turn our obj into JSON so we&#39;ll do that there, and then use a foreign function that takes just the primitive objects for use within Erlang with eredis.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-define</span><span class="hljs-params">(SET(Key, Value)</span>, [ &lt;&lt;"SET"&gt;&gt;, Key, Value ]).

<span class="hljs-function"><span class="hljs-title">put_</span><span class="hljs-params">(Id, Data, Pid)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, &lt;&lt;<span class="hljs-string">"OK"</span>&gt;&gt;} = eredis:q(Pid, ?SET(Id, Data)),
      ok
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>Now, this is not necessarily how we should approach building an FFI for a native library, as we&#39;re making some decisions in Erlang that could be made in Purescript, a more traditional FFI would look like this.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">q</span><span class="hljs-params">(Pid, Operation)</span> -&gt;</span>
  eredis:q(Pid, Operation).
</code></pre>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> q :: <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">Binary</span>)
</code></pre>
<p>And then we could build the API we <em>actually</em> want on top of <em>that</em> instead - I&#39;ve rather skipped that step in my demo for clarity, but if I was producing a library wrapper for publication that&#39;s probably the approach I&#39;d take, as unwieldy as it is to actually use it means we end up writing more Purescript and less Erlang.</p>
<p>This is the approach that erl-cowboy and Stetson took, whereas erl-pinto takes the direct approach to &quot;desired API&quot;, making the concession that it&#39;ll be easier to build without 1-1 FFI in existence. Either way, it&#39;s pretty easy to call into existing code in Erlang.</p>
<h1 id="next-up">Next up</h1>
<p>We&#39;ve pretty much covered the surface area of the demo project, so I&#39;ll be going off on a little journey talking about some of the common things that we like to do in Erlang and how to get that behaviour into Purerl, if I get any questions about these posts I&#39;ll follow up with answers in blog format also.</p>
]]></description><link>http://codeofrob.com/entries/purescript-interop-with-native-erlang---interacting-with-redis.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purescript-interop-with-native-erlang---interacting-with-redis.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 29 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Shared code twixt Purescript server and client]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<p>We&#39;ve got a basic model representing our &#39;book&#39;</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">module</span> Books <span class="hljs-keyword">where</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Book</span> = { <span class="hljs-title">isbn</span> :: <span class="hljs-type">String</span>
            , <span class="hljs-title">title</span> :: <span class="hljs-type">String</span>
            , <span class="hljs-title">author</span> :: <span class="hljs-type">String</span>
            }</span>
</code></pre>
<p>Which is pretty terribly exciting - the key thing to note here is that this is a plain ol&#39; record containing primitive types - this makes it pretty shareable as far as view models go (Let&#39;s ignore that we&#39;re using it for persistence here, demo code gonna demo code).</p>
<p>We&#39;ve shoved Books.purs into a folder called &#39;shared&#39; which has been softlinked from both the client and server directories, which means it will be separately compiled into JS And Purescript respectively.</p>
<p>There is a great library over in Purescript world called <a href="https://github.com/justinwoo/purescript-simple-json">simple-json</a> which defines a <em>ReadForeign</em> and <em>WriteForeign</em> for these basic types, which means that the functions readJSON and writeJSON will do the back and forth between JSON and the Purescript types.</p>
<p>There is also (thanks to the efforts of <a href="https://github.com/purerl/purescript-simple-json">@nwolverson</a>, a port of this library exists on the Purerl side of things which works in exactly the same way, using <a href="https://github.com/talentdeficit/jsx">JSX</a> under the hood. This is a fairly common pattern across the Purerl world, and you&#39;ll see when browsing the org repos that a lot of the code from the JS Purescript world has been ported across with minimal changes so that the two worlds look as alike as possible.</p>
<p>So, in the previous post we loaded a list of Books out of our genserver in Cowboy and simply called writeJSON on it.</p>
<pre><code class="language-haskell">
<span class="hljs-meta"># Rest.contentTypesProvided (\req state -&gt; Rest.result (jsonWriter : nil) req state)</span>

<span class="hljs-title">jsonWriter</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">Tuple2</span> <span class="hljs-type">String</span> (<span class="hljs-type">Req</span> -&gt; a -&gt; (<span class="hljs-type">Effect</span> (<span class="hljs-type">RestResult</span> <span class="hljs-type">String</span> a)))
<span class="hljs-title">jsonWriter</span> = tuple2 <span class="hljs-string">"application/json"</span> (\req state -&gt; <span class="hljs-type">Rest</span>.result (writeJSON state) req state)
</code></pre>
<p>If we open up the client code, we can see</p>
<pre><code class="language-haskell">
<span class="hljs-title">maybeBook</span> &lt;- <span class="hljs-type">H</span>.liftAff $ loadItem $ <span class="hljs-string">"/api/books/"</span> &lt;&gt; isbn

<span class="hljs-comment">-- where</span>

<span class="hljs-title">loadItem</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">ReadForeign</span> a =&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Aff</span> (<span class="hljs-type">Either</span> <span class="hljs-type">String</span> a)
<span class="hljs-title">loadItem</span> uri = <span class="hljs-keyword">do</span>
  response &lt;- <span class="hljs-type">AX</span>.get <span class="hljs-type">AXResponse</span>.string uri
  <span class="hljs-keyword">case</span> response.body <span class="hljs-keyword">of</span>
     <span class="hljs-type">Left</span> err -&gt; pure $ <span class="hljs-type">Left</span> <span class="hljs-string">"No"</span>
     <span class="hljs-type">Right</span> json -&gt; pure $ bimap show identity $ readJSON json
</code></pre>
<p>That is all that is required to shift data between the server Purescript and the client Purescript which is pretty tidy indeed! Because we&#39;re using the same library, any custom implementations of <em>ReadForeign</em> and <em>WriteForeign</em> we might choose to write can then also be shared between the two.</p>
<p>Obviously sharing code between both client and server is something that should be entered into with caution, typically sharing a lot of business logic is the sign of a problem - but I can easily see us ending up in a world where we can start using Halogen on the server-side to pre-render HTML for serving to the client much in the same way that the ReactJS community have started doing similar with NodeJS.</p>
<h1 id="next-up">Next up</h1>
<p>We&#39;ll look at our bindings to Redis, to get a feel for what interop with &quot;native&quot; Erlang with FFI looks like.</p>
]]></description><link>http://codeofrob.com/entries/shared-code-twixt-purescript-server-and-client.html</link><guid isPermaLink="true">http://codeofrob.com/entries/shared-code-twixt-purescript-server-and-client.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 27 Aug 2019 09:30:00 GMT</pubDate></item></channel></rss>