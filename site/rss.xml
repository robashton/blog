<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>NodeJS RSS Module</generator><lastBuildDate>Wed, 24 Apr 2013 07:30:08 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[OMeta OData ODear - polishing it off]]></title><description><![CDATA[<p>Now I've gotten most of this work done, I left a few pieces of work outstanding and after review, I can make some of the OMeta cleaner and nicer. I also need to be a bit better about interpreting the various primitives in OData.</p>

<p>I've also got a more <a href="https://github.com/Page-/">qualified person</a> to review my OMeta as I go along and give me feedback on my work, so this is where I integrate a lot of that.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
<li><a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic operator support in OData</a></li>
<li><a href="/entries/precedence-grouping,-you-first..-no-you-odata-parser.html">Precedence grouping in OData</a></li>
<li><a href="/entries/parsing-those-pesky-filtering-functions-in-odata.html">Filter query methods in OData</a></li>
<li><a href="/entries/the-final-odata-query-bits,-yes-were-nearly-there.html">The rest of OData</a></li>
</ul>

<h2>OMeta</h2>

<p><strong>Un-needed semantic actions</strong></p>

<p>In a few places in my OMeta I have expressions that look like this:</p>

<pre><code>(
  seq("allpages") -&gt; "allpages"
| seq("none") -&gt; "none"
)
</code></pre>

<p>This is quite wasteful and can be written much more simply as </p>

<pre><code>(
  seq("allpages") 
| seq("none")
)
</code></pre>

<p>This is because by default the last expression will be returned anyway</p>

<p>The same goes for this (ignoring that the Text primitive still needs some work)</p>

<pre><code>Text =
  &lt;    (   ~'\''
      (    '\\' anything
      |    letter
      )
    )*
  &gt;:text
  -&gt; text
</code></pre>

<p>Is much tidier if we get rid of the un-need semantic action because text will be returned anyway, and we can drop that named 'text' variable too.</p>

<pre><code>Text =
  &lt;    (   ~'\''
      (    '\\' anything
      |    letter
      )
    )*
  &gt;
</code></pre>

<p>And</p>

<pre><code>SelectOption =
  seq("$select=")
  (
    "*"                                 -&gt; '*' 
  | listOf(`PropertyPath, ','):properties  -&gt; { properties: properties }
  ):value -&gt; { name: "$select", value: value }
</code></pre>

<p>Is much better off without too</p>

<pre><code>SelectOption =
  seq("$select=")
  (
    "*"
  | listOf(`PropertyPath, ','):properties  -&gt; { properties: properties }
  ):value -&gt; { name: "$select", value: value }
</code></pre>

<p><strong>Stop repeating yourself!</strong></p>

<p>OMeta uses memoisation so this isn't a big deal, but repeating yourself is annoying anyway and we can be far more expressive if we think about commonly matches constructs in our code.</p>

<pre><code>(
  seq(" asc") -&gt; "asc"
| seq(" desc") -&gt; "desc"
)?:order
</code></pre>

<p>Here I'm looking for a sequence of characters with 'space' 'asc' 'space' and this would be far better written as</p>

<pre><code>spaces
(
  seq("asc")
| seq("desc")
| -&gt; 'desc'
):order
</code></pre>

<p>And to boot I've added in the default, which is 'desc' so I don't need that optional '?' anymore.</p>

<p>And how about this little one?</p>

<pre><code>listOf(`PropertyPath, ',')
</code></pre>

<p>I use that in quite a few places in the code, better split it off into its own rule</p>

<pre><code>PropertyPathList = 
  listOf(`PropertyPath, ',')
</code></pre>

<p>And use that around the place instead!</p>

<p><strong>Un-needed brackets</strong></p>

<pre><code>  PathSegment:model 
  (
    '?'
    ( listOf(`QueryOption, '&amp;'):options
    )
  )?
</code></pre>

<p>I do this in a few places, and while it causes no harm, OMeta is hard enough to read to the un-initiated without throwing brackets in all of the place</p>

<pre><code>  PathSegment:model 
  (
    '?'
    listOf(`QueryOption, '&amp;'):options
  )?
</code></pre>

<p>Not rocket science!</p>

<p><strong>Custom matching methods</strong></p>

<p>Admittedly I hacked this together in a rum-bar at 10pm, but I have this floating around in the code for dealing with <a href="/entries/parsing-those-pesky-filtering-functions-in-odata.html">filter methods</a></p>

<pre><code>SingleArgMethodCall :name =
  seq(name) 
  '(' 
  spaces 
  FilterByExpression:one 
  spaces
  ')' -&gt; { args: [ one ], method: name }
,

TwoArgMethodCall :name = 
  seq(name)
  '(' 
  spaces 
  FilterByExpression:one 
  spaces 
  ',' 
  spaces 
  FilterByExpression:two 
  spaces 
  ')' -&gt; { args: [ one, two ], method: name }
, 

ThreeArgMethodCall :name = 
  seq(name)
  '(' 
  spaces 
  FilterByExpression:one 
  spaces 
  ',' 
  spaces 
  FilterByExpression:two 
  spaces 
  ','
  spaces
  FilterByExpression:three 
  spaces 
  ')' -&gt; { args: [ one, two, three ], method: name }
, 
</code></pre>

<p>This is still better than doing the above individually for <em>every single supported method</em>, but it would be nice if we could do</p>

<pre><code>MethodCall(name, arity)
</code></pre>

<p>Instead of having three different expressions in a non-expandable manner</p>

<p>Well, first off - the beginning of this will looke lik</p>

<pre><code>MethodCall :name :arity =
  seq(name)
  '('
    numberOf(`FilterByExpression, arity):args
  ')' -&gt; { args: args, method: name }
,
</code></pre>

<p>Except there is no function called numberOf.</p>

<p>Extending our OMeta parser with custom functions is really easy though.</p>

<pre><code>ODataParser.numberOf = function(rule, count, seperator) {
  var ret = [];
  for(var i = 1; i &lt; count; i++) {
    ret.push(this._apply(rule));
    this._apply("spaces");
    this._applyWithArgs('exactly', seperator)
    this._apply("spaces");
  }
  ret.push(this._apply(rule));
  return ret;
}
</code></pre>

<p>These '_apply' methods are simply what the rules are converted into when the OMeta is transpiled into JS, and we're skipping that bit and patching our parser with the raw JS. Simples!</p>

<h2>OData, ODear</h2>

<p>Well, I skipped a few steps here certainly - especially with regard to the following rules:</p>

<pre><code>Number = &lt;digit+&gt;:d -&gt; parseInt(d, 10),
  Number = &lt;digit+&gt;:d -&gt; parseInt(d, 10),
  Text =
    &lt;    (   ~'\''
        (    '\\' anything
        |    letter
        )
      )*
    &gt;:text
  ,

  QuotedText =
    '\''
    Text:t 
    '\'' -&gt; t
  ,
Text =
  &lt;    (   ~'\''
      (    '\\' anything
      |    letter
      )
    )*
  &gt;:text
,
</code></pre>

<p>and</p>

<pre><code>ResourcePart =
  &lt;    (   letter
    |    '_'
    )+
  &gt;:resourcePart
  -&gt; resourcePart.replace(new RegExp('_', 'g'), ' ')
,

ResourceName =
  &lt;    ResourcePart
    (    '-'
      ResourcePart
    )*
  &gt;
</code></pre>

<p>These are our primitives in the OData space, everything else is built up off of them and I've been a bad person and not done them properly. (If anybody has bothered reading all the way up to here, you probably thought this at the time and maybe even commented about it)</p>

<p><strong>Text and QuotedText</strong></p>

<p>Just what <em>is</em> Text? </p>

<p><em>As part of the query string</em></p>

<pre><code>OperationParam = 
  Text:name '=' Text:value -&gt; { name: name, value: value }
</code></pre>

<p><em>And inside quotes as a string literal</em></p>

<pre><code>QuotedText =
  '\''
  Text:t 
  '\'' -&gt; t
,
</code></pre>

<p><em>What are the rules?</em></p>

<p>Well, if it's part of the query string, let's say it's the name of a parameter, it can be anything at all (except reserved characters from the Uri - these should be encoded). To solve this we need to read the <a href="http://tools.ietf.org/html/rfc3986">RFC</a></p>

<pre><code> reserved    = gen-delims / sub-delims
 gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
 sub-delims  = "!" / "$" / "&amp;" / "'" / "(" / ")"
                         / "*" / "+" / "," / ";" / "="
</code></pre>

<p>We should recognise most of these, although some of these are explicitly allowed in some uri schemes and according to this RFC that's okay. </p>

<p>Still, an implementation of this can look something like:</p>

<pre><code>ReservedUriComponent  =
  GenDelim
| SubDelim
,

GenDelim = 
  ":" | "/" | "?" | "#" | "[" | "]" | "@"
,

SubDelim = 
  "!" | '$' | '*' | "'" | "&amp;" | "(" | ")" | "+" | "," | ";" | "="
,

Text =
  &lt;
    ~ReservedUriComponent*
    anything
  &gt;
,
</code></pre>

<p>What I'll do, is explicitly deny all of these characters except in cases where I explicitly allow them (for example, the dollar symbol is allowed in built-in query params, brackets are allowed in expressions, quotes are allowed to denote string literals, etc)</p>

<p>I can use this rule safely for quoted text as that rule explicitly allows quoted text:</p>

<pre><code>QuotedText =
  '\''
  Text:t 
  '\'' -&gt; t
</code></pre>

<p><strong>Resource paths</strong></p>

<p>Same thing now goes here, and I can say that each part of a resource path is a UriComponent, explicitly disallowing spaces, separated by a '/', so</p>

<pre><code>ResourceName =
  &lt;(    
    ~(ReservedUriComponent | ' ')
    anything
  )+
  &gt;:resourceName
</code></pre>

<p>Much happier about all of this.</p>

<p><strong>Decoding as we go</strong></p>

<p>If somebody does give us some text that looks like this</p>

<pre><code>foo='hello%20world'
</code></pre>

<p>It would be nice if it was decoded for output</p>

<pre><code>Text =
  &lt;
   (~ReservedUriComponent
   anything)*
  &gt;:text -&gt; decodeURIComponent(text)
,
</code></pre>

<p>We can indeed call arbitrary JS methods in our semantic output, good for us.</p>

<p>We'll do the same for resource names too</p>

<pre><code>ResourceName =
  &lt;(    
    ~(ReservedUriComponent | ' ')
    anything
  )+
  &gt;:resourceName -&gt; decodeURIComponent(resourceName)
</code></pre>

<p>I think if I was to go and do some of this again, I'd have been explicit about Uri conformance from the start, but it hasn't caused too much damage so we're okay.</p>

<p><strong>Supporting further primitives</strong></p>

<p>At the moment we can parse integers with</p>

<pre><code>Number = &lt;digit+&gt;:d -&gt; parseInt(d, 10)
</code></pre>

<p>But this is only half the story, we actually need to explicitly support decimals too</p>

<pre><code>Number = Decimal | Integer
,

Decimal = 
  &lt;
    digit+
    '.'
    digit+
  &gt;:d     -&gt; new Number(d)
, 

Integer = &lt;digit+&gt;:d -&gt; parseInt(d, 10)
,
</code></pre>

<p><strong>Semantic output</strong></p>

<p>I'm now much happier that we have our bases covered with the types that we support, and that I'm not doing anything nefarious with OMeta, that leaves me with a final tidy-up task.</p>

<p>In some cases, we're outputting to an array that states 'this is what you have, so now you know how to interpret it', this is quite a standard way of doing things in OMeta and particularly in the expression parsing space.</p>

<p>By outputting to an array in this manner, it becomes very easy to write a further OMeta processing step to convert the output of the OMeta parsing step into another format (compilation).</p>

<p>This is useful for say, generating SQL based on the model that these chaps have defined in SBVR.</p>

<p>Let's look at a tangible example where I've gotten this weird:</p>

<pre><code>SelectOption =
  seq("$select=")
  (
    "*"                                 -&gt; '*' 
  | PropertyPathList:properties  -&gt; { properties: properties }
  ):value -&gt; { name: "$select", value: value }
,
</code></pre>

<p>In one case, our semantic action is to return a string containing a single character *, and other case I return an object literal with a list of properties in it.</p>

<p>I kinda want to go through and sort this out, but without using it in anger (say, for generating SQL), it's hard to say what a useful model will look like.</p>

<p>I've also made some mistakes in that I didn't refactor my tests as I went to eliminate duplication, so they're a bit coupled to the structure of the model.</p>

<p>I've decided that as I only have a day left at the client, that the best thing I can do at this point is raise my hands in the air and point out very publicly that:</p>

<ul>
<li>The tests are brittle <em>because</em> and this is how you'd improve them</li>
<li>The model probably isn't that easy to consume, and will need changing, which will mean the tests need changing, <em>sorry</em></li>
</ul>

<p>With this said and done, I've decided the final bit of work I can do is to run some fuzzy testing against the parser and start trying to make it <em>really</em> complete, as this is a harder problem. (and maybe I can refactor the tests as I do this, so I only leave one problem for them to sort out)</p>

<p><strong>Fuzzy testing</strong></p>

<p>So I found a great tool (or at least something that sounds like a great tool), which <a href="http://www.quut.com/abnfgen/">generates output based on an ABNF</a>, and OData conveniently has an <a href="http://www.odata.org/media/30002/OData%20ABNF.html">ABNF specified for it</a> so let's go!</p>

<p>What I'll do to get started is download and compile the abnfgen package, and run a single test case to make sure that this crazy idea is going to work, then I'll automate it and tell it to dump failed cases to a list so I can re-run them and work out why they've failed.</p>

<p><em>edit</em></p>

<p>Scratch that, the ABNF is incomplete and buggy and crap, what is the actual point, onto making something pretty instead...</p>

<p><strong>Hooking it up to the editor</strong></p>

<p>Because one of the main reasons for using OMeta (other than "it's what they use for most parsing already"), is the support for it in the editor that they use across the organisation.</p>

<p>Hooking it up was a simple matter of grabbing some code already written to run OMeta against a third party editor, and adding support to the parser for this.</p>

<p>To do this, I just have to add a method to my parser like so:</p>

<pre><code>ODataParser._enableTokens = function() {
  OMeta._enableTokens.call(this, ['Text', 'ResourceName', 'Number', 'RecognisedOption', 'FilterAndOperand', 'FilterByOperand', 'FilterRecognisedMathOperand']);
};
</code></pre>

<p>You'll notice if you're observant, that I've added a few more named types here, that's because otherwise I had no way of matching key words and therefore colouring them separately.</p>

<p>Instead of</p>

<pre><code>seq("add")
</code></pre>

<p>I now have</p>

<pre><code>FilterRecognisedMathOperand("add")
,

FilterRecognisedMathOperand :name = 
  seq(name)
</code></pre>

<p>That's about the only type of change I had to make to support the following glory:</p>

<p><img src="/img/parse_output.png" alt="Highlighted output in a text area from OData input" title="Parse output"/></p>

<p>Mission accomplished, now onto my next client...</p>]]></description><link>http://codeofrob.com/entries/ometa-odata-odear---polishing-it-off.html</link><guid isPermaLink="true">http://codeofrob.com/entries/ometa-odata-odear---polishing-it-off.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 23 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[The final OData query bits, yes we're nearly there]]></title><description><![CDATA[<p>So yes, we <strong>are</strong> nearly there, in fact we only have a few query options remaining, which I'll cover entirely here because they're all pretty miniscule.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
<li><a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic operator support in OData</a></li>
<li><a href="/entries/precedence-grouping,-you-first..-no-you-odata-parser.html">Precedence grouping in OData</a></li>
<li><a href="/entries/parsing-those-pesky-filtering-functions-in-odata.html">Filter query methods in OData</a></li>
</ul>

<p><strong>Expand</strong></p>

<p>Expand allows the expansion of a particular property path in OData, like so</p>

<p><em>Expand the path Products/Suppliers</em></p>

<pre><code>/Categories?$expand=Products/Suppliers
</code></pre>

<p><em>Expand the path Suppliers AND expand the path Products</em></p>

<pre><code>/Categories?$expand=Suppliers,Products
</code></pre>

<p>So this is quite easy, $expand expects a list of ResourcePath, separated by a comma.</p>

<p>I'll not show the tests for this, you can assume I have some though, with the appropriate data appearing on the model..</p>

<pre><code>ExpandOption = 
  seq("$expand=")
  listOf(`PropertyPath, ','):properties -&gt; { name: "$expand", value: { properties: properties }}
,
</code></pre>

<p>Doesn't take a genius to work that one out does it :)</p>

<p><strong>Format</strong></p>

<p>This one is a doozy, the docs pretty much say it accepts</p>

<ul>
<li>application/atom+xml</li>
<li>application/xml</li>
<li>application/json</li>
<li>Any other valid IANA content type</li>
</ul>

<p>So what we're saying here is that we'll parse any content type, what I'll do is just parse the general pattern to make sure it doesn't contain garbage and leave it at that.</p>

<pre><code>FormatOption = 
  seq("$format=")
  ContentType:type -&gt; { name: "$format", value: type }
,

ContentType = 
  &lt; letter+
    '/' 
    letter+
    (
      '+' letter+
    )?
  &gt;
</code></pre>

<p>There are probably more rules than that but it's easily improved later</p>

<p><strong>Select</strong></p>

<p>Select tells us what is going to be brought back from a query, this can either be a property path, a collection of property paths or an asterisk.</p>

<p>An asterisk means bring back EVERYTHING. Nothing special.</p>

<pre><code>SelectOption =
  seq("$select=")
  (
    "*"                                 -&gt; '*' 
  | listOf(`PropertyPath, ','):properties  -&gt; { properties: properties }
  ):value -&gt; { name: "$select", value: value }
,
</code></pre>

<p><strong>Highlighting a problem or three</strong></p>

<p>That's pretty much the entire spec sorted out, and we have a few tidy ups on our hand</p>

<ul>
<li>The model we're building isn't meaningful enough</li>
<li>I've done some messy OMeta, it needs tidying</li>
<li>I'm not handling primitive types properly (ResourceNames, ResourceComponents, Numbers etc)</li>
</ul>

<p>I'll sort all these out in the next entry (I imagine that there will have been some comments made about these already in the future... in the past now, I wrote all this a month ago after all) and then we'll be finished and onto something new.</p>]]></description><link>http://codeofrob.com/entries/the-final-odata-query-bits,-yes-were-nearly-there.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-final-odata-query-bits,-yes-were-nearly-there.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 22 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Parsing those pesky filtering functions in OData]]></title><description><![CDATA[<p>The final bit of our $filter feature is the ability to invoke a special function and compare the result of that to the rest of an expression.</p>

<p>Again a reminder of where we are so far:</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
<li><a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic operator support in OData</a></li>
<li><a href="/entries/precedence-grouping,-you-first..-no-you-odata-parser.html">Precedence grouping in OData</a></li>
</ul>

<p><strong>Function calls look like this</strong></p>

<pre><code>/Customers?$filter=substringof('Alfreds', CompanyName) eq true
</code></pre>

<p>In other words, they're a special piece of the expression which can take a list of expressions separated by commas</p>

<p>I could hack this and just allow any function call, or I can explicitly name them all - which I'll do because it'll help with the highlighting in the editor that'll use this parser.</p>

<p>I'll do the first one here, and then go and do the rest in a similar fashion because they're just the same thing over and over again!</p>

<p>Our test for 'substringof'</p>

<pre><code>test("/resource?$filterby=substringof('alfred', Product) eq 'cake'", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'eq'", function() {
     assert.equal(result.options.$filterby[0], "eq")
  })
  it("lhs should be a function call", function() {
     assert.equal(result.options.$filterby[1][0], "call")
  })
  it("lhs should be substringof with correct args", function() {
     assert.equal(result.options.$filterby[1][1].method, 'substringof')
     assert.equal(result.options.$filterby[1][1].args[0], 'alfred')
     assert.equal(result.options.$filterby[1][1].args[1].name, 'Product')
  })
  it("rhs should be cake", function() {
     assert.equal(result.options.$filterby[2], "cake")
  }) 
})
</code></pre>

<p>This kinda thing will do, and getting the method out is a simple  matter of adding the MethodExpression to the values possible in an expression:</p>

<pre><code>FilterByValue = 
  FilterMethodCallExpression
| FilterNegateExpression
| Number
| QuotedText
| PropertyPath
| GroupedPrecedenceExpression
,
</code></pre>

<p>Now, it is tempting to be lazy and just write a  generic method recogniser with variable lists of args, but we're building for highlighting so it would be nice to know what the recognised methods are, and what args they expect, so what I'll do is this</p>

<pre><code>FilterMethodCallExpression = 
  (
    FilterSubstringOf
  | OtherMethod
  | AnotherMethod
  ) -&gt; [ "call", methodcall ]
,
</code></pre>

<p>And write a definition for each method (tedious, but I'll automate a pile of that with VIM macros)</p>

<pre><code>FilterSubstringOf = 
  seq('substringof'):method 
  '(' 
  spaces 
  FilterByExpression:one 
  spaces 
  ',' 
  spaces 
  FilterByExpression:two 
  spaces 
  ')' -&gt; { args: [ one, two ], method: method }
</code></pre>

<p>And they'll all look like that.</p>

<p>With this done, $filter is now fully supported and I can get on with mopping up the final recognised pieces of OData. I'll try and do that all in a single post.</p>]]></description><link>http://codeofrob.com/entries/parsing-those-pesky-filtering-functions-in-odata.html</link><guid isPermaLink="true">http://codeofrob.com/entries/parsing-those-pesky-filtering-functions-in-odata.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 19 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Precedence grouping, you first.. no you (Odata parser)]]></title><description><![CDATA[<p>With expression parsing out of the way, there are just a few complications remaining, </p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
<li><a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic operator support in OData</a></li>
</ul>

<p>I'm still missing a few key parts of this $filter feature, the next one is precedence grouping.</p>

<p><strong>Do all this stuff before you do the other stuff</strong></p>

<p>I don't think this will be too hard to parse given our already built-up knowledge of how to do precedence.</p>

<p>To the test..</p>

<pre><code>test("/some/resource?$filterby=(Price div Price) mul 5 gt 10", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'gt'", function() {
     assert.equal(result.options.$filterby[0], "gt")
  })
  var lexpr = result.options.$filterby[1] 

  it("should be {expr} mul 5", function() {
    assert.equal(lexpr[0], "mul")
    assert.equal(lexpr[2], 5)
  })

  it("should be {Price div Price}", function() {
    assert.equal(lexpr[1][0], "div")
    assert.equal(lexpr[1][1].name, "Price")
    assert.equal(lexpr[1][2].name, "Price" )
  })

  it("rhr should be 10", function() {
     assert.equal(result.options.$filterby[2], 10)
  })
})
</code></pre>

<p>This is actually the same test as in our <a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic Operators</a> post, only we've surrounded the div expression because we want that to happen all by itself.</p>

<p>Well, Brackets actually have the <em>highest</em> precedence, so they'll need to go at the very end of our parser.</p>

<pre><code>FilterByValue = 
  FilterNegateExpression
| Number
| QuotedText
| PropertyPath
| GroupedPrecedenceExpression
,

GroupedPrecedenceExpression = 
  "(" spaces FilterByExpression:expr spaces ")" -&gt; expr

,
</code></pre>

<p>Yes, it really is that simple. This is what comes of building up the definition of a parse-target out of little building blocks and then making a sequence of them.</p>

<p>If only all programs worked like this.</p>]]></description><link>http://codeofrob.com/entries/precedence-grouping,-you-first..-no-you-odata-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/precedence-grouping,-you-first..-no-you-odata-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 18 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Adding arithmetic operators to our OData parser]]></title><description><![CDATA[<p>I'm finally reaching the point where I can parse most of the OData conventions for Uris, which is nice!</p>

<p>A re-cap of where we are so far.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
</ul>

<p>Wowsers, talk about an accidental blog series...</p>

<p><strong>Arithmetic operators</strong></p>

<p>What were they again?</p>

<pre><code>Add        Addition                /Products?$filter=Price add 5 gt 10
Sub        Subtraction             /Products?$filter=Price sub 5 gt 10
Mul        Multiplication          /Products?$filter=Price mul 2 gt 2000
Div        Division                /Products?$filter=Price div 2 gt 4
Mod        Modulo                  /Products?$filter=Price mod 2 eq 0
</code></pre>

<p>Ah yes,</p>

<p>Now, these are all the same, but operator precedence is important so the order in which we want to go through them is:</p>

<ul>
<li>Add/Sub</li>
<li>Mul/Div/Mod</li>
</ul>

<p>This is very similar to how we implemented And/Or although I'll write a few tests to make sure I get it right.</p>

<pre><code>test("/some/resource?$filterby=Price add 5 gt 10", "OData", function(result) {

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'gt'", function() {
     assert.equal(result.options.$filterby[0], "gt")
  })
  it("lhr should be Price add 5", function() {
     var rhs = result.options.$filterby[1] 
     assert.equal(rhs[0], "add")
     assert.equal(rhs[1].name, "Price")
     assert.equal(rhs[2], 5)
  })
  it("rhr should be 10", function() {
     assert.equal(result.options.$filterby[2], 10)
  })
})
</code></pre>

<p>This tells us that our 'add' operator has higher precedence than the comparisons (which makes sense). This'll mean we want to sneak it in somewhere after those comparisons. (Assuming in this scheme that And/Or have a higher precedence than add, and it seems to be that way)</p>

<pre><code>FilterLogicalExpression =
  FilterLogicalExpression:lhs
  FilterByOperand:op
  FilterAddExpression:rhs -&gt; [op, lhs, rhs ]
| FilterAddExpression
,

FilterAddExpression =
  FilterAddExpression:lhs
  FilterAddOperand:op
  FilterByValue:rhs -&gt; [ op, lhs, rhs ]
| FilterByValue
,
FilterAddOperand =
  spaces
  (
    seq("add")
  | seq("sub")
  ):op 
  spaces -&gt; op
,
</code></pre>

<p>Simples, we insert it in the pipeline between "LogicalExpression" and "Checking the value" (Literal values have the highest precedence because they don't require any work)</p>

<p>And because Mul/etc have a higher precedence than Add, this exactly the same</p>

<pre><code>test("/some/resource?$filterby=Price mul 5 gt 10", "OData", function(result) {

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'gt'", function() {
     assert.equal(result.options.$filterby[0], "gt")
  })
  it("lhr should be Price add 5", function() {
     var lhs = result.options.$filterby[1] 
     assert.equal(lhs[0], "mul")
     assert.equal(lhs[1].name, "Price")
     assert.equal(lhs[2], 5)
  })
  it("rhr should be 10", function() {
     assert.equal(result.options.$filterby[2], 10)
  })
})
</code></pre>

<p>Like so</p>

<pre><code>FilterAddExpression =
  FilterAddExpression:lhs
  FilterAddOperand:op
  FilterMulExpression:rhs -&gt; [ op, lhs, rhs ]
| FilterMulExpression
,

FilterMulExpression =
  FilterMulExpression:lhs
  FilterMulOperand:op
  FilterByValue:rhs -&gt; [ op, lhs, rhs ]
| FilterByValue
,
</code></pre>

<p>Now what I actually have to do is define operator precedence for mul/div etc independently. So I can't actually cheat and do</p>

<pre><code>FilterMulOperand =
  spaces
  (
    seq("mul")
  | seq("div")
  | seq("mod")
  ):op 
  spaces -&gt; op
,
</code></pre>

<p>Like I have been doing, or when I write the following test, it will fail.</p>

<pre><code>test("/some/resource?$filterby=Price div Price mul 5 gt 10", "OData", function(result) {
    console.log(JSON.stringify(result))

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'gt'", function() {
     assert.equal(result.options.$filterby[0], "gt")
  })
  var lexpr = result.options.$filterby[1] 

  it("should be Price div {expr}", function() {
    assert.equal(lexpr[0], "div")
    assert.equal(lexpr[1].name, "Price")
  })

  it("should be Price mul 5", function() {
    assert.equal(lexpr[2][0], "mul")
    assert.equal(lexpr[2][1].name, "Price")
    assert.equal(lexpr[2][2], 5)
  })

  it("rhr should be 10", function() {
     assert.equal(result.options.$filterby[2], 10)
  })
})
</code></pre>

<p>What will happen here is we'll get</p>

<pre><code>[
  'gt',
  [
    'mul',
    [
      'div', 'Price', 'Price'
    ],
    5
  ],
  10
]
</code></pre>

<p>When what we clearly want is</p>

<pre><code>[
  'gt',
  [
    'div',
    'Price',
    [
      'mul', 'Price', '5'
    ]
  ],
  10
]
</code></pre>

<p>Or if you like</p>

<pre><code>( (price / price) * 5 ) &gt; 10
</code></pre>

<p>Instead of</p>

<pre><code>( Price / (price * 5)  ) &gt; 10
</code></pre>

<p>Which is a little bit different to say the least!</p>

<p>So, explicit operation order is what we want, and here is how get it:</p>

<p><strong>One massively explicit set of operator precedences...</strong></p>

<pre><code>FilterByOption = 
  seq("$filterby=")
  FilterByExpression:expr -&gt; { name: "$filterby", value: expr }
,

FilterByExpression =
  FilterAndExpression
,
</code></pre>

<p><em>And is the least important in our hierarchy</em></p>

<pre><code>FilterAndExpression =
  FilterAndExpression:lhs
  FilterAndOperand:op
  FilterLogicalExpression:rhs -&gt; [ op, lhs, rhs ]
| FilterLogicalExpression
,
</code></pre>

<p><em>Followed by any logical expression</em></p>

<pre><code>FilterLogicalExpression =
  FilterLogicalExpression:lhs
  FilterByOperand:op
  FilterAddExpression:rhs -&gt; [op, lhs, rhs ]
| FilterAddExpression
,
</code></pre>

<p><em>Then we descend through our mathematical operators in reverse precedence order</em></p>

<pre><code>FilterSubExpression =
  FilterSubExpression:lhs
  spaces seq("sub") spaces
  FilterAddExpression:rhs -&gt; [ "sub", lhs, rhs ]
| FilterAddExpression
,

FilterAddExpression =
  FilterAddExpression:lhs
  spaces seq("add") spaces
  FilterModExpression:rhs -&gt; [ "add", lhs, rhs ]
| FilterModExpression
,

FilterModExpression =
  FilterModExpression:lhs
  spaces seq("mod") spaces
  FilterDivExpression:rhs -&gt; [ "mod", lhs, rhs ]
| FilterDivExpression
,
FilterDivExpression =
  FilterDivExpression:lhs
  spaces seq("div") spaces
  FilterMulExpression:rhs -&gt; [ "div", lhs, rhs ]
| FilterMulExpression
,

FilterMulExpression =
  FilterMulExpression:lhs
  spaces seq("mul") spaces
  FilterByValue:rhs -&gt; [ "mul", lhs, rhs ]
| FilterByValue
,

FilterByValue = 
  FilterNegateExpression
| Number
| QuotedText
| PropertyPath
,

FilterNegateExpression = 
  spaces
  seq("not")
  spaces
  (
    FilterByValue
  | '(' spaces FilterByExpression:expr spaces ')' -&gt; expr
  ):value -&gt;  [ "not", value ]
,
</code></pre>

<p>How cool is that??!!? That's pretty much the whole shebang wrapped up as far as expressing parsing goes, and now I can go trigger mad with nested and/or/sub/mul/etc - with the exception of the precedence operators which I'll add next!</p>]]></description><link>http://codeofrob.com/entries/adding-arithmetic-operators-to-our-odata-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/adding-arithmetic-operators-to-our-odata-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 17 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[These are NOT the results you are looking for - OData parser]]></title><description><![CDATA[<p>A quick re-cap of where we are so far in our OData OMeta Adventure.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
</ul>

<p>Before we get onto some more fuzzy stuff, it would be good to deal with 'not'</p>

<p>Not is an interesting case because it's not really  the same as the rest of the expressions so far</p>

<pre><code>Not  Logical negation  /Products?$filter=not endswith(Description,'milk')
</code></pre>

<p>It can't apply in situations like this however</p>

<pre><code>/Products?$filter=not Product eq 5
</code></pre>

<p>But it can probably apply in situations like this</p>

<pre><code>/Products?$filter=not Published
</code></pre>

<p>This tells us something, which is that not isn't going to be expecting an expression unless it's in braces, otherwise it's going to be looking for a value.</p>

<p>I'm not supporting methods yet, so I'll ignore that requirement for now.</p>

<pre><code>test("/some/resource?$filterby=not Published", "OData", function(result) {

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'not'", function() {
     assert.equal(result.options.$filterby[0], "not")
  })

  it("value should be 'Published'", function() {
    assert.equal(result.options.$filterby[1].name, "Published")
  })
})
</code></pre>

<p>First off, this one</p>

<pre><code>FilterByValue = 
  FilterNegateExpression
|  Number
| QuotedText
| PropertyPath
,

FilterNegateExpression = 
  spaces
  seq("not")
  spaces
  FilterByValue:value       -&gt;  [ "not", value ]
,
</code></pre>

<p>Quite simple, if we get as far as checking for a value, it means we haven't found an expression, so we'll check for "Not" - I guess this is where we'll probably stick methods later too. </p>

<p>A "NegateExpression" is simply a "not" followed by a value, we'll allow double negatives too because there is no harm in this.</p>

<p>Next up, we'll check for braces, and inside braces we'll allow further expressions (recurse recurse recurse)</p>

<pre><code>test("/some/resource?$filterby=not (Price gt 5)", "OData", function(result) {

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'not'", function() {
     assert.equal(result.options.$filterby[0], "not")
  })
  it("Value should be Price gt 5", function() {
     var rhs = result.options.$filterby[1] 
     assert.equal(rhs[0], "gt")
     assert.equal(rhs[1].name, "Price")
     assert.equal(rhs[2], 5)
  })
})
</code></pre>

<p>Solved by</p>

<pre><code>FilterNegateExpression = 
  spaces
  seq("not")
  spaces
  (
    FilterByValue
  | '(' spaces FilterByExpression:expr spaces ')' -&gt; expr
  ):value -&gt;  [ "not", value ]
,
</code></pre>

<p>Dead easy, now it's time to get our heads stuck into Arithmetic Operators.</p>]]></description><link>http://codeofrob.com/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 16 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Recursive expression parsing in our OData filter parser]]></title><description><![CDATA[<p>A quick re-cap of where we are so far in our OData OMeta Adventure.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
</ul>

<p><strong>CRIKEY</strong></p>

<p>Never thought I'd be writing this much about OMeta, but I've taken quite the shine to it.</p>

<p>I did basic expressions, but actually expressions can be made up of other expressions so I may as well bite that bullet and get on with it.</p>

<p>Let's look at what we might expect if we use 'and'</p>

<pre><code>test("/some/resource?$filter=Price gt 5 and Price lt 10", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'and'", function() {
     assert.equal(result.options.$filterby[0], "and")
  })

  it("Left hand side should be Price gt 5", function() {
     var lhs = result.options.$filterby[1] 
     assert.equal(lhs[0], "gt")
     assert.equal(lhs[1].name, "Price")
     assert.equal(lhs[2], 5)
  })

  it("Right hand side should be less than 10", function() {
     var rs = result.options.$filterby[2] 
     assert.equal(rhs[0], "lt")
     assert.equal(rhs[1].name, "Price")
     assert.equal(rhs[2], 10)
  })
})
</code></pre>

<p>We have a tree that looks like</p>

<pre><code>[ 'and', 
  [ 'gt', 'Price', 5 ],
  [ 'lt', 'Price', 10]
]
</code></pre>

<p>Our next step can walk this tree and generate SQL or something similar very easily.</p>

<p><strong>How do we generate such a thing?</strong></p>

<p>Well, 'and' is an operator with the lowest precedence (well, the same as 'or'), and therefore we want it to be first in the tree (it makes senseif you think about it!). </p>

<p>The leaves should be the nodes with the highest precedence because we'll get their results first and them go up to the root node.</p>

<p>This suggests we need to cascade through the preferable options until we find something we like:</p>

<p>There is quite a wall here, so let's break it down</p>

<pre><code>  FilterByOption = 
    seq("$filterby=")
    FilterByExpression:expr -&gt; { name: "$filterby", value: expr }
</code></pre>

<p><em>When we find $filterby, then parse the expression</em></p>

<pre><code>  FilterByExpression =
    FilterAndExpression
</code></pre>

<p><em>The first thing we want to find is an 'and' expression</em></p>

<pre><code>  FilterAndExpression =
    FilterAndExpression:lhs
    FilterAndOperand:op
    FilterLogicalExpression:rhs -&gt; [ op, lhs, rhs ]
  | FilterLogicalExpression
</code></pre>

<p><em>try and find more AndExpressions</em></p>

<p><em>Else, let the right hand side be the next preferable thing (a plain old logical expression)</em></p>

<p><em>Else, just try to find a logical expression</em></p>

<pre><code>  FilterLogicalExpression =
    FilterLogicalExpression:lhs
    FilterByOperand:op
    FilterByValue:rhs -&gt; [ op, lhs, rhs ]
  | FilterByValue
</code></pre>

<p><em>Try to find more LogicalExpressions</em></p>

<p><em>Else, let the right hand side be the next preferable thing (a plain old value)</em></p>

<p><em>Else fall back to finding a value</em></p>

<pre><code>  FilterAndOperand =
    spaces
    (
      seq("and")
    | seq("or")
    ):op 
    spaces -&gt; op
</code></pre>

<p><em>And/or have the same precedence</em></p>

<pre><code>  FilterByOperand =
    spaces
    (
      seq("eq")
    | seq("ne")
    | seq("gt")
    | seq("ge")
    | seq("lt")
    | seq("le")
    ):op 
    spaces -&gt; op
</code></pre>

<p><em>These are unchanged</em></p>

<pre><code>  FilterByValue = 
    Number
  | QuotedText
  | PropertyPath
</code></pre>

<p><em>As are these</em></p>]]></description><link>http://codeofrob.com/entries/recursive-expression-parsing-in-our-odata-filter-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/recursive-expression-parsing-in-our-odata-filter-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 15 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Our OData parser - looking at filterby]]></title><description><![CDATA[<p>A quick re-cap of where we are so far:</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
</ul>

<p>Now I need to tackle $filterby, which is bit of a mammoth, as can be seen from the description from the OData Uri conventions</p>

<pre><code>Eq         Equal                   /Suppliers?$filter=Address/City eq 'Redmond'
Ne         Not equal               /Suppliers?$filter=Address/City ne 'London'
Gt         Greater than            /Products?$filter=Price gt 20
Ge         Greater than or equal   /Products?$filter=Price ge 10
Lt         Less than               /Products?$filter=Price lt 20
Le         Less than or equal      /Products?$filter=Price le 100
And        Logical and             /Products?$filter=Price le 200 and Price gt 3.5
Or         Logical or              /Products?$filter=Price le 3.5 or Price gt 200
Not        Logical negation        /Products?$filter=not endswith(Description,'milk')
Add        Addition                /Products?$filter=Price add 5 gt 10
Sub        Subtraction             /Products?$filter=Price sub 5 gt 10
Mul        Multiplication          /Products?$filter=Price mul 2 gt 2000
Div        Division                /Products?$filter=Price div 2 gt 4
Mod        Modulo                  /Products?$filter=Price mod 2 eq 0
( )        Precedence grouping     /Products?$filter=(Price sub 5) gt 10
</code></pre>

<p>And this is before we even have a look at the supported <em>"functions"</em> (we'll leave these until the next entry I think!)</p>

<p>Thankfully this is all pretty much the same deal and boils down to simple recursive expression parsing. </p>

<p><strong>Implementing Eq</strong></p>

<p>I'll not do this for all of them, but you can assume I've just implemented them the same way only with "Ge, etc" substituted for whatever...</p>

<pre><code>test("/some/resource?$filterby=Foo eq 2", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'eq'", function() {
     assert.equal(result.options.$filterby[0], "eq")
  })
  it("lhr should be Foo", function() {
     assert.equal(result.options.$filterby[1].name, "Foo")
  })
  it("rhr should be 2", function() {
     assert.equal(result.options.$filterby[2], 2)
  })
})
</code></pre>

<p>The idea for this stuff is that I want to generate an AST for further processing by say, a SQL generator. The easiest way to do this is to generate arrays for consumption. This can be ran through a further OMeta processing step to generate SQL later on.</p>

<p>I'm not so comfortable with the bit where I address the filterby[1].name, it feels as addressing down a path should be dealt with in the same way as the rest of the AST (perhaps everywhere else I should be generating an array instead of those nested objects).</p>

<p>I actually have some other ideas about how I'd do this so I'll park that as well (as I'm having a conversation and review of this code tomorrow in the office)</p>

<p><strong>The implementation</strong></p>

<pre><code>FilterByOption = 
  seq("$filterby=")
  FilterByExpression:expr -&gt; { name: "$filterby", value: expr }
,
FilterByExpression =
  PropertyPath:lhs
  seq(" eq ")
  Number:rhs           -&gt; [ "eq", lhs, rhs ]
,
</code></pre>

<p>So I'm keeping it simple by making some assumptions that'll get proved wrong in a sec</p>

<ul>
<li>Only accepting number for rhs</li>
<li>Only accepting 'eq as the operand</li>
<li>PropertyPath is probably not the way to go for this in its current incarnation as mentioned above</li>
</ul>

<p><strong>Adding not equals</strong></p>

<pre><code>test("/some/resource?$filterby=Foo ne 2", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'ne'", function() {
     assert.equal(result.options.$filterby[0], "ne")
  })
  it("lhr should be Foo", function() {
     assert.equal(result.options.$filterby[1].name, "Foo")
  })
  it("rhr should be 2", function() {
     assert.equal(result.options.$filterby[2], 2)
  })
})
</code></pre>

<p>Can be dealt with by saying that our Operand is a choice</p>

<pre><code>FilterByOption = 
  seq("$filterby=")
  FilterByExpression:expr -&gt; { name: "$filterby", value: expr }
,

FilterByExpression =
  PropertyPath:lhs
  FilterByOperand:op
  Number:rhs           -&gt; [ op, lhs, rhs ]
,

FilterByOperand =
  seq(" eq ") -&gt; "eq"
| seq(" ne ") -&gt; "ne"
</code></pre>

<p>Can now do the same for </p>

<ul>
<li>Gt</li>
<li>Ge</li>
<li>Lt</li>
<li>Le</li>
</ul>

<p>Like so</p>

<pre><code>FilterByOperand =
  spaces
  (
    seq("eq")
  | seq("ne")
  | seq("gt")
  | seq("ge")
  | seq("lt")
  | seq("le")
  ):op 
  spaces -&gt; op
  ,
</code></pre>

<p>Note that I tidied it up, and allowed any white space either side and got rid of my own strings (the last return result is automatically assigned to 'op'</p>

<p>And I'll parameterise the test to get this covered easily and document my progress</p>

<pre><code>function operandTest(op) {
  test("/some/resource?$filterby=Foo " + op + " 2", "OData", function(result) {
    it("A filter should be present", function() {
       assert.notEqual(result.options.$filterby, null)
    })
    it("Filter should be an instance of '" + op + "'", function() {
       assert.equal(result.options.$filterby[0], op)
    })
    it("lhr should be Foo", function() {
       assert.equal(result.options.$filterby[1].name, "Foo")
    })
    it("rhr should be 2", function() {
       assert.equal(result.options.$filterby[2], 2)
    })
  })
}
operandTest("eq")
operandTest("ne")
operandTest("gt")
operandTest("ge")
operandTest("lt")
operandTest("le")
</code></pre>

<p><strong>Not everything is a number</strong></p>

<p>Now for the next thing, what can we have as that Rhs? Well, let's go with</p>

<ul>
<li>Number (eg 2, 3, 5 )</li>
<li>QuotedText (eg 'foo', 'bar')</li>
</ul>

<p>As that's what I can think of from the docs</p>

<p>Here is a test for the quoted string:</p>

<pre><code>  test("/some/resource?$filterby=Foo eq 'bar'", "OData", function(result) {
    it("A filter should be present", function() {
       assert.notEqual(result.options.$filterby, null)
    })
    it("Filter should be an instance of 'eq'", function() {
       assert.equal(result.options.$filterby[0], op)
    })
    it("lhr should be Foo", function() {
       assert.equal(result.options.$filterby[1].name, "Foo")
    })
    it("rhr should be 2", function() {
       assert.equal(result.options.$filterby[2], 'bar')
    })
  })
</code></pre>

<p>Same deal again, let's make this extendable</p>

<pre><code>FilterByExpression =
  PropertyPath:lhs
  FilterByOperand:op
  FilterByValue:rhs           -&gt; [ op, lhs, rhs ]
,
</code></pre>

<p>With</p>

<pre><code>FilterByValue = 
  Number
| QuotedText
</code></pre>

<p>Where QuotedText looks something like this:</p>

<pre><code>QuotedText =
  '\''
  Text:t 
  '\'' -&gt; t
,
</code></pre>

<p>Imaginative.</p>

<p>Next up we'll have to think about what else we can expect to see in our expressions - thinking about the Arithmetic operators and grouping operators. <em>shudder</em></p>]]></description><link>http://codeofrob.com/entries/our-odata-parser---looking-at-filterby.html</link><guid isPermaLink="true">http://codeofrob.com/entries/our-odata-parser---looking-at-filterby.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 12 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Paging support in our OData parser]]></title><description><![CDATA[<p>As a reminder as to where we've gotten to so far, these are the tests that are currently passing:</p>

<pre><code>Parsing /
   Service root should have no model 

Parsing /model
   should have the resource specified 

Parsing /model(1)
   should have the resource specified 
   should have the key specified for the source 

Parsing /model(1)/child
   should have the resource specified 
   should have the key specified for the resource 
   should have the child specified 

Parsing /model(1)/$links/Child
   should have the resource specified 
   should have the key specified for the resource 
   should have the link specified 

Parsing /method(1)/child?foo=bar
   should have the resource specified 
   The result should be addressed 
   should have the path specified 
   should have the argument specified 

Parsing /resource?$orderby=Property
   sort options are present on the result 
   sort options have the property specified 

Parsing /resource?$orderby=PropertyOne,PropertyTwo
   sort options are present on the result 
   sort options have the first property specified 
   sort options have the second property specified 

Parsing /resource?$orderby=PropertyOne desc
   sort options are present on the result 
   sort options have the property specified 
   sort options have the property ordering specified 

Parsing /resource?$orderby=PropertyOne asc
   sort options are present on the result 
   sort options have the property specified 
   sort options have the property ordering specified 

Parsing /resource?$orderby=PropertyOne asc,PropertyTwo desc
   sort options are present on the result 
   sort options have property one name specified 
   sort options have property one ordering specified 
   sort options have the property two name specified 
   sort options have the property two ordering specified 

Parsing /resource?$orderby=PropertyOne/SubProperty
   sort options are present on the result 
   sort options have property one name specified 
   sort options have property one's sub property specified 
</code></pre>

<p>Which is nice. Now I want to add paging support in the form of </p>

<p>$top and $skip, while I'm at it I may as well add support for $inlinecount because it's pretty much the same thing.</p>

<p>This should be fairly easy, this is what I want to support:</p>

<pre><code>/some/path?$top=5&amp;limit=skip=100
/some/path?$inlinecount=allpages
</code></pre>

<p><strong>Top and Skip</strong></p>

<p>These are quite simple, just text and a number, let's write a couple of tests</p>

<pre><code>test("/some/resource?$top=5&amp;$skip=100", "OData", function(result) {
  it("top should be specified", function() {
     assert.equal(result.options.$top, 5)
  })
  it("skip should be specified", function() {
     assert.equal(result.options.$skip, 100)
  })
})
</code></pre>

<p>I just need to add these to the list of recognised query options</p>

<pre><code>QueryOption = 
    SortOption
  | TopOption
  | SkipOption
  | OperationParam
,
</code></pre>

<p>This is where the elegance of OMeta makes me really happy, being able to easily say what the options for something are in this way is really pretty.</p>

<p>So, TopOption</p>

<pre><code>TopOption = 
  seq("$top=") Number:value -&gt; { name: "$top", value: value }
,
</code></pre>

<p>and SkipOption</p>

<pre><code>SkipOption = 
  seq("$skip=") Number:value -&gt; { name: "$skip", value: value }
,
</code></pre>

<p>Can't say fairer than that!</p>

<p><strong>inlinecount</strong></p>

<p>This one is a bit more interesting, the only valid options are <em>none</em> and <em>allpages</em>, and we're supposed to return a 404 if we don't match. We're not currently doing anything with HTTP in this parser so what I'll actually do is accept "any text" and leave it up to the consumer to do this job for us. (Rather than throw a generic <em>I can't parse this</em> exception)</p>

<pre><code>test("/some/resource?$inlinecount=allpages", "OData", function(result) {
  it("inline should be specified", function() {
     assert.equal(result.options.$inlinecount, "allpages")
  })
})

test("/some/resource?$inlinecount=none", "OData", function(result) {
  it("inline should be specified", function() {
     assert.equal(result.options.$inlinecount, "none")
  })
})

test("/some/resource?$inlinecount=flibble", "OData", function(result) {
  it("inline should be specified", function() {
     assert.equal(result.options.$inlinecount, "")
  })
})
</code></pre>

<p>I want explicit handling for this because it'll help with the highlighting efforts in the editor that  this will be used in.</p>

<p>We can add it like so</p>

<pre><code>QueryOption = 
    SortOption
  | TopOption
  | SkipOption
  | InlineCountOption
  | OperationParam
,
</code></pre>

<p>And handle our explcit decisions like so</p>

<pre><code>InlineCountOption =
  seq("$inlinecount=") 
  (
    seq("allpages") -&gt; "allpages"
  | seq("none") -&gt; "none"
  | Text -&gt; ""
  ):value -&gt; { name: "$inlinecount", value: value }
,
</code></pre>

<p><strong>Et voila</strong></p>

<p>So that's paging done and dusted, incredibly simple when you know how. Next up we'll explore the murky world of OData filtering.</p>]]></description><link>http://codeofrob.com/entries/paging-support-in-our-odata-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/paging-support-in-our-odata-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 11 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[The OData parser - applying modifiers to our query]]></title><description><![CDATA[<p>I've got <a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">basic resource parsing</a>, <a href="/entries/parsing-odata---nested-resource-paths.html">path parsing</a>, and <a href="/entries/parsing-odata---service-operations.html">service operations</a> sussed, now I need to begin the grand delving into parsing all of the query options that can be applied to an OData request.</p>

<p>There is quite the myriad of query string options that can be applied in a conventional OData request, and they all begin with $ and have some sort of expression after it.</p>

<ul>
<li>$orderby (order by some sort of field)</li>
<li>$top (paging support)</li>
<li>$skip (paging support)</li>
<li>$filter (expressions passed in to do filtering - basically LINQ support and SQL server support &lt;/cynicism&gt;)</li>
</ul>

<p>These all appear at the very end of the query string like so</p>

<pre><code>/resource/child?$orderby=Rating asc
/resource?$top=10
/resource?$orderby=Rating,Category/Name desc
/resource?$filter=Rating eq 5
</code></pre>

<p>As can be seen, the complexity of these can grow quite easily but in reality they're pretty much a combination of</p>

<ul>
<li>the query option itself</li>
<li>an expression that is unique to that query option</li>
</ul>

<p>Also, we can re-use any rules we already have about parsing resource names (except we don't want to allow id specification, etc)
I imagine when trying to re-use those rules I'll probably sort out some of the niggles I've overlooked so far too!</p>

<p>So I guess what we need to do is parse the resource path and then apply any of these modifiers to it. There is actually a fair amount of support for this already in the Rulemotion code that I'm looking to replace so I'll likely be able to copy most of it out as I write the tests for it.</p>

<p><strong>$orderby</strong></p>

<p>OrderBy seems quite trivial so we'll start with that</p>

<pre><code>test("/resource?$orderby=Property", "OData", function(result) {
  it("sort options are present on the result", function() {
     assert.notEqual(result.options.$orderby, null)
  })
  it("sort options have the property specified", function() {
     assert.equal(result.options.$orderby.property, "Property")
  })
})
</code></pre>

<p>I'm quite excited about this as how this model presents itself will probably help me sort out the main model I'm creating to support the OData request.</p>

<p>I'll start off with:</p>

<pre><code>OData = (
  (
    PathSegment:model 
    (
      '?'
      ( listOf(`QueryOption, '&amp;'):options
      )
    )?
  ) -&gt; { 
          if(options) {
           model.options = {}
           for(var i in options)
             model.options[options[i].name] = options[i].value;
          }
         return model
       }
  | '/'
) 
</code></pre>

<p>I'll simply look for a list of query options, and actually merge the notion of service parameters and known query options (and in fact, custom options too - which are simply any unrecognised options - without a dollar sign in front of them)</p>

<p>What does this look like? </p>

<pre><code>QueryOption = 
  SortOption
| OperationParam
,

SortOption = 
  seq("$orderby=")
  ResourceName:property -&gt; { name: '$orderby', value = { property: property }}
</code></pre>

<p>Well we'll start off with the simplest one, which is just supporting a single property and no options. I don't want to get too ahead of myself after all.</p>

<p>This works but of course I've broken my tests for service parameters now, so I'll fix those</p>

<pre><code>test("/method(1)/child?foo=bar", "OData", function(result) {
    console.log(result)
  it("should have the resource specified", function() {
     assert.equal(result.resource, 'method')
  })
  it("The result should be addressed", function() {
     assert.equal(result.key, '1')
  })

  it("should have the path specified", function() {
     assert.equal(result.property.resource, 'child')
  })

  it("should have the argument specified", function() {
     assert.equal(result.options.foo, 'bar')
  })
})
</code></pre>

<p><strong>A bit more $orderby</strong></p>

<p>Not done by a long-shot, we have several aspects to $orderby</p>

<ul>
<li>We can order by a single property</li>
<li>We can order by several properties</li>
<li>A property can be specified by a path to that property</li>
<li>We can order ASC or DESC</li>
</ul>

<p>First off, let's deal with multiple properties - it seems this will be easiest</p>

<pre><code>test("/resource?$orderby=PropertyOne,PropertyTwo", "OData", function(result) {
  it("sort options are present on the result", function() {
     assert.notEqual(result.options.$orderby, null)
  })
  it("sort options have the first property specified", function() {
     assert.equal(result.options.$orderby.properties[0].name, "PropertyOne")
  })
  it("sort options have the second property specified", function() {
     assert.equal(result.options.$orderby.properties[1].name, "PropertyTwo")
  })
})
</code></pre>

<p>Yeugh, our data model is getting quite convoluted - I'll be working on that for sure.</p>

<p>But first...</p>

<pre><code>SortOption = 
  seq("$orderby=")
  listOf(`SortProperty, ','):properties -&gt; { name: '$orderby', value: { properties: properties }  }
,

SortProperty = 
  ResourceName:property -&gt; { name: property }

,
</code></pre>

<p>Pretty tidy, and this opens up the avenue of being able to specify ASC or DESC very easily</p>

<p><em>DESC</em></p>

<pre><code>test("/resource?$orderby=PropertyOne desc", "OData", function(result) {
  it("sort options are present on the result", function() {
     assert.notEqual(result.options.$orderby, null)
  })
  it("sort options have the property specified", function() {
     assert.equal(result.options.$orderby.properties[0].name, "PropertyOne")
  })
  it("sort options have the property ordering specified", function() {
     assert.equal(result.options.$orderby.properties[0].order, "desc")
  })
})
</code></pre>

<p><em>ASC</em></p>

<pre><code>test("/resource?$orderby=PropertyOne asc", "OData", function(result) {
  it("sort options are present on the result", function() {
     assert.notEqual(result.options.$orderby, null)
  })
  it("sort options have the property specified", function() {
     assert.equal(result.options.$orderby.properties[0].name, "PropertyOne")
  })
  it("sort options have the property ordering specified", function() {
     assert.equal(result.options.$orderby.properties[0].order, "asc")
  })
})
</code></pre>

<p><em>Double trouble</em></p>

<pre><code>test("/resource?$orderby=PropertyOne asc,PropertyTwo desc", "OData", function(result) {
  it("sort options are present on the result", function() {
     assert.notEqual(result.options.$orderby, null)
  })
  it("sort options have property one name specified", function() {
     assert.equal(result.options.$orderby.properties[0].name, "PropertyOne")
  })
  it("sort options have property one ordering specified", function() {
     assert.equal(result.options.$orderby.properties[0].order, "asc")
  })
  it("sort options have the property two name specified", function() {
     assert.equal(result.options.$orderby.properties[1].name, "PropertyTwo")
  })
  it("sort options have the property two ordering specified", function() {
     assert.equal(result.options.$orderby.properties[1].order, "desc")
  })
})
</code></pre>

<p>Adding this is <em>super</em> easy</p>

<pre><code>SortProperty = 
  ResourceName:property
  (
    seq(" asc") -&gt; "asc"
  | seq(" desc") -&gt; "desc"
  )?:order
  -&gt; { name: property, order: order }
</code></pre>

<p>Simply check for the resource name, then optionally check for an "asc" or a "desc", before bundling this into an object.</p>

<p><strong>And the final bit - property paths</strong></p>

<p>I already technically have this written in the form of the expression "PathSegment", but that's a bit too coupled to the main query path, and un-coupling it would be tricky - so it's better off just to write a new expression for matching paths within query options.</p>

<p>First off, the test I want to pass</p>

<p><em>Reminder: This is the PathSegment I put together last time</em></p>

<pre><code>PathSegment = 
      '/'
      ResourceName:resource
      (
        ("(" Number:key ")")?
        (
          (seq("/$links") PathSegment:link)
        | PathSegment: next
        )?
      ) -&gt; { resource: resource, key: key, link: link, property: next }
,
</code></pre>

<p>We just need a subset of this, let's call it PropertyPath</p>

<pre><code>PropertyPath = 
      ResourceName:resource
      (
        '/'
        PropertyPath: next
      )? -&gt; { name: resource, property: next}
,
</code></pre>

<p>And with a slight modification to our SortOptions to use this new expression:</p>

<pre><code>SortProperty = 
  PropertyPath:property
  (
    seq(" asc") -&gt; "asc"
  | seq(" desc") -&gt; "desc"
  )?:order
  -&gt; {
       property.order = order;
       return property;
     }
</code></pre>

<p>And we're done.</p>

<p>Next up, I'll tackle the paging stuffs, as that should be simple.</p>]]></description><link>http://codeofrob.com/entries/the-odata-parser---applying-modifiers-to-our-query.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-odata-parser---applying-modifiers-to-our-query.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 10 Apr 2013 09:30:00 GMT</pubDate></item></channel></rss>