<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><generator>NodeJS RSS Module</generator><lastBuildDate>Wed, 28 Mar 2012 15:06:00 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Anti-templating languages]]></title><description><![CDATA[<p>I don't really like templating languages or view engines (especially in JavaScript) - it's something I've been vocal on in person for a while now but never got around to writing about.</p>

<p>Things like this have been <a href="http://www.workingsoftware.com.au/page/Your_templating_engine_sucks_and_everything_you_have_ever_written_is_spaghetti_code_yes_you">ranted on</a> before by other people, but I want to share my particular dislike of the frameworks and technologies here, as well as present up the way I'm currently working.</p>

<p><strong>Logic in your views</strong></p>

<p>Now, we all know this isn't a good idea, but what do we really mean by this? What are the problems we're facing?</p>

<p><strong>EJS</strong></p>

<p>EJS is a view engine similar in nature to WebForms in ASP.NET, which means for .NET devs it's often reached at for its comfortable familiarity and lack of learning requirements.</p>

<p>Let's look at the default example on the EJS website to understand this</p>

<pre><code>&lt;ul&gt;
&lt;% for(var i=0; i &lt; supplies.length; i++) {%&gt;
   &lt;li&gt;&lt;%= supplies[i] %&gt;&lt;/li&gt;
&lt;% } %&gt;
&lt;/ul&gt;
</code></pre>

<p>EJS promises to "<em>Clean the HTML out of your JavaScript</em>", and the very first demo shows us an example of HTML which has been dirtied with JavaScript.</p>

<p>This is just moving the problem around, this is very much a case of "logic in the view" and it makes it difficult to maintain because it's difficult to read and it's hard to tell where the HTML begins and where the HTML ends.</p>

<p>Standard practise might be to do something like this:</p>

<pre><code>&lt;ul&gt;
    &lt;%= Helpers.RenderList(supplies) %&gt;
&lt;/ul&gt;
</code></pre>

<p>But this just means I've moved the HTML back into my JavaScript again. I guess what we're saying here, is that tryingto arbitrarily separate 'view' from 'logic' in this way is a fools errand and moving the problem around is solving nothing.</p>

<p><strong>Mustache</strong></p>

<p>Mustache is a "logic-less" templating language (they say it on their site), there are other "logic-less" templating languages around too and they're all much of a muchness.</p>

<p>I quote:</p>

<blockquote>
  <p>We call it "logic-less" because there are no if statements, else clauses, or for loops. Instead there are only tags.</p>
</blockquote>

<p><em>for-loop-replacement:</em></p>
<pre><code>
    &lt;ul&gt;
    {{#supplies}}
      &lt;li&gt;{{text}}&lt;/li&gt;
    {{/supplies}}
    &lt;/ul&gt;
</code></pre>

<p><em>if-else-statement-replacement</em></p>

<pre><code>
{{#shipped}}
    &lt;li&gt;This product shipped on {{shipdate}}&lt;/li&gt;
{{/shipped}}
{{^shipped}}
    &lt;li&gt;This product has not yet shipped&lt;/li&gt;
{{/shipped}
</code></pre>

<p>This is just a for loop and an if-else statement but with different syntax, pretending they're otherwise is doing a disservice to everybody who is going to be reading this code.</p>

<p>We of course also have the ability to seamlessly call methods from Mustache because we're always going to need to write code somewhere <i>(see above re: arbitrary separation)</i>.</p>

<pre><code>{{#wrapped}}
  {{name}} is awesome.
{{/wrapped}}

{
  "name": "Rob",
  "wrapped": function() {
    return function(text) {
      return "&lt;b&gt;" + render(text) + "&lt;/b&gt;"
    }
  }
}
</code></pre>

<p>This serves to just confuse though, as the fact a method is being called is hidden from us and means we're reduced to jumping between template and code to work out what is going on.</p>

<p><strong>A shared concern</strong></p>

<p>I have a problem that's shared across all of these solutions though, and that's the one of dealing with external designers.</p>

<p>I have only once worked in a situation where I was privileged enough to work with a designer who knew her HTML and Webforms syntax and could be taught more if needed because she was a permanent member of our team. <em>(And that was only because I spent months campaigning to get somebody who knew what they were doing when it came to making things look pretty!)</em></p>

<ul>
<li>I want to be delivered clean HTML which I can use in my application</li>
<li>I want to be able to integrate updates to that HTML if need be</li>
<li>Teaching a contractor how to use 'template language X' is a waste of my money</li>
<li>Finding a contractor who knows 'template langauge X' is a waste of my time</li>
</ul>

<p>Here in lies a problem - the moment we go to any templating language/system that isn't <em>just</em> HTML, we have to transform what the designer has given us into that templating language - and then translate it back when patching in any amendments that might come as we continue developing.</p>

<p><strong>Performance</strong></p>

<p>Not only those points, but if we're truly going to have a logic-less templating language and we're using third party APIs in any way (whether they be third-third party, or just plain old third party) then in order to get the data into a shape fit for binding directly to your template, transforms must be done which means writing mapping code one way or another.</p>

<p>It's not healthy I tell you - if you're going to transform one set of data into other data that is an exact match of your view requirements, and then transform from that data into another set of data (your view) then you're paying a cost for this. (Throw in your favourite MVC/MVVM framework for JS and even more so, but that's another blog entry entirely).</p>

<p><strong>So what do I like then?</strong></p>

<ul>
<li>Accept that a for loop is a for loop</li>
<li>Accept that an if statement is an if statement</li>
<li>Accept that you're always going to need some of these things in your applications</li>
<li>Accept that the above is best suited to being in a programming language of some sort</li>
</ul>

<p>We have a great opportunity in JS, where we have a language that has been built almost for the primary purpose of interacting with the output that the user sees and where we have libraries whose sole purpose is the interaction <em>with</em> that output.</p>

<p><em>Use the force</em></p>

<p>Enter the anti-templating system "<a href="https://github.com/flatiron/plates">Plates</a>" (there are others that are similar, but this is what I'm using at the moment, as it's isomorphic, fast with no-frills and hopefully will remain so - despite the "issue" reports asking for "nesting" or "collections" etc - as they're missing the point).</p>

<p>Rather than being a templating language, Plates merely binds data to HTML. </p>

<p>HTML!! You know - the stuff that you're going to give to the browser, the  stuff which your designer gives you - the stuff that everybody on the internet and their pet animals know how to use.</p>

<p>Given some HTML:</p>

<pre><code>&lt;div id="test"&gt;&lt;/div&gt;
</code></pre>

<p>And some model:</p>

<pre><code>{ 
    "test": "hello"
}
</code></pre>

<p>Then </p>

<pre><code>Plates.bind(html, model);
</code></pre>

<p>Combined with a bit of JavaScript this gives us enough power to do everything we'd want to do when it comes to taking some data and displaying it on a page. <em>(Yes, it supports matching by class, yes it supports putting data into attributes on those elements, this is all trivial).</em></p>

<p><em>How does it all fit together?</em></p>

<p>Well, I tend to either keep the HTML snippets which I'm going to hydrate on the page itself in a hidden div, or if they're shared templates, as files which I can pull down with a HTTP GET (not rocket science really).</p>

<p>How do I deal with collections? Easy - I write a for loop. How do I deal with different paths? I want an 'if' statement.</p>

<p><em>But don't you end up with spaghetti code?</em></p>

<p>Well no - just because I'm not following an enforced and arbitrary separation of 'view' and 'logic' doesn't mean I'm throwing away sensible software practises.</p>

<p>It's just, that separation comes naturally on a case-by-case basis.</p>

<p>Sometimes I'll end up with some code that matches the model purely on convention and I can write</p>

<pre><code>hydrateTemplate('source', 'target', data);
</code></pre>

<p>Sometimes I'll end up with builders that look like this</p>

<pre><code> startTemplateWithId('targetId')
    .withText('title', data.title)
    .withText('name', data.name)
    .withCollection('itemList', data.items, getItemHtml)
    into('placeholder');
</code></pre>

<p>Or similar (although in most simple cases this kind of over-blown code isn't needed).</p>

<p>My mark-up remains clean, my model remains clean, and the code that lies between is kept clean, tidy and to the point - not to mention re-usable where appropriate because it's <em>just code</em>.</p>

<p>When asked where this style fits in, I'd say it's essentially just MVP, with the line between V and P moving around to fit the situation.</p>

<p><strong>Summary</strong></p>

<p>Separation of view and logic isn't going to happen along any sort of neat line without silly amounts of abstraction; use something that allows you to have clean HTML and clean JavaScript with as little bullshit in-between as possible. </p>

<p>You'll be happier, your code will be happier and you'll find it is a lot easier to deliver a product when you stop arguing about whether you have enough separation in your abstractions.</p>


]]></description><link>http://codeofrob.com/entries/anti-templating-languages.html</link><guid isPermaLink="true">http://codeofrob.com/entries/anti-templating-languages.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 28 Mar 2012 16:34:00 GMT</pubDate></item><item><title><![CDATA[Lessons learned building a multiplayer game in NodeJS and WebGL]]></title><description><![CDATA[<p>I've uploaded Hoverbattles to its own server on EC2, and it has been running fine with an uptime of over 96 hours so far, and this is great!</p>

<p><a href="http://hoverbattles.com">http://hoverbattles.com</a></p>

<p>I've wanted to share a few of the mistakes/lessons learned writing and deploying a multiplayer game built entirely with JavaScript on top of <a href="http://nodejs.org/">NodeJS</a> and <a href="http://learningwebgl.com/blog/">WebGL</a> for a while and this represents an opportune moment to do so. </p>

<p>I've gone with a brain-dump of various related learnings, as well as a couple of periphery items - first off, we'll go with the reason I couldn't keep Hoverbattles up on the old server.</p>

<p><strong>Deploy long-running, processor-intensive node apps to decent hardware</strong></p>

<p>If you're going to deploy a long running node application that is going to be running a constant load, don't deploy it to either:</p>

<ul>
<li>A micro instance of EC2</li>
<li>A really low budget VPS</li>
</ul>

<p>This might be plain old obvious to most people, but apparently not to me - I first deployed to my own VPS, and found that after it had been running for an hour or so it consumed all the memory on the server and fell over in a steaming heap.</p>

<p>I tried to find a memory leak in Hoverbattles itself, I changed to various versions of node, I re-built various components of the OS and nothing seemed to work. I wasn't able to reproduce the issue on my meaty laptop and I gave up for a while, as I was working on a new project.</p>

<p>Turns out that by running long running processes on a virtualised OS on oversubscribed hardware, the OS is lied to, or it lies to you and things don't work quite well. Some of the more knowledgeable types could probably tell us why - but the bottom line is you shouldn't be doing it.</p>

<p><strong>Note:</strong> This probably doesn't go for simple websites built on top of node in express or whatever, I'm talking about long running applications that are doing processing almost constantly, like the server-side component to a 'realtime' multiplayer game.</p>

<p><strong>If you're really going to share code between client + server, plan this accordingly</strong></p>

<p>With Hoverbattles, it started off as a purely client-based game, with JavaScript files being included in the main HTML file and this worked great while I was experimenting with the WebGL and working out how everything was going to work.</p>

<p>I soon moved to having a server implementation running the logic, and ported everything across to <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS</a>, using <a href="https://github.com/sstephenson/stitch">Stitch</a> to package up all of the files so I could use them on the client.</p>

<p>This is actually problematic, as you don't want <em>all</em> the code on the client, and you don't want <em>all</em> the code on the server - with CommonJS you'll only get the code loaded on the server that is used there, but if you're stitching your entire /src folder, you're potentially also sending down code for your persistence, communication, 'secret sauce' stuff etc.</p>

<p>I ended up solving this in Hoverbattles by having a folder structure of:</p>

<pre><code> /shared
 /server
 /client
</code></pre>

<p>This is a bit hideous and arbitrary - and doesn't allow me to organise my codebase naturally along its logical borders, and it's for that reason in my latest projects I've switched across to using <a href="http://requirejs.org/">RequireJS</a>.</p>

<p>By writing different entry points to the same code, and simply boot-strapping in various sub-systems and behaviours from those call-sites, you can naturally end up with a dependency chain that only includes code relevant to the platform for which it is targetted. </p>

<p><strong>Avoid creating new objects in the main event loop</strong></p>

<p>This is obvious too if you've been developing any sort of large scale JavaScript application, or you come from an unmanaged background where this is something you learn not to do from very early on - but I've been developing in a mostly managed world for a few years (C#) and creating objects doesn't carry with it the same overhead so you become quite cavalier to it.</p>

<p>I started profiling Hoverbattles a few weeks in and was surprised to find out that 70% of my CPU time was spent in a single method, that is:</p>

<pre><code>vec3.create();
</code></pre>

<p>Vec3 is an object literal from <a href="https://github.com/toji/gl-matrix">glMatrix</a> containing useful functions for manipulating and creating vectors on top of the typed arrays available in WebGL compatible browsers - these are cool for a number of reasons (performance oriented reasons mostly) and I didn't really think twice about my usage here.</p>

<p>Consider the following imaginary method called once a frame for each missile currently active in the scene.</p>

<pre><code>calculateDistanceToTarget: function() { 
  var difference = vec3.create();
  var targetDestination = this.target.position;
  vec3.subtract(targetDestination, this.position, difference);
  return vec3.length(difference);
};
</code></pre>

<p>This is a really bad idea, and I had code lying around all over the place that would do this - create a temporary float array in order to perform some calculation and then carry on.</p>

<p>The answer was to create a buffer or two on start-up for each system that needed to do things like this, then the code looks something like this.</p>

<pre><code>calculateDistanceToTarget: function() { 
  var targetDestination = this.target.position;
  vec3.subtract(targetDestination, this.position, this.sharedVec3);
  return vec3.length(this.sharedVec3);
};
</code></pre>

<p>This isn't too nice, but so long as you keep the use of this shared buffer to a single method (IE, write into it, then read out of it immediately) then there are no issues with multiple methods across the system using this data.</p>

<p>On that note though...</p>

<p><strong>Private state should remain private</strong></p>

<p>I got in the habit in Hoverbattles of being a bit cavalier about accessing state and simply doing direct property access across objects in order to perform calculations. In some cases this isn't a bad idea and keeps the code legible and fast. In most cases it's a lot of coupling added for little gain - especially if you start to write back to those fields later.</p>

<p>Just like in C#, property/field access is generally a bad idea, you should be asking objects questions which they can answer, and giving them extra information for those questions if they need it - and you should definitely be telling them to do things instead of taking that responsibility away from them.</p>

<p>The thing is, in most LOB apps this is really not that big a deal, CRUD is boring, the applications we build are boring, we can get away with this stuff. When you're dealing with a game world where dozens of things are going on 30 times a second, controlling access to state starts to become important. <em>Lesson learned.</em></p>

<p>Consider instead our earlier example of:</p>

<pre><code>calculateDistanceToTarget: function() { 
  var targetDestination = this.target.position;
  vec3.subtract(targetDestination, this.position, this.sharedVec3);
  return vec3.length(this.sharedVec3);
};
</code></pre>

<p>We could instead have:</p>

<pre><code>calculateDistanceToTarget: function() {
    return this.target.distanceFrom(this.position);
};
</code></pre>

<p>This subtle switch in logic means we're no longer accessing the supposedly private state of another object, and I'm free to change it without worrying about the rest of my code breaking.</p>

<p>I'm also able to far easier control this behaviour when writing tests (target can be a fake target if I feel it necessary to stub out the real logic).</p>

<p>In my current projects I am being a lot more strict about state access - all state is technically public due to the nature of my JavaScript objects, but I don't give into temptation and touch it (<em>that's will power yo</em>').</p>

<p>Encapsulation is really important in a project that has this much "business logic", and having a sensible object model is a big part of this.</p>

<p><strong>Push, don't pull - but sometimes pull</strong></p>

<p>I also made the mistake in Hoverbattles of trying to build components to control every aspect of a particular behaviour - this involved pulling state from various places to work out whether A or B should happen, or whether to display X on the screen or not.</p>

<p>This didn't scale, I ended up having to pull state from three sources (which means asking the world for the entities concerned), and writing methods to pull that state on the components that those entities were build out of.</p>

<p>Turns out I ended up with a system in places that looks like classic Event Sourcing; You look at high score tables, persistence, particle systems and the HUD as views on top of the single source of truth and consider that you can build those views from events being raised in the game world. Suddenly it makes sense that all state in areas with high view subscription should be built from events raised by those entities.</p>

<p>Once I had that realisation, development got a lot easier, <em>"Hey, I've been told to move, I'll  raise an event with the relevant data, subscribe to it myself to update my own state and let everybody else do the same".</em></p>

<p>I didn't go overboard with this, in Hoverbattles there are only a few places where the above is true, and even then only just and in my latest code this is much more established pattern - the world has commands coming in via input or across the network, and raises events so everything that cares can be updated.</p>

<p>Sometimes it is just more appropriate to pull the state, especially if it's hard to raise an event without duplicating data (see above the cost of creating new objects), and the trick so far has been recognising that and trying not to overly homogenise.</p>

<p><strong>Don't let network-code take over your domain</strong></p>

<p>In Hoverbattles there was a real problem when it came to writing the network code, it ended up being far too pervasive and leaked into too many aspects of the logical entity code.</p>

<p>Some of this managed to be repaired before it became too much of a mess, the main realisation was that there were only a few classes of problem involved in most of the network code, that is:</p>

<ul>
<li>User input, sent as commands to both the world and the server</li>
<li>Periodic sync, extracting state from objects and serializing across the wire to all clients</li>
<li>Protected code that can only be executed on the server, but the results of which need executing on both client and server</li>
</ul>

<p>These are actually ordered in terms of difficulty:</p>

<ul>
<li>User input can easily be sorted by sticking an intermediary between the actual input emitter and the game world (so, one object with some code in it). </li>
<li>Each component has the chance to serialize state and receive state by convention with methods called _in and _out</li>
<li>This one caused a lot of issues, trying to attach different components to entities depending on whether they were created on the server/client, etc</li>
</ul>

<p>That last one was a bit of a doosy, I ended up with about 20 objects trying to juggle only the responsibility specific to the server or to the client, it looked something like this.</p>

<pre><code>/client/
/client/firingbehaviour.js
/client/dyingbehaviour.js
/client/lockingbehaviour.js
/server/
/server/firingbehaviour.js
/server/dyingbehaviour.js
/server/lockingbehaviour.js
/shared/
/shared/firingbehaviour.js
/shared/dyingbehaviour.js
/shared/lockingbehaviour.js
</code></pre>

<p>This gave me hard to debug errors because the responsibilities for an entity's behaviour were spread all over the place, state was being mutated all over the shop and it was becoming hard not to duplicate code across the different environments.</p>

<p>All of this because I was full of pride and didn't want to write into my code anywhere the line of code:</p>

<pre><code>if(Environment.IsServer)
</code></pre>

<p>As it felt wrong. I ended up with a compromise, which is I'd do that on the main entity object (which tends to bring together these different behavourial components).</p>

<p>Here's the thing - if I was using events to update my internal state, surely I could simply suppress the events on the client if the client didn't have permission to make that decision <em>(for example, player health loss is a decision only the server can make - I don't want craft blowing up and being removed from the scene if they didn't actually die, it's a horrible visual artifact).</em></p>

<pre><code>applyDamage: function(amount) {
  var newHealth = this.health - amount;
  this.raiseServerEvent('CraftDamaged', newHealth);
},
onCraftDamaged: function(newHealth) {
  this.health = newHealth;
  if(this.health &lt; 0)
   this.raiseEvent('CraftDestroyed');
}
</code></pre>

<p>Regardless of client or server, this logic would get executed - but only on the server would the event actually get raised when a craft lost health, and that event would automatically be proxied to all the clients for the rest of the logic to be executed.</p>

<p>This leaves me with:</p>

<pre><code>/craft/
/craft/firingbehaviour.js
/craft/dyingbehaviour.js
/craft/lockingbehaviour.js
</code></pre>

<p>Because this was back-patched in over a weaker system, there are some remnants of this change left over the Hoverbattles source, but it is a lesson I'm applying in the new game to really good effect. </p>

<p>The network code in the latest project consists of about three objects primarily just routing commands and events and it is most likely going to stay that way.</p>

<p><strong>Arrays are mutable reference types</strong></p>

<p>Duh. we all know that, why bother including it? Well - remember I said that creating new objects is expensive so I was sharing them? Yeah - well that can bite too, and given that this was one of my recurring bugs (my own stupidity granted) it's worth documenting.</p>

<p>In C#, typically you don't expose mutable reference types, you'd return an IEnumerable<T> if you wanted to expose a collection from an object, which is a read-only collection fit for... well reading from the consuming code.</p>

<p>Can't quite pull off that trick in JavaScript (although the solution could exist in user-land it's a bit of a faff as it's not transparent). </p>

<p>The problem is, in a game like Hoverbattles - half of our state is in fact arrays of either length of '3', or length of '16' (vectors and matrices) and we have to be careful when receiving a vector or matrix that we don't own. Consider the following simplified code, which is <em>reminiscent</em> of an actual bug I had in Hoverbattles.</p>

<p><em>Player</em></p>

<pre><code>moveLeft: function(amount) {
  this.position[0] -= amount;
  this.raiseEvent('Moved', this.position);
}
</code></pre>

<p><em>Enemy</em></p>

<pre><code>onPlayerMoved: function(newPosition) {
  this.playerPosition = newPosition;
},
doSomeLogic: function() {
   // Some calculation that indirectly modifies the array
   this.playerPosition[0] += 5;
}
</code></pre>

<p>Okay, the above is quite obvious, but this kind of thing happened (in substantially more convoluted scenarios) with the outrageous result of player craft ending up where they should not be. (Especially in the network code where objects are receiving new state a lot of the time).</p>

<p>The answer is, if you're receiving an array from an event or command, to copy it over to your own internal value if you want to keep the state around for any length of time for future processing. (Ignore this at your peril unless you're smart and/or have lots of tests).</p>

<p><strong>Push it to the GPU</strong></p>

<p>Hoverbattles first particle system was written on the CPU, and looked something like this:</p>

<pre><code>var ParticleEngine = function(count) {
  this.particles = new Array(count);
  for(var x = 0; x &lt; count ; x++) {
    this.particles[x] = {
      x: 0,
      y: 0
      velx: 0,
      vely: 0
    }
  }
};

ParticleEngine.prototype = {
  update: function() {
    for(var x = 0; x &lt; count ; x++) {
      this.particles[x].x += this.particles[x].velx;
      // etc
    }
  }
};
</code></pre>

<p>Yeah, this didn't go too well - I wanted... no, I needed many thousands of particles, and blocking the event loop on the browser by looping through large collections of objects is a big no no.</p>

<p>If you can push processing from the CPU on the browser, to the GPU using shaders, then you should, JavaScript is slow and not a suitable place to be playing with large loops of data.</p>

<p>Besides, <a href="http://en.wikipedia.org/wiki/GLSL">GLSL</a> is quite a pretty language to do it in:</p>

<pre><code>void main(void){

    float age = (time - aCreationTime);
    vec3 position = aVertexPosition + (aVelocity * age);
    vColour = aColour;

    vec3 vectorToPoint = (position - vCamera);
    float distanceSquared = abs(dot(vectorToPoint, vectorToPoint));
    float scale = clamp(distanceSquared, 1.0, 10000.0);      

    life = 1.0 - (age / aLifetime);
    life = clamp(life, 0.0, 1.0);

    gl_PointSize = (aSize * maxsize) / (scale / 100.0);
    gl_Position =  uProjection * uView * vec4(position, 1.0);
}
</code></pre>

<p><strong>Relax</strong></p>

<p>Finally - <a href="http://codeofrob.com/entries/a-relaxed-attitude-towards-the-pragmatic-delivery-of-okay-software.html">something I covered previously</a> - relax, there is no problem you cannot solve with a bit of patience, re-factoring, profiling, and debugging. :-)</p>


]]></description><link>http://codeofrob.com/entries/lessons-learned-building-a-multiplayer-game-in-nodejs-and-webgl.html</link><guid isPermaLink="true">http://codeofrob.com/entries/lessons-learned-building-a-multiplayer-game-in-nodejs-and-webgl.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 19 Mar 2012 12:00:00 GMT</pubDate></item><item><title><![CDATA[Your container is not wanted here]]></title><description><![CDATA[<p>Finding myself embroiled in yet another debate about IOC containers on Twitter I've decided to place my current thoughts here for posterity.</p>

<p><em>I don't really like using IOC containers</em></p>

<p>There, I said it. I really don't. I used to, I did - I thought they were an excellent way to manage those dependencies, to push the effort of lifetime and scope management into something that would automatically handle those things for me so I wouldn't have to think about them.</p>

<p>I thought they were an excellent way to bootstrap of my entire application from a single place, and have all the interfaces matched with their single implementations and pushed into the relevant consumers without having to think about it.</p>

<p>But you know what? Having your entire application sucked out of a black box and then writing rules for the exceptions to those wonderful conventions and then writing new conventions and interceptors and using all the "wonderful features" of the modern IOC container started to lead to developers spending more time debugging mysterious container issues and fighting odd/conflicting lifetime issues than writing code of real value.</p>

<p>Oh, you could easily dismiss this with "Oh, Rob doesn't know how to use a container properly", but you'd be missing the point, because even if I didn't (<em>and I do by the way</em>), it's irrelevant whether I do or not.</p>

<p><em>Missing the point</em>? Missing the point because nearly every team using an IOC container <strong>IS</strong> doing it wrong, and they're doing it wrong because they <em>are</em> complicated and they give you a lot of "extensibility points" to make it <em>easy</em> to do things like interception, they make it <em>easy</em> to do things like per-request items, they make it <em>easy</em> to create singletons that aren't really singletons. and they make it <em>easy</em> to create lots of interfaces that get sucked into lots of classes (in the name of low coupling, and usually with the result of a total lack of any cohesiveness).</p>

<p><strong>It's putting the cart before the horse</strong></p>

<p>Learn to walk before you run, cart before horse, etc. The fundamental issue here, is that people are spending their times learning about IOC containers, gaining some level of test-ability because everything is an interface that talks to other interfaces via interfaces to interfaces. This is not to say that IOC containers cause this explicitly, because if you've already got a grasp of OO concepts then you aren't going to do too much damage here (except for hiding simple concepts like lifetime management up behind infrastructure that's a bit more future-career-proof).</p>

<p>My fundamental issue is that not enough time is being spent by developers learning how to just grow a testable and maintainable code-base. Throwing your lot in with a container with a centralized bootstrap process and claiming that's an advantage is missing out on a fundamental aspect of clean software development - that is, neat little packages that know how to bootstrap themselves and expose a sensible API for doing so - allowing them to be used across the code-base in an understandable and idiomatically crafted way.</p>

<p>Allowing your junior developers to "not worry about these things", because the almighty and all-knowing container will look after them and ensure that the code is testable, and that dependencies will just work automatically is simply shirking the responsibility of actually teaching those developers the useful and transferable skills that will help them deliver products across a multitude of languages and platforms. (EG. not just the two that come with a million IOC containers to choose from).</p>

<blockquote>
  <p><em>In GOOS we are extremely explicit about scope!  Java is a block</em>
<em>structured language with lexical scoping, closures and objects.</em>
<em>Blocks and objects are scopes. Variables declared in a block and</em>
<em>instance variables declared in an object are in a scope. There is no</em>
<em>need to re-implement (badly) what the language (compiler and VM)</em>
<em>already provide.</em></p>

<p>Nat Pryce</p>
</blockquote>

<p>And this, is what I believe that it all boils down to.</p>

<ul>
<li>You want per-request scoping? That's a "using statement" around the entry point to that request. </li>
<li>You want application-lifetime scoping? Just create the object on start-up and let it get cleaned up on application-close</li>
<li>You want something more fine-grained? That's just another using statement around the code concerned.</li>
</ul>

<p>Objects still don't need to know about their own scoping, of course not, and we realized that with containers early on with the removal of attributes from most frameworks. But why make all the effort of pushing scoping into a framework when it is such an intrinsic part of your application and it's relatively trivial to manage anyway? Lifetime management is not an implementation detail to be pushed away into central infrastructure code, and nothing but trouble will be had from trying to work that way <em>(nested sub-containers anyone? No - I thought not).</em></p>

<p>You want to talk about writing masses of boilerplate code? I have very little in the applications I'm actively developing now - each abstraction developed is responsible for its own set-up, and only exposes to the outside world any configuration needs that it might require and the public interfaces required to do its job. That code is written and tested <em>as part of the code-base</em>, is compile safe and is fast to bootstrap because "it's just code". Abstractions are built on top of other abstractions and are tested against other abstractions with appropriate levels of isolation depending on the test concerned and there are no problems here at all.</p>

<p>This approach does not preclude the injection of dependencies into say, the subsystem which might be created as a consequence of its construction, it merely hides that detail behind an appropriate API because the consumers of this package don't typically care about that construction.</p>

<p>You want to talk about managing deep or complex object graphs? That's not a problem - each package is only ever going to have a shallow object graph, because that's sensible software design - I don't have complicated object graphs because complicated object graphs tend to show themselves during testing and are very quickly turned into simple object graphs.</p>

<p>It's just software, and we should be spending more time learning how to deliver software and less time learning how to manipulate favourite container X.</p>


]]></description><link>http://codeofrob.com/entries/your-container-is-not-wanted-here.html</link><guid isPermaLink="true">http://codeofrob.com/entries/your-container-is-not-wanted-here.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 02 Feb 2012 12:34:00 GMT</pubDate></item><item><title><![CDATA[What does it look like when I code?]]></title><description><![CDATA[
		<p>Something like this</p>

<object width="1280" height="720"><param name="movie" value="http://www.youtube.com/v/mp_nxjhx6yY?version=3&amp;hl=en_US&amp;rel=0&amp;hd=1"><param name="allowFullScreen" value="true"><param name="allowscriptaccess" value="always"><embed src="http://www.youtube.com/v/mp_nxjhx6yY?version=3&amp;hl=en_US&amp;rel=0&amp;hd=1" type="application/x-shockwave-flash" width="1280" height="720" allowscriptaccess="always" allowfullscreen="true"></object>

<p>This is a time-lapse of me creating a game over 48 hours (a weekend), overall there is about 30 hours of screen-time packed into 3 minutes of video - it's cool to see how the game and code progress over those 30 hours.</p>

<p>What is interesting is how I always have the social elements open in a browser window on my left hand side, I'd never noticed it before - I don't think it slowed me down any - the pauses where I wasn't coding I was up making coffee or thinking about a problem</p>

<p>Still, it would be interesting to see how I'd get on without it if I was doing another of these - the next rendition of the competition is next March and I think I'll be doubling my efforts to create something cool - I might even go as far as to do a 3D effort in WebGL</p>
	]]></description><link>http://codeofrob.com/entries/what-does-it-look-like-when-i-code.html</link><guid isPermaLink="true">http://codeofrob.com/entries/what-does-it-look-like-when-i-code.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 20 Dec 2011 17:47:00 GMT</pubDate></item><item><title><![CDATA[Hoverbattles Released (and more)]]></title><description><![CDATA[
		<p>I've gone off on a tangent recently and been playing around with games development as if I was 15 again</p>
<p>I think I'm going to make a game that I actually want people to play next, but first up - three things I've released recently</p>
<h4>Hoverbattles</h4>
<p>My flagship 'game', something I've learned a <strong>lot</strong> from these past couple of months - written with a NodeJS back-end, with WebGL front-end, the code is awful in places and I think I have a few memory leaks (or third party libs do!) but I'm pretty much done with this now.</p>
<p><span style="font-weight: bold;">Note: The server this is on is not brill, so there will be lag</span><br>
</p>
<p>This can be found at <a href="http://hoverbattles.com">http://hoverbattles.com</a> - fill your boots.</p>
<p>Source can be found at <a href="https://github.com/robashton/HoverBattles">https://github.com/robashton/HoverBattles</a></p>
<p> </p>
<h4><img width="800" height="479" alt="" src="/images/codeofrob_com/hoverbattles.png"></h4>
<h4>Plane Thinking</h4>
<p>I coded this over a few days as warm-up for LD22, the 48 hour games development challenge, this is plain old Canvas (although I was playing with using WebGL to do progressive enhancement it turns out that copying buffers between the two gets expensive quickly and I didn't take it much further</p>
<p>This should work in most browsers, I really should make the effort to get it working with touch controls as it would work well on iPad</p>
<p>This can be played at <a href="http://planethinking.heroku.com/">http://planethinking.heroku.com/</a></p>
<p>Source can be found at <a href="https://github.com/robashton/plane-thinking">https://github.com/robashton/plane-thinking</a></p>
<p><a href="https://github.com/robashton/plane-thinking"><img width="800" height="650" alt="" src="/images/codeofrob_com/plane-thinking2.png"><br>
</a>  </p>
<h4>You don't have to be alone</h4>
<p>This is my entry to the 48 hour game development competition Ludum Dare - I don't really think of this as competing with anybody else, trying to build a game from scratch over 48 hours is <strong>mega hard</strong> and I'm really proud that I was able to pull it off with plot, sound, music and alternative ending galore</p>
<p>The code for this is ... suboptimal, if you play it on anything other than a really high end desktop computer in any other browser than Chrome then do so at your peril. I'll be learning from that in my next game and making an effort to keep those render calls down</p>
<p>The game can be found at: <a href="http://ld22-ashton.heroku.com/">http://ld22-ashton.heroku.com/</a></p>
<p>The source can be found at: <a href="https://github.com/robashton/ld48_22">https://github.com/robashton/ld48_22</a></p>
<p><a href="https://github.com/robashton/ld48_22"><img width="1082" height="949" alt="" src="/images/codeofrob_com/update-10.png"><br>
</a></p>
<h4>The point of all this</h4>
<p>Games development is complicated, the code in Hoverbattles is probably the most complex domain I've ever worked on, and finding ways to keep the accidental complexity low whilst keeping the technical complexity low at the same time was a big challenge</p>
<p>I've learned a lot by stepping away from ordinary business app development, and I'll be taking that back to the workplace with me, as well as carrying on in this space - never before has there been a better time for aspiring games development to noodle on in their spare time.</p>
<p>This site? Yeah I've messed this up a bit - I need to rip all these posts out and deploy them as static content and set up some re-directs, a project for a rainy weekend when I don't want to play with games :-)</p>
<p>Merry Xmas</p>
<p>Rob</p>
	]]></description><link>http://codeofrob.com/entries/hoverbattles-released-and-more.html</link><guid isPermaLink="true">http://codeofrob.com/entries/hoverbattles-released-and-more.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 20 Dec 2011 15:28:00 GMT</pubDate></item><item><title><![CDATA[A relaxed attitude towards the pragmatic delivery of 'okay' software]]></title><description><![CDATA[
		<strong>A brief middle-of-project retrospective</strong>
<p>I've not been coding in my spare time much the past few months, being seriously busy for a client - but the past couple of weeks has seen me pick up a project of mine that I started a few months ago (HoverBattles) and start pushing to some level of completion.</p>
<img width="800" height="451" alt="" src="/images/internal_codeofrob_com/currentproject.png">
<p>This has been an interesting project for me, not least of all because it's written entirely in Javascript (WebGL + JS, NodeJS and CouchDB) but because this time I made a real effort to drop any up-front <em>'zomg my code must be perfect'</em> aspirations from the get go.</p>
<p>What does this mean? Well I pretty much decided that technical debt should not be something to be overly avoided, overly organised code-bases stifle creativity and I really just wanted to <strong>deliver something.</strong></p>
<p>I also knew that as I learned more about effective JavaScript that my opinions on the 'best way to achieve things' would be changing about 20x more rapidly than it does when working in an environment I'm heavily used to, and trying to constantly maintain code at some mythical standard would prevent me from actually delivering</p>
<p>A couple of months later how does that leave me? Is the code-base a huge unmaintainable mess? I would say no - it is not. </p>
<p>There are messy bits in there but they're largely on the periphery. An avoidance of up-front framework/empire building has allowed me to be morally flexible with regards to where I put new code to Get Cool Stuff Done, and a healthy concern when going over pre-existing code to add something new has led to some easy wins when re-factoring around the pain points that naturally emerge.</p>
<p>I don't think that I've taken a cavalier approach to the project - at a macro level it's quite well structured, and for the most part there is a clean separation between the different sub-components that drive the system. In a code review there are bits I'd have to apologise for but even in projects with the greatest amount of technical debt avoidance this has been true.</p>
<p>There are some problems with the messaging/multi-player side of things, complex work-flows have emerged as a consequence of the individual components receiving some input, doing something and raising some output in orders that I did not pre-plan.</p>
<p>This has been made more complicated by the fact that some of these components only exist on the server, and yet the events they raise are still sent to the client because the client needs to react even if it is not the one doing the critical thinking.</p>
<p>This is an example of what I have come to classify as a <em>real problem</em> - that is, it is a problem that is naturally occurring and isn't one I have constructed to satisfy the whims of my inner Powerpoint Architect.</p>
<p>When I think of all the things that we work on in our line of business applications, the efforts we go to de-couple everything so it can be easily tested and maintained, the efforts we go to make sure we have the extensibility points and have our "what ifs" covered, I'm seeing a lot of that in a new light as this project goes on. </p>
<p>I don't think a lot of our 'units' in our LOB world are really units at all, they're fractions of 'units', and it's only as part of a more complex interaction that things get interesting and worth spending time fussing over.</p>
<p>Even those seeking to do more vertical testing of a unit within their system (across several internal components) aren't really testing anything meaningful, they're not really spending their time on anything really meaningful either - I wonder if we do a lot of this stuff just to make our jobs more interesting because LOB apps are at a micro-level... quite boring</p>
<p>Anyway I digress, a response could be that some of that rigidity and forward thinking is needed because we have more than one soul working on these projects and if everybody took the cavalier 'get it done' attitude we'd end up with a big mess right?</p>
<p>I'm not convinced - I think that if you have a team that can actually communicate and react to problems as they arise that a good momentum would still be possible, a lot of the technical solutions delivered in these LOB apps seem to exist as a way of avoiding the need for communication and I'm beginning to think of that as less okay than I did</p>

<p>I'm also beginning to think that a concentration on these things causes bigger balls to be dropped. There is little point in arguing over patterns if you're going to forget to apply sanitisation to user-provided input for example - or suitable defensive mechanisms against things that might go wrong (as dirty as that might make some of your code).</p>

<p>Going back to the whole CQRS thing as that was the topic of the last post, this ties in well - those things exist as solutions to complexity that already exists - not as ways of creating complexity that wasn't there before. Technical solutions should be avoided unless they're actually delivering the necessary value.</p>
<p>Random blathering I know, I'll actually start talking about the tech in the game soon I think, it's getting interesting and I think there are some things to say about it</p>
	]]></description><link>http://codeofrob.com/entries/a-relaxed-attitude-towards-the-pragmatic-delivery-of-okay-software.html</link><guid isPermaLink="true">http://codeofrob.com/entries/a-relaxed-attitude-towards-the-pragmatic-delivery-of-okay-software.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 01 Nov 2011 11:37:00 GMT</pubDate></item><item><title><![CDATA[CQRS is too complicated]]></title><description><![CDATA[
		<p>Is something I hear all too often at conferences and on Twitter, and more often or not it is said because of either a basic misunderstanding of what CQRS is or is not - or perhaps because they've dipped their toes into the hyperactive DDDCQRS mailing list and been scared away by all the white coat discussion that goes on in there a lot of the time.</p>
<p>The other day, the sentiment was yet again voiced by somebody of whose opinion I respect on Twitter and I ended up in about five minutes writing a gist explaining why I didn't think this was the case (Writing 4000 word essays is an hour's work if I'm feeling ranty), I've tidied it up a bit and decided to throw it below as it works well in a blog entry.</p>
<p><strong>A basic summary</strong></p>
<p>At the highest level CQRS just means maintaining a happy division between the reads and writes across your system - that is, having the reads in your system executed in a thin clean manner appropriate to the views you want to retrieve (one model), and your writes going through all the crazy logic you need such as validation, updating queues, third party systems, processing business rules (another model)</p>
<p>Consider the traditional and very-tongue-in-cheek N-Tier architecture I have created here in powerpoint, seen in a million "architecture" presentations in ASP.NET webforms shops across the world:</p>
<p>&nbsp;<img alt="" width="400" height="326" src="/images/internal_codeofrob_com/1.png"></p>
<p>Now modify it a little bit so that our reads haven't got to go through all that cruft, haven't got to somehow amene themselves to a bunch of "DAL objects" that are created with the very&nbsp;best intention of standardising our access to some form of database (and normally optimised for the write actions anyway).</p>
<p><img alt="" width="400" height="310" src="/images/internal_codeofrob_com/2.png"></p>
<p>We can&nbsp;instantly make our lives a lot easier by creating a pile of code optimised for creating views for our presentation layer,&nbsp;perhaps doing a bit of raw SQL or calling a sproc to generate the view for us. We can helpfully formalise this arrangement and for the most part set down a rule that the direction of travel down those two paths is one way (towards the DB for writes and away from the DB for reads).&nbsp; Funnily enough - most systems that do that <strong>BOL</strong>/BLL/DAL<strong>/OCKS</strong> stuff end up with something that looks like this anyway because it's too hard to do everything through a single model.</p>
<p>This is now a form of CQRS - at the highest level we've effectively split our system into two models&nbsp;and done something that's very similar to what we'd call CQS if we were&nbsp;doing it at the method level.&nbsp; This in itself should surely be enough to convince you&nbsp; that CQRS itself is not complicated and it might be a useful thing to look further into.</p>
<p>Of course, as you go further down the rabbit hole...</p>
<p><strong>Some examples</strong></p>
<p>CQRS can be achieved by using a document database like Raven or Couch - using your documents as a write store, using your indexes as a query store. </p>
<p>&nbsp;<img alt="" width="400" height="299" src="/images/internal_codeofrob_com/32.png"></p>
<p>It can be achieved with your favourite ORM (Even better if you can actually use that O and that M and get some good old OO going) - if you want to use your objects for encapsulating business logic and go directly to the the queries to project the data you need for views (HQL, SQL directly, SPROCS, whatever) - from the same database even, providing this remains efficient enough for your needs. <em>(Funnily enough, "our" collective weak attempts at creating domain models with NHibernate are what led to us re-discovering the need for two models in the first place in my opinion).</em></p>
<p>&nbsp;<img alt="" width="400" height="312" src="/images/internal_codeofrob_com/4.png"></p>
<p>Of course you may well end up with two databases anyway, as trying to query a database comprised of tables that represent state in your "objects" can be pretty inefficient, with the read store updated from the write store using hooks in your write system to generate pre-calculated views or data that's more applicable to generating views - this is not a bad model and can work too, it's still CQRS.</p>
<p>&nbsp;<img alt="" width="400" height="319" src="/images/internal_codeofrob_com/5.png"></p>
<p>CQRS gets the "complicated" label because people often associate it directly with event sourcing, which requires that little bit more of up-front development in order to get the level of elegance you won't find in the above scenarios. However, even event sourcing is really simple once you look at it - and is a natural progression from some of the other ways of "doing" CQRS - which can be a bit muddy (not that there is anything wrong with systems that are a bit muddy). <em>Note that I'm not mentioning DDD here At All - which is where a lot of heavy&nbsp;learning lies, and nearly none of us do anyway.</em></p>
<p>Consider hooking those events in your system to manually flatten/re-arrange data into other stores as outlined above? Does that work for that one other store? How about a reporting store? How about full text search? What about integration with third party systems and the data they want to see from you? How about the boardroom reports your CEO now wants on his desk each morning before he starts his day?</p>
<p><img alt="" width="400" height="351" src="/images/internal_codeofrob_com/6.png"></p>
<p>Youch. Deciding your single source of truth is the already written state gives you an amount of inflexibility, which you may or may not be happy with&nbsp;up to a point.</p>
<p>Updating other views of this truth after small changes can be inefficient&nbsp;and awkward. Recovering after introducing any write bugs to the system can be expensive also. Hell - even changing your model can also be expensive as database migrations are hardly the easiest things if you're trying to work with multiple stores and layers all over the place. When your powerpoint presentations start looking like this you have&nbsp;complexity issues- and these complexity issues aren't caused by CQRS, they're caused by having complex powerpont presentations.</p>
<p>Moving to events and jumping through a few hoops to make this possible <em>can</em> open up a world of simplicity, and if it's not for you there are other options open to you. CQRS is not complicated - trying to shoehorn the responsibilities of read and write through a single model is complicated. Most of us realise that going through a standard "BLL, DAL, BOL, TLA, CRA, P) layer for both reads/writes is dumb, and CQRS is a good way of formalising this decision.</p>
<p><strong>Another tdlr;</strong></p>
<p>You can see that clearly there is a natural progression from the very basics to having the need to go for a full blown event sourcing system with publishers/subscribers/servers/eventual consistency once the complexity of trying to manage a more "simple" solution starts to overwhelm.</p>
<p>Unless you have that complexity and&nbsp;that need&nbsp;then of course trying to thrust an ivory tower designed architecture onto a system that doesn't need it is going to seem complicated. Hint: If your technical solution is more complicated than your original problem you're probably doing it wrong.</p>
<p><a href="http://cre8ivethought.com/blog/index"><img alt="" width="500" height="405" src="/images/internal_codeofrob_com/DDDOverview_big.jpg"></a></p>
	]]></description><link>http://codeofrob.com/entries/cqrs-is-too-complicated.html</link><guid isPermaLink="true">http://codeofrob.com/entries/cqrs-is-too-complicated.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 28 Sep 2011 19:45:00 GMT</pubDate></item><item><title><![CDATA[RavenDB Consultancy]]></title><description><![CDATA[
		<p>I've been contacted quite a bit this past month with requests for workshops and short term consultancy on RavenDB - I'm thrilled to bits that the database seems to be taking off in this way and I'm all about helping this happen.</p>

<p>The short answer is yes, I am happy to come and do private workshops tailored around your company's needs with RavenDB, I am also happy to offer remote or on-site consultancy where appropriate/desired.</p>

<p>If you've too been wondering about this but not known where to look, just e-mail me at <a href="mailto:robashton@codeofrob.com">robashton@codeofrob.com</a>, I don't bite.</p>

<p>That's about it really, I'll use this space to say that I'm now nearly settled in Belgium on a long term project for a client and I'm ready to commence blogging again, I've a few things I want to cover with RavenDB in particular but I'll most likely be doing that over at <a href="http://codebetter.com">codebetter.com</a></p>
	]]></description><link>http://codeofrob.com/entries/ravendb-consultancy.html</link><guid isPermaLink="true">http://codeofrob.com/entries/ravendb-consultancy.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 05 Aug 2011 11:48:00 GMT</pubDate></item><item><title><![CDATA[SLJS.org - a Silverlight - Html/JS converter]]></title><description><![CDATA[
		<p>At NDC2011 I was chatting to some folk who work on various OSS projects about cool things we could potentially work on in the future, and the topic of a Silverlight -&gt; Web converter came up</p>

<p>TLDR: Click <a href="http://sljs.org">here</a> to see the demos, click <a href="http://github.com/robashton/sljs">here</a> to see the code, click <a href="http://groups.google.com/group/sljs">here</a> to view the Google Group.</p>

<p>I had thought about this before, but it is only recently that an IL converter appeared up that I deemed fit for this purpose (<a href="http://jsil.org">JSIL</a>), and it is after this conversation I decided to put words into action</p>

<p>To this end, I have spent the past few weeks diving into the various concepts in Silverlight and spiking out implementations for converting them to make sure that the vast majority of what I wanted was actually possible</p>

<p>And that leads us to this, <a href="http://sljs.org">SLJS.org</a>, home to where I've gotten so far, with a couple of demos showing off what it can do. More to be added as we go along.</p>

<ul>
<li>Here is a basic example of an application in action: Hello World (<a href="http://sljs.org/output/HelloWorld/HelloWorldTestPage.html">Silverlight</a>, <a href="http://sljs.org/output/HelloWorld/index.html">HTML</a>)</li>
<li>And here is something demonstrating some more SL concepts: Calculator (<a href="http://sljs.org/output/Calculator/CalculatorTestPage.html">Silverlight</a>, <a href="http://sljs.org/output/Calculator/index.html">HTML</a>)</li>
</ul>
<p>Truth be told I'm largely doing this for fun and education at the minute, although I know a few people who actually want to use it - not to convert legacy projects, but to write new code in their familiar Silverlight world and have it work in a browser without requiring a plug-in.</p>

<p>I'm happy to support that, but it should be a community effort, rather than me blindly just working on features for the sake of it (although I have a little more of that left in me before I start taking on feature requests!)</p>

<p>So far the following has been implemented</p>

<ul>
    <li>Bootstrapping a converted Silverlight application in JavaScript
    </li><li>Responding to changes of the root UI element</li>
    <li>Rendering a control hierarchy from the root UI element</li>
    <li>Rudimentary Dependency Object and Dependency Property support</li>
    <li>Listening for changes on Dependency Properties to update styling</li>
    <li>Listening for changes on Dependency Properties to update content</li>
    <li>A templating system for customizing the output from each control</li>
</ul>

<p>On my immediate road-map (so in the coming week), I'll be working on:</p>

<ul>
   <li>Rudimentary data-binding support (A spot of MVVM coming up)</li>
   <li>Converting styles to CSS</li>
   <li>Going through System.Windows.Controls and creating the outline for them in JS</li>
   <li>Forcing some layout concepts into HTML from Silverlight</li>
   <li>A preliminary investigation into attached dependency properties</li>
</ul>

<p>I would totally appreciate some help/feedback/pointers for the direction of the project/cheering from the sidelines etc</p>

<p>The last one is important actually, if y'all tell me you find this interesting then I'll carry on working on it, if nobody gives a crap then when I get bored I'll stop :-)</p>

<p>But yeah, just joining the <a href="http://groups.google.com/group/sljs">Google Group</a> and helping me build a road-map would be a good start</p>
	]]></description><link>http://codeofrob.com/entries/sljs.org---a-silverlight---html-js-converter.html</link><guid isPermaLink="true">http://codeofrob.com/entries/sljs.org---a-silverlight---html-js-converter.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 30 Jun 2011 08:29:00 GMT</pubDate></item><item><title><![CDATA[5 reasons to give node.js some love]]></title><description><![CDATA[
		<p>In response to a question from a friend on Twitter (Private account so no linky), but with the text: </p>

<p>"Been reading up a little bit on node.js @robashton @domgreen. What makes it stand out from alternatives or is it just a JS 'me too' play?"</p>

<p>My initial response was, hey - you know what? I can't think of any (popular) alternatives that provide the unique combination that node.js does, and then started writing a torrent of tweets describing why I personally am so excited about node.</p>

<p>Then I decided that rather than spam Twitter, I should write a blog post to link to when asked the same question in the future.</p>

<p>Every bugger has already done one of these, but I want to answer the question in my own personal way</p>

<b>1) You get to write Javascript on the server and the client</b>

<p>Think about this for a second - it's really not just a gimmick (although some people seem to think it is). Even in a simple web application you're going to have validation logic that you're going to want to execute on the client AND on the server, and usually this can't be shared without going through some sort of rules engine or crazy framework to spit out some rough client-side equivalents. </p>

<p>No need with node, you can write your model (complete with business rules, etc), and write a nice task-based user interface around that model, running it all locally in the browser, and then dispatching and validating the commands on the server - because hey, everything is just JSON at the end of the day, and everything you're writing works against that.</p>

<p>Take this a step further, and consider that we have some pretty awesome document databases on the scene at the moment whose primary communication and storage mechanism is - guess what? JSON (well BSON) - at no point during any of this do you need to sit there dealing with mapping frameworks or hand-written mapping code, because you're just flinging JSON around.</p>

<p>With efforts on <a href="http://www.commonjs.org/">CommonJS</a> and <a href="https://github.com/sstephenson/stitch">Stitch</a> ongoing, there is really no excuse for not writing all your JavaScript in a state where it can be executed on both the client and the server.</p>

<b>2) Event-based asynchronous stuff is just How Things Work in JavaScript </b>

<p>Yeah okay, I have no idea what I'm talking about here, but what I do understand and what most people who have been writing JavaScript for the past decade understand is that <i>your</i> JavaScript tends to execute on a single thread and long-running processes get dealt with by the host, using callbacks to notify you (back on that single thread) as and when those things are done.</p>

<p>Now, in the browser these long-running requests are limited to... well HTTP calls to the server to get/post data, but on the server we do nearly <i>everything</i> like this; requests to other machines, requests to the file system etc.</p>

<p>We don't need any crazy language keywords (looking at you C#), we don't need any crazy Task of X/Y and Z objects (Looking at you C#), we just need: </p>

<script src="https://gist.github.com/949550.js?file=gistfile1.js"></script>

<p>This gives us some brilliant performance benefits, dealing with potentially gazillions of connected clients an <a href="http://www.theregister.co.uk/2011/03/01/the_rise_and_rise_of_node_dot_js/">easy possibility</a> <i>Sorry for a "the register" link this early in the morning, it's a bit indecent of me.</i></p>

<p>This also makes dealing with concurrency (at least within a single process) really easy too, all your variables are safe to be accessed at any time as you haven't got any potential race conditions, you can mutate state all you want and not worry that somebody else is going to come along and take away your cheese.</p>

<p>Hell, even the plans for future-node seem to be keeping this philosophy intact, with multiple node processes being given a way to communicate safely (or at least as far as I understand the slides that I've read from conferences I wasn't at).</p>

<b>3) Awesome package management!</b>

<p>Just like Ruby, and just like Linux-land in general, if you want to do something there is probably a library/package waiting for you to pull down and consume, and you can do this via the wonderful magic of <a href="http://npmjs.org/">NPM</a></p>

<p>npm install socket.io</p>

<p>It's that easy to get the libraries you need, and there are libraries available for most of the things you can think of, the primary ones I am using myself are: </p>

<ul>
     <li><a href="https://github.com/felixge/node-paperboy">Paperboy</a> - for simply serving static files from a directory (index.html, style.css, etc</li>
     <li><a href="https://github.com/donnerjack13589/node.gzip">gzip</a> - for um, gzipping content that I send down to the client</li>
     <li><a href="http://socket.io/">socket.io</a> - for magically doing websockets, or at the very least emulating websockets</li>
     <li><a href="https://github.com/tmpvar/jsdom">jsdom</a> + jquery - manipulating the DOM server-side? Oh say it ain't so?</li>
     <li><a href="https://github.com/sstephenson/stitch">Stitch</a> for allowing me to write code in CommonJS format and still use it in the browser.</li>
</ul>

<p>This isn't anything particularly unique to node, but in this day and age it's a bit hard to be taken seriously without a good package manager in your ecosystem and it's good to see something of quality here.</p>

<b>4) Community community community</b>

<p>The community around node.js is brilliantly active, passionate and y'know - generally quite bright - and willing to try new things out (Kinda goes with the territory really)</p>

<p>This, just like Ruby, is a really big draw for those of us from ecosystems which... lack anything of this scale</p>

<p>This enthusiasm does make it a bit difficult to separate actual innovation occurring from the old "Look at JavaScript doing what everything else has been able to do forever", but I'll take raw enthusiasm over rigid nay-say mentality any day - enthusiasm is contagious and gives me the ability to Get Things Done</p>

<b>5) It's easy, really easy, like super easy, We can all do it!</b>

<p>JavaScript aside (And if you don't like JavaScript you can always use CoffeeScript), the process of writing code that does exciting stuff is ludicrously simple.</p>

<p>Having direct access to the HTTP pipeline, and not hiding it behind crazy levels of abstracted framework cruft is a big, big win - and once you start writing code like this you start to wonder where this kind of thing has been all your life.</p>

<p>"I want to do this: " has not once resulted in me banging my head against the constraints and limitations that somebody else has put in my way (supposedly to help me).</p>

<p>My personal website currently runs on pixie dust and grated unicorn horns - I'm pulling in content from my old subtext blog and spitting it out on the front page (with plans to pull in content from <a href="http://codebetter.com/robashton/">CodeBetter</a> and <a href="http://altdevblogaday.org/author/rob-ashton/">Altdevblogaday</a> too), whilst acting as a reverse proxy for the old site (in very few lines of code). </p> 

<p>That's utterly crazy, and I drafted it up in just a few hours of hackity hack hack hacking, with those goals in mind.</p>

<b>Anyway...</b>

<p>The beauty of node comes in the combination of these attributes, not just one thing (because none of those things bar point #1 are by themselves particularly new or ground breaking</p>

<p>If you've previously dismissed node as something pointless because you think it brings nothing new to the table compared to your X, Y or Z then I urge you to have another look at it, as The Creators prepare to bring it natively to Windows it's only going to get more popular and you'll want to be involved.</p>

	]]></description><link>http://codeofrob.com/entries/5-reasons-to-give-node.js-some-love.html</link><guid isPermaLink="true">http://codeofrob.com/entries/5-reasons-to-give-node.js-some-love.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Sat, 30 Apr 2011 07:39:00 GMT</pubDate></item></channel></rss>