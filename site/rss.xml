<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>NodeJS RSS Module</generator><lastBuildDate>Fri, 28 Jun 2013 11:09:25 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Change it Up - A Tekpub thing]]></title><description><![CDATA[<p>Just a small thing and a moderately embarassing one at that.</p>
<p>While I was in Hawaii towards the <a href="/entries/i-am-interested-in-talking-about-work.html">end of my travels</a> this year, I got coralled into doing an interview about <a href="/entries/i-am-not-looking-for-a-job.html">why I did what I did</a> and what prompted me to take action about &quot;changing things up&quot;.</p>
<p>If you know me personally, then there is probably not anything too new in this video, but if you&#39;re interested in the thought process behind &quot;getting out of that rut&quot; and you&#39;re considering doing something about it yourself, I&#39;ve been told that this video will help :)</p>
<p>You can find it at Tekpub over at <a href="http://tekpub.com/products/change-it-up"><a href="http://tekpub.com/products/change-it-up">http://tekpub.com/products/change-it-up</a></a>. If you haven&#39;t got a subscription then you should just go and get one, as Tekpub is pretty rad.</p>
]]></description><link>http://codeofrob.com/entries/change-it-up---a-tekpub-thing.html</link><guid isPermaLink="true">http://codeofrob.com/entries/change-it-up---a-tekpub-thing.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 28 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Learn functional programming with me - more idiomatic Clojure]]></title><description><![CDATA[<p>I went through my code in the last entry and did a bit of re-factoring in an effort to get my state under control, I&#39;ve also had some feedback that some of my Clojure could be a bit more idiomatic so let&#39;s sort that out.</p>
<ul>
<li><a href="/entries/learn-functional-programming-with-me---a-mission-statement.html">Mission statement</a></li>
<li><a href="/entries/learn-functional-programming-with-me---drawing-a-square.html">Drawing a square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---moving-the-square.html">Moving the square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---attributes-and-vectors.html">Attributes and vectors</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-my-workflow.html">Improving my workflow</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-lots-more-state.html">Creating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---mutating-lots-of-state.html">Mutating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-our-data-structure-with-maps.html">Improving our data structure with maps</a></li>
<li><a href="/entries/learn-functional-programming-with-me---keyboard-input-for-our-red-square.html">Moving our red square with keyboard input</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-items-to-a-sequence.html">Adding items to a sequence and firing bullets</a></li>
<li><a href="/entries/learn-functional-programming-with-me---refactoring-my-state-transitions.html">Refactoring my state transitions</a></li>
</ul>
<p><strong>assoc-in vs update-in</strong></p>
<p>Here is some code I wrote</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> enemiesLogic [state]
  <span class="list">(<span class="title">let</span><span class="body"> [direction <span class="list">(<span class="body"><span class="keyword">:direction</span> state)</span></span>
        enemies <span class="list">(<span class="body"><span class="keyword">:enemies</span> state)</span></span>
        func <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">=</span><span class="body"> direction <span class="number">1</span>)</span></span> inc dec)</span></span>
       ]
    <span class="list">(<span class="title">assoc</span><span class="body"> state <span class="keyword">:enemies</span>
      <span class="list">(<span class="title">for</span><span class="body"> [enemy enemies]
        <span class="list">(<span class="title">assoc</span><span class="body"> enemy <span class="keyword">:x</span> <span class="list">(<span class="title">func</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> enemy)</span></span>)</span></span>)</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>What I&#39;m essentially doing is </p>
<ul>
<li>Selecting a function to apply based on the direction</li>
<li>Creating a new enemies collection where that function has been applied to each enemy</li>
</ul>
<p>Well, why bother with this? We can do</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> enemiesLogic [state]
  <span class="list">(<span class="title">let</span><span class="body"> [direction <span class="list">(<span class="body"><span class="keyword">:direction</span> state)</span></span>
        enemies <span class="list">(<span class="body"><span class="keyword">:enemies</span> state)</span></span>
        func <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">=</span><span class="body"> direction <span class="number">1</span>)</span></span> inc dec)</span></span>
       ]
    <span class="list">(<span class="title">assoc</span><span class="body"> state <span class="keyword">:enemies</span>
      <span class="list">(<span class="title">for</span><span class="body"> [enemy enemies]
        <span class="list">(<span class="title">update-in</span><span class="body"> enemy [<span class="keyword">:x</span>] func)</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>update-in takes in a func to enact on the value, rather than the new value and saves us precious reading time. Thinking about it, we can actually save some effort here too.</p>
<p>This makes a big difference in cases where I&#39;ve been lazy and done this</p>
<pre><code><span class="list">(<span class="title">assoc</span><span class="body"> bullet <span class="keyword">:y</span> <span class="list">(<span class="title">dec</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:y</span> bullet)</span></span>)</span></span>)</span></span></code></pre>
<p>Looks better like</p>
<pre><code><span class="list">(<span class="title">update-in</span><span class="body"> bullet [<span class="keyword">:y</span>] dec)</span></span></code></pre>
<p>Passing around functions seems pretty functional.</p>
<p><strong>State doesn&#39;t define an object</strong></p>
<p>Why do I have this?</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initEnemy [x y w h]
 {
  <span class="keyword">:x</span> <span class="list">(<span class="title">*</span><span class="body"> x <span class="number">30</span>)</span></span>
  <span class="keyword">:y</span> <span class="list">(<span class="title">*</span><span class="body"> y <span class="number">30</span>)</span></span>
  <span class="keyword">:w</span> w
  <span class="keyword">:h</span> h
 }
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> initPlayer [x y w h]
 {
  <span class="keyword">:x</span> x
  <span class="keyword">:y</span> y
  <span class="keyword">:w</span> w
  <span class="keyword">:h</span> h
 }
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> initBullet [x y w h]
 {
  <span class="keyword">:x</span> x
  <span class="keyword">:y</span> y
  <span class="keyword">:w</span> w
  <span class="keyword">:h</span> h
 }
)</span></span></code></pre>
<p>Seems to me that everything in my game is a rect, and what changes between these everything is the behaviour that is performed over that state.</p>
<p>So, death to these things and in with</p>
<pre><code><span class="list">(<span class="title"><span class="built_in">defn</span></span> initRect <span class="collection">[x y w h]</span>
 <span class="collection">{
  <span class="attribute">:x</span> x
  <span class="attribute">:y</span> y
  <span class="attribute">:w</span> w
  <span class="attribute">:h</span> h
 }</span>
)</span></code></pre>
<p>Actually, I&#39;m pulling this structure apart in a number of places, such as my drawing functions</p>
<pre><code><span class="list">(<span class="title">let</span><span class="body"> [{<span class="keyword">:keys</span> [x y w h]} bullet]
  <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx x y w h <span class="string">"#000"</span>)</span></span>
)</span></span></code></pre>
<p>A solution to this would be to make drawSquare take in this map and de-construct it there. I&#39;ve established that this is a primitive I want in my application and I&#39;ll use it as such.</p>
<p>I could further solidify this by turning it into a Record but I&#39;m not yet feeling any pain from not having it as one so I won&#39;t bother..</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> drawSquare [[ctx width height] rect c]
  <span class="list">(<span class="title">set</span><span class="body">! <span class="list">(<span class="body">. ctx -fillStyle)</span></span> c)</span></span>
  <span class="list">(<span class="title">let</span><span class="body"> [{<span class="keyword">:keys</span> [x y w h]} rect]
    <span class="list">(<span class="body">.fillRect ctx x y w h)</span></span> 
  )</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> enemiesRender [ctx state]
  <span class="list">(<span class="title">let</span><span class="body"> [enemies <span class="list">(<span class="body"><span class="keyword">:enemies</span> state)</span></span>]
    <span class="list">(<span class="title">doseq</span><span class="body"> [enemy enemies] 
      <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx enemy <span class="string">"#FF0"</span>)</span></span>
    )</span></span>
  )</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> bulletsRender [ctx state]
  <span class="list">(<span class="title">doseq</span><span class="body"> [bullet <span class="list">(<span class="body"><span class="keyword">:active</span> <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>)</span></span>] 
    <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx bullet <span class="string">"#000"</span>)</span></span>
  )</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> playerRender [ctx state]
  <span class="list">(<span class="title">let</span><span class="body"> [player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>]
    <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx player <span class="string">"#F00"</span>)</span></span>
  )</span></span>
)</span></span></code></pre>
<p>In other thoughts, these functions are all the same apart from the colour of the rect, it seems a bit daft to me, how about</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> renderRects [ctx rects colour]
  <span class="list">(<span class="title">doseq</span><span class="body"> [rect rects] 
    <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx enemy colour)</span></span>
  )</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> enemiesRender [ctx state]
  <span class="list">(<span class="title">renderRects</span><span class="body"> ctx <span class="list">(<span class="body"><span class="keyword">:enemies</span> state)</span></span> <span class="string">"#FF0"</span>)</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> bulletsRender [ctx state]
  <span class="list">(<span class="title">renderRects</span><span class="body"> ctx <span class="list">(<span class="title">get-in</span><span class="body"> state [<span class="keyword">:bullets</span> <span class="keyword">:active</span>])</span></span> <span class="string">"#000"</span>)</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> playerRender [ctx state]
  <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span> <span class="string">"#F00"</span>)</span></span>
)</span></span></code></pre>
<p>Keeping the number of data structures to a minimum and re-using tiny little functions seems to be a thing in these parts.</p>
<p><strong>Naming clojure constructs</strong></p>
<p>I&#39;ve been a naughy boy and stuck to my JavaScript ways of doing things with the camelCase all up in the show.</p>
<p>Turns out that Clojure fiends prefer hyphenation-on-their-names and I can kinda get behind that.</p>
<p>I&#39;ll also take the opportunity to formally start using &#39;rect&#39; everywhere instead a combination of  &#39;square&#39; and &#39;rect&#39; etc, and do a general tidy up of names.</p>
<p>I&#39;ll not show them all, but in essence </p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> bulletsRender [ctx state]
  <span class="list">(<span class="title">renderRects</span><span class="body"> ctx <span class="list">(<span class="title">get-in</span><span class="body"> state [<span class="keyword">:bullets</span> <span class="keyword">:active</span>])</span></span> <span class="string">"#000"</span>)</span></span>
)</span></span></code></pre>
<p>Will become</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> render-bullets [ctx state]
  <span class="list">(<span class="title">render-rects</span><span class="body"> ctx <span class="list">(<span class="title">get-in</span><span class="body"> state [<span class="keyword">:bullets</span> <span class="keyword">:active</span>])</span></span> <span class="string">"#000"</span>)</span></span>
)</span></span></code></pre>
<p>And so on (so don&#39;t get confused in latter entries where the names of things have changed!)</p>
<p>The only downside to this arrangement is ctrl-p is now broken in vim for method names, this is a chance for the Emacs people to point and laugh at me.</p>
<p><strong>Parenthesis white space</strong></p>
<p>I&#39;m getting little value from new-lining my parentheses.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> update-state [state]
  <span class="list">(<span class="title">update-bullets</span><span class="body">
    <span class="list">(<span class="title">update-player</span><span class="body">
      <span class="list">(<span class="title">update-enemies</span><span class="body">
        <span class="list">(<span class="title">update-direction</span><span class="body"> state)</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>When re-factoring or moving code around, I&#39;m using the vim shortcuts </p>
<ul>
<li>vi(</li>
<li>va(</li>
<li>ci(</li>
<li>ca(</li>
</ul>
<p>And so on, and actually it would be easier if I could just use left and right to move to the brace I want to grab the contents of.</p>
<p>So, I&#39;m going to sort that out too and go with</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> update-state [state]
  <span class="list">(<span class="title">update-bullets</span><span class="body">
    <span class="list">(<span class="title">update-player</span><span class="body">
      <span class="list">(<span class="title">update-enemies</span><span class="body">
        <span class="list">(<span class="title">update-direction</span><span class="body"> state)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>
<p>Gasp. Radical. This will reduce my vertical space usage and allow me to see more context on my screen (I&#39;m a k+r person in C#/JS etc so I&#39;m totally up in this way of doing things)</p>
<p>The fully tidied up source code can be found at <a href="https://github.com/robashton/clojure-spaceinvaders/blob/d7df1f4671ffe86dd2391d368e7b0169ab263fae/game.cljs">this snapshot on Github</a> if you want to catch up with where I am so far.</p>
<p>With this, I can go and look at collision detection!</p>
]]></description><link>http://codeofrob.com/entries/learn-functional-programming-with-me---more-idiomatic-clojure.html</link><guid isPermaLink="true">http://codeofrob.com/entries/learn-functional-programming-with-me---more-idiomatic-clojure.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 27 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Ruby on Rails and the Phantom Menace]]></title><description><![CDATA[<p>Remember when Star Wars came out? No - me neither, it was before my time but I watched it on the TV as I grew up never really knowing what a big deal it was to some people or why.</p>
<p>Then George Lucas announced he was going to make NEW STAR WARS, and everybody got excited - including people who hadn&#39;t really been <em>that</em> into it to begin with. We traipsed down to the cinema in droves to find out that in place of the epic star wars action we expected, we got Jar Jar Binks.</p>
<p><em>That&#39;s how I feel now</em></p>
<p>I&#39;ve been on that .NET platform thing for a while now, although I&#39;ve been writing JS for a long time and my heart has never really left the world of C and C++ I can definitely be considered as one of those people who cast an eye on the promised land of Ruby on Rails acknowledging that it was apparently very good but things were fine without it thankyou very much.</p>
<p>Only now I&#39;m doing Ruby on Rails, and I&#39;ve missed the first few iterations and the software I&#39;ve found myself using is the programming equivalant of Jar Jar sodding binks.</p>
<p><em>TLDR</em></p>
<p>This was going to be a rant, but I got distracted by building stuff and never finished the entry. Oh well - I kinda like it like this.</p>
]]></description><link>http://codeofrob.com/entries/ruby-on-rails-and-the-phantom-menace.html</link><guid isPermaLink="true">http://codeofrob.com/entries/ruby-on-rails-and-the-phantom-menace.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 25 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Company spotlight - Featurist]]></title><description><![CDATA[<p>So I mentioned that I&#39;d <a href="/entries/im-leaving-.net.html">joined a start-up in London</a>, what I didn&#39;t mention is that I&#39;m effectively employee #1 at this place even though they&#39;ve been going for quite a while now.</p>
<p>So how have we managed to get this far without any full-time staff of our own?</p>
<h3>Enter Featurist</h3>
<p><a href="http://www.featurist.co.uk/">Featurist</a> are a band of contractors/consultants/hit-team/merry-men who join companies as a team and build software. Right now they&#39;ve been building stuff with us whilst working on other more enterprisy .NET contracts.</p>
<p>Normally at companies who consider themselves &quot;.NET shops&quot;, you&#39;ll get one or two really good people and then a big pile of others who slow the whole thing down whether it be intentional or through general incompetence. Now I&#39;m sat in a room of half a dozen of these folks and it&#39;s completely bizarre to find yourself saying &quot;I believe in this one thing&quot;, and having a whole team of people presenting rational and thought out cases for and against your view point.</p>
<p>Now, at this start-up we&#39;re pretty much slinging Ruby all over the show (And boy am I hating on the Ruby the past couple of weeks), and I&#39;m finding myself needing these guys a lot to help me do things the &quot;correct&quot; way in this environment. I whine and moan about this <em>all of the time</em> and they&#39;ve done a remarkable job of seeing through that and getting on and building stuff with me. (Did I mention I really hate ruby, and bundler, and rails? I do all the time in the office and on Twitter).</p>
<p>What I&#39;ve not done is tell them all how amazing they are, and sadly whining and being negative about the 5% often outweighs the other 95% of positivity so I&#39;m sticking the positive stuff up in this blog entry for everybody to see.  (No, I&#39;m not on commission)</p>
<h3>Featurist are great</h3>
<ul>
<li>Have a look at their <a href="https://github.com/featurist">Github</a>, this is not the standard .NET consultancy fare - they&#39;re out there <em>doing stuff</em> - both interesting and useful in a variety of technologies. They&#39;re busy having opinions and using those opinions to help companies build better software - it&#39;s pretty rad.</li>
<li>As far as temperament goes, I&#39;ve never met a group who have managed to mix being &quot;chilled out about things&quot; with &quot;we still care about software and building software&quot; in quite the way they have (Unlike me who have the latter but not the former to my detriment)</li>
<li>Quality? They&#39;ve got it - I might bitch about the rails monolith but truth be told this project is about 10000% better than most of the projects I&#39;ve ever come in onto this late in the game - and this is almost 100% down to the work of Featurist.</li>
<li>Culture? Easy going, keeping things mixed up (I made fun of them for moving desks every day but it keeps things interesting and the cynic in me be damned), focused on keeping processes lightweight but visible and shipping regularly - all those things that are easy to say and hard to do.</li>
</ul>
<h3>Hire them</h3>
<p>If your company needs help (whether you&#39;re a start-up or established software house), you could do far worse than to get in touch with Featurist to see how they could help you - it&#39;s worth it.</p>
]]></description><link>http://codeofrob.com/entries/company-spotlight---featurist.html</link><guid isPermaLink="true">http://codeofrob.com/entries/company-spotlight---featurist.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 21 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Learn functional programming with me - refactoring my state transitions]]></title><description><![CDATA[<p>I&#39;m able to stream out a load of bullets in a long fish-poo like line, but what I need to do is rate limit these somehow...</p>
<ul>
<li><a href="/entries/learn-functional-programming-with-me---a-mission-statement.html">Mission statement</a></li>
<li><a href="/entries/learn-functional-programming-with-me---drawing-a-square.html">Drawing a square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---moving-the-square.html">Moving the square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---attributes-and-vectors.html">Attributes and vectors</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-my-workflow.html">Improving my workflow</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-lots-more-state.html">Creating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---mutating-lots-of-state.html">Mutating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-our-data-structure-with-maps.html">Improving our data structure with maps</a></li>
<li><a href="/entries/learn-functional-programming-with-me---keyboard-input-for-our-red-square.html">Moving our red square with keyboard input</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-items-to-a-sequence.html">Adding items to a sequence and firing bullets</a></li>
</ul>
<p><strong>My state is... in a state</strong></p>
<p>My bullets subsystem is just a list of bullets, and I actually need more state to represent this.</p>
<p>So I had a little change to create a map which represented</p>
<ul>
<li>The bullets active within the scene</li>
<li>The time since we last fired a bullet</li>
</ul>
<p>Not too complicated:</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initBullets []
  {
    <span class="keyword">:lastFiringTicks</span> <span class="number">0</span>
    <span class="keyword">:active</span> <span class="list">(<span class="body">)</span></span>
  }
)</span></span></code></pre>
<p>Of course, this has made a bit of a mockery out of my bullets logic...</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> bulletsLogic [state]
  <span class="list">(<span class="title">let</span><span class="body"> [player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>
        bullets <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>
        existingBullets 
        <span class="list">(<span class="title">for</span><span class="body"> [bullet <span class="list">(<span class="body"><span class="keyword">:active</span> bullets)</span></span>]
          {
            <span class="keyword">:x</span> <span class="list">(<span class="body"><span class="keyword">:x</span> bullet)</span></span>
            <span class="keyword">:y</span> <span class="list">(<span class="title">dec</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:y</span> bullet)</span></span>)</span></span>
            <span class="keyword">:w</span> <span class="list">(<span class="body"><span class="keyword">:w</span> bullet)</span></span>
            <span class="keyword">:h</span> <span class="list">(<span class="body"><span class="keyword">:h</span> bullet)</span></span>
          }
        )</span></span>
      ]
    <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="body">@keyStates <span class="number">32</span>)</span></span>
      {
        <span class="keyword">:lastFiringTicks</span> <span class="list">(<span class="body"><span class="keyword">:lastFiringTicks</span> bullets)</span></span>
        <span class="keyword">:active</span> <span class="list">(<span class="title">cons</span><span class="body"> 
                {
                 <span class="keyword">:x</span> <span class="list">(<span class="body"><span class="keyword">:x</span> <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>)</span></span>
                 <span class="keyword">:y</span> <span class="list">(<span class="body"><span class="keyword">:y</span> <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>)</span></span>
                 <span class="keyword">:w</span> <span class="number">5</span>
                 <span class="keyword">:h</span> <span class="number">5</span>
                }
                existingBullets
                )</span></span>
      }
      {
        <span class="keyword">:lastFiringTicks</span> <span class="list">(<span class="body"><span class="keyword">:lastFiringTicks</span> bullets)</span></span>
        <span class="keyword">:active</span> existingBullets
      }
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>So much for that statement about Functional Programming forcing you to write code that is easy to reason about, a fool will write foolish code in whatever language ;-)</p>
<p><strong>Refactoring away from pain</strong></p>
<p>I can refactor this of course - now I know that there is an ability to &#39;modify&#39; a single field within a map with &#39;assoc&#39;, I can create functions that don&#39;t need to know about the whole state and have little sub-functions for handling the logic of my bullets system.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> bulletsLogic [state]
  <span class="list">(<span class="title">tryAndFire</span><span class="body">
    <span class="list">(<span class="title">moveBullets</span><span class="body"> state)</span></span>
  )</span></span>
)</span></span></code></pre>
<p>How about moving the bullets, and then passing whatever the state is after that point to the tryAndFire function, and then returning the state of that to the outside world?</p>
<p>Moving the bullets becomes a matter of calling assoc on each bullet with a modified y, this is much nicer than having to copy across each property of the bullet.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> moveBullets [state]
  <span class="list">(<span class="title">let</span><span class="body"> [bullets <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>
        active <span class="list">(<span class="body"><span class="keyword">:active</span> bullets)</span></span>]
    <span class="list">(<span class="title">assoc</span><span class="body"> state <span class="keyword">:bullets</span> 
      <span class="list">(<span class="title">assoc</span><span class="body"> bullets <span class="keyword">:active</span>
        <span class="list">(<span class="title">for</span><span class="body"> [bullet active]
          <span class="list">(<span class="title">assoc</span><span class="body"> bullet <span class="keyword">:y</span> <span class="list">(<span class="title">dec</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:y</span> bullet)</span></span>)</span></span>)</span></span>
        )</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>And trying to fire becomes a matter of adding an item to the list, or just returning original state</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> tryAndFire [state]
  <span class="list">(<span class="title">let</span><span class="body"> [bullets <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>
        active <span class="list">(<span class="body"><span class="keyword">:active</span> bullets)</span></span>
        player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>]
    <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="body">@keyStates <span class="number">32</span>)</span></span>
      <span class="list">(<span class="title">assoc</span><span class="body"> state <span class="keyword">:bullets</span> 
        <span class="list">(<span class="title">assoc</span><span class="body"> bullets <span class="keyword">:active</span>
          <span class="list">(<span class="title">cons</span><span class="body"> 
            {
             <span class="keyword">:x</span> <span class="list">(<span class="body"><span class="keyword">:x</span> player)</span></span>
             <span class="keyword">:y</span> <span class="list">(<span class="body"><span class="keyword">:y</span> player)</span></span>
             <span class="keyword">:w</span> <span class="number">5</span>
             <span class="keyword">:h</span> <span class="number">5</span>
            }
            active
          )</span></span>
        )</span></span>
      )</span></span>
      state
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p><strong>Refactoring towards readability</strong></p>
<p> Of course this can be re-factored a bit further for readability by pulling out another function</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> tryAndFire [state]
  <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="body">@keyStates <span class="number">32</span>)</span></span>
    <span class="list">(<span class="title">fire</span><span class="body"> state)</span></span>
    state
  )</span></span>
)</span></span></code></pre>
<p>Keeping the activity of firing to its own little function</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> fire [state]
  <span class="list">(<span class="title">let</span><span class="body"> [bullets <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>
        active <span class="list">(<span class="body"><span class="keyword">:active</span> bullets)</span></span>
        player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>]
    <span class="list">(<span class="title">assoc</span><span class="body"> state <span class="keyword">:bullets</span> 
      <span class="list">(<span class="title">assoc</span><span class="body"> bullets <span class="keyword">:active</span>
        <span class="list">(<span class="title">cons</span><span class="body"> 
          <span class="list">(<span class="title">initBullet</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> player)</span></span> <span class="list">(<span class="body"><span class="keyword">:y</span> player)</span></span> <span class="number">5</span> <span class="number">5</span>)</span></span>
          active
        )</span></span>
       )</span></span>
     )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>And yes, I also pulled out the code for creating a new bullet to make it even more obvious what is going on.</p>
<p>Now, actually because of my main logic function looking like this:</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> doLogic [state]
  {
    <span class="keyword">:direction</span> <span class="list">(<span class="title">directionLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:enemies</span> <span class="list">(<span class="title">enemiesLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:player</span> <span class="list">(<span class="title">playerLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:bullets</span> <span class="list">(<span class="title">bulletsLogic</span><span class="body"> state)</span></span>
  }
)</span></span></code></pre>
<p>I&#39;ve got to do some contortions to return &#39;just the bullets&#39; from my bullets logic</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> bulletsLogic [state]
  <span class="list">(<span class="body"><span class="keyword">:bullets</span> <span class="list">(<span class="title">tryAndFire</span><span class="body">
    <span class="list">(<span class="title">moveBullets</span><span class="body"> state)</span></span>
  )</span></span>)</span></span>
)</span></span></code></pre>
<p><strong>Refactoring away from the acrobatics</strong></p>
<p>But how about taking my new pattern further and applying each sub-system&#39;s changes to the state as a sequence of modifications to the state</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> doLogic [state]
  <span class="list">(<span class="title">bulletsLogic</span><span class="body">
    <span class="list">(<span class="title">playerLogic</span><span class="body">
      <span class="list">(<span class="title">enemiesLogic</span><span class="body">
        <span class="list">(<span class="title">directionLogic</span><span class="body"> state)</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>Overall I think I like this approach better than trying to make each system return its own state, and as most of the logic seems to require sections of state from all over the show having the state all readily accessible seems to make sense.</p>
<p>That said, I&#39;d normally shy away from this sort of approach in an OO language/manner because shared data implies coupling. </p>
<p>Of course my normal solution is often the duplication of state via events or some other in-direct means and the reason for this tends to be to avoid accidental mutation which isn&#39;t going to be such a problem here where it&#39;s such an explicit decision.</p>
<p>I&#39;ll see how that plays out as I roll forwards, but now I&#39;ve applied this refactoring step I&#39;m in a much better position to get in the feature I wanted in the first place. </p>
<p>If I end up not liking the current mutation capabilities, I can always change how I update the state from the outside-most part of my program by doing my assoc there. That mutation is such a visible decision in my code seems to be one of the bonuses of FP.</p>
<p><strong>Updating nested data with assoc-in</strong></p>
<p>I don&#39;t like all the nested assocs, so I hit up the Clojure docs now I&#39;m not on a plane and discover &#39;assoc-in&#39; and &#39;get-in&#39;, which do pretty much what you&#39;d expect.</p>
<p>Instead of</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> fire [state]
  <span class="list">(<span class="title">let</span><span class="body"> [bullets <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>
        active <span class="list">(<span class="body"><span class="keyword">:active</span> bullets)</span></span>
        player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>]
    <span class="list">(<span class="title">assoc</span><span class="body"> state <span class="keyword">:bullets</span> 
      <span class="list">(<span class="title">assoc</span><span class="body"> bullets <span class="keyword">:active</span>
        <span class="list">(<span class="title">cons</span><span class="body"> 
          <span class="list">(<span class="title">initBullet</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> player)</span></span> <span class="list">(<span class="body"><span class="keyword">:y</span> player)</span></span> <span class="number">5</span> <span class="number">5</span>)</span></span>
          active
        )</span></span>
       )</span></span>
     )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>I can actually do</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> addBulletInPlayerLocation [state]
  <span class="list">(<span class="title">let</span><span class="body"> [player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>]
    <span class="list">(<span class="title">assoc-in</span><span class="body"> state [<span class="keyword">:bullets</span> <span class="keyword">:active</span>]
      <span class="list">(<span class="title">cons</span><span class="body"> 
        <span class="list">(<span class="title">initBullet</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> player)</span></span> <span class="list">(<span class="body"><span class="keyword">:y</span> player)</span></span> <span class="number">5</span> <span class="number">5</span>)</span></span>
        <span class="list">(<span class="title">get-in</span><span class="body"> state [<span class="keyword">:bullets</span> <span class="keyword">:active</span>])</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>So I&#39;ve done that everywhere it makes sense to as it makes the code more readable.</p>
<p><strong>Applying that time limiter</strong></p>
<p>So, what kicked off my re-factoring efforts was the addition of a little bit of state to my map ala</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initBullets []
  {
    <span class="keyword">:lastFiringTicks</span> <span class="number">0</span>
    <span class="keyword">:active</span> <span class="list">(<span class="body">)</span></span>
  }
)</span></span></code></pre>
<p>How to use this? Well, the algorithm goes something like this</p>
<pre><code><span class="title">Is</span> <span class="built_in">last</span>Ticks nonZero? 
  Increase <span class="built_in">last</span>Ticks
  is <span class="built_in">last</span>Ticks equal to firing rate?
    Set <span class="built_in">last</span>Ticks to Zero

Are we trying to fire? 
  Yes? Is <span class="built_in">last</span>Ticks <span class="number">0</span>?
    Yes? Fire, increase <span class="built_in">last</span>Ticks</code></pre>
<p>So we have two steps</p>
<ul>
<li>UpdateFiringTicks</li>
<li>TryAndFire</li>
</ul>
<p><strong>Managing the firing ticks</strong></p>
<p>Well first off, let&#39;s add this to the chain of logics we want to execute for our bullet logic</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> bulletsLogic [state]
  <span class="list">(<span class="title">tryAndFire</span><span class="body">
    <span class="list">(<span class="title">updateFiringTicks</span><span class="body">
      <span class="list">(<span class="title">moveBullets</span><span class="body"> state)</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>And we can simply execute the logic described above here</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> updateFiringTicks [state]
  <span class="list">(<span class="title">let</span><span class="body"> [bullets <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>
        ticks <span class="list">(<span class="body"><span class="keyword">:lastFiringTicks</span> bullets)</span></span>]
    <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> ticks <span class="number">0</span>)</span></span> 
      state
      <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> <span class="list">(<span class="title">rem</span><span class="body"> ticks <span class="number">30</span>)</span></span> <span class="number">0</span>)</span></span>
        <span class="list">(<span class="title">assoc-in</span><span class="body"> state [<span class="keyword">:bullets</span> <span class="keyword">:lastFiringTicks</span>] <span class="number">0</span>)</span></span>
        <span class="list">(<span class="title">assoc-in</span><span class="body"> state [<span class="keyword">:bullets</span> <span class="keyword">:lastFiringTicks</span>] <span class="list">(<span class="title">inc</span><span class="body"> ticks)</span></span>)</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>And firing just needs to update this value now so...</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> fire [state]
  <span class="list">(<span class="title">incrementFiringTicks</span><span class="body">
    <span class="list">(<span class="title">addBulletInPlayerLocation</span><span class="body"> state)</span></span>
  )</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> incrementFiringTicks [state]
  <span class="list">(<span class="title">assoc-in</span><span class="body"> state [<span class="keyword">:bullets</span> <span class="keyword">:lastFiringTicks</span>] <span class="number">1</span>)</span></span>
)</span></span></code></pre>
<p>Now my little craft only fires about once a second, mission accomplished.</p>
<p><strong>Summary</strong></p>
<p>This was quite a lengthy process to add a simple feature, I got side-tracked by what I hope was useful learning. I&#39;m left a little uncomfortable with how I&#39;m dealing with state and I feel like there is something more elegant I could be doing. Maybe I&#39;ll discover this as I continue through.</p>
]]></description><link>http://codeofrob.com/entries/learn-functional-programming-with-me---refactoring-my-state-transitions.html</link><guid isPermaLink="true">http://codeofrob.com/entries/learn-functional-programming-with-me---refactoring-my-state-transitions.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 20 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Learn functional programming with me - Adding items to a sequence]]></title><description><![CDATA[<p>What good is Space Invaders if you can&#39;t shoot anyone?</p>
<ul>
<li><a href="/entries/learn-functional-programming-with-me---a-mission-statement.html">Mission statement</a></li>
<li><a href="/entries/learn-functional-programming-with-me---drawing-a-square.html">Drawing a square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---moving-the-square.html">Moving the square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---attributes-and-vectors.html">Attributes and vectors</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-my-workflow.html">Improving my workflow</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-lots-more-state.html">Creating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---mutating-lots-of-state.html">Mutating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-our-data-structure-with-maps.html">Improving our data structure with maps</a></li>
<li><a href="/entries/learn-functional-programming-with-me---keyboard-input-for-our-red-square.html">Moving our red square with keyboard input</a></li>
</ul>
<p>So far I have a fixed number of entities in my scene, which means the pattern</p>
<pre><code><span class="function"><span class="title">logic</span><span class="params">(state)</span> =&gt; <span class="title">newState</span></code></pre>
<p>Has been working great for me, but how might I manage a variable number of these entities? How might I hook up the creation of these entities to keyboard input?</p>
<p>Well, actually I don&#39;t think it is going to be that hard - but we&#39;ll see as I give it a go...</p>
<p><strong>The basics once again</strong></p>
<p>The same deal as everything else so far (okay, my next entry might be on re-factoring all this to avoid duplication)</p>
<p><em>This is how we create a bullet</em></p>
<pre><code><span class="list">(<span class="title"><span class="built_in">defn</span></span> initBullet <span class="collection">[x y w h]</span>
 <span class="collection">{
  <span class="attribute">:x</span> x
  <span class="attribute">:y</span> y
  <span class="attribute">:w</span> w
  <span class="attribute">:h</span> h
 }</span>
)</span></code></pre>
<p><em>Bullets logic is taking the current sequence of bullets and moving them on the vertical axis</em></p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> bulletsLogic [state]
  <span class="list">(<span class="title">for</span><span class="body"> [bullet <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>]
    {
      <span class="keyword">:x</span> <span class="list">(<span class="body"><span class="keyword">:x</span> bullet)</span></span>
      <span class="keyword">:y</span> <span class="list">(<span class="title">dec</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:y</span> bullet)</span></span>)</span></span>
      <span class="keyword">:w</span> <span class="list">(<span class="body"><span class="keyword">:w</span> bullet)</span></span>
      <span class="keyword">:h</span> <span class="list">(<span class="body"><span class="keyword">:h</span> bullet)</span></span>
    }
  )</span></span>
)</span></span></code></pre>
<p><em>And I&#39;m going to draw a black square for each bullet</em></p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> bulletsRender [ctx state]
  <span class="list">(<span class="title">doseq</span><span class="body"> [bullet <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>] 
    <span class="list">(<span class="title">let</span><span class="body"> [{<span class="keyword">:keys</span> [x y w h]} bullet]
      <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx x y w h <span class="string">"#000"</span>)</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>There is nothing special or new about the above, although I&#39;ve dropped the &#39;let&#39; (as compared to the enemies render function) and pulled the bullets out of the state as part of the doseq call.</p>
<p>My bullets to begin with?</p>
<p><em>Create an empty list</em></p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initState []
 { 
   <span class="keyword">:direction</span> <span class="number">1</span>
   <span class="keyword">:enemies</span> <span class="list">(<span class="title">for</span><span class="body"> [x <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">16</span> <span class="number">2</span>)</span></span>
                  y <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">8</span> <span class="number">2</span>)</span></span>]
              <span class="list">(<span class="title">initEnemy</span><span class="body"> x y <span class="number">20</span> <span class="number">20</span>)</span></span>
   )</span></span>
   <span class="keyword">:player</span> <span class="list">(<span class="title">initPlayer</span><span class="body"> <span class="number">200</span> <span class="number">430</span> <span class="number">20</span> <span class="number">20</span>)</span></span>
   <span class="keyword">:bullets</span> <span class="list">(<span class="body">)</span></span>
 } 
)</span></span></code></pre>
<p>I found out how to do that on Google so I think it&#39;s right.</p>
<p>I also found out that apparently an empty list is not a sequence, although it is sequenceable which means I can safely do the above (I think)</p>
<p><em>Calling the appropriate methods</em></p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> doLogic [state]
  {
    <span class="keyword">:direction</span> <span class="list">(<span class="title">directionLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:enemies</span> <span class="list">(<span class="title">enemiesLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:player</span> <span class="list">(<span class="title">playerLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:bullets</span> <span class="list">(<span class="title">bulletsLogic</span><span class="body"> state)</span></span>
  }
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> renderScene [ctx state]
  <span class="list">(<span class="title">enemiesRender</span><span class="body"> ctx state)</span></span>
  <span class="list">(<span class="title">playerRender</span><span class="body"> ctx state)</span></span>
  <span class="list">(<span class="title">bulletsRender</span><span class="body"> ctx state)</span></span>
)</span></span></code></pre>
<p>Now, all of this achieves the square root of diddly squat, although if I run the program it doesn&#39;t fall over in a heap pile of flames so that&#39;s pretty good going for all of this code.</p>
<p><strong>Hooking up some input events</strong></p>
<p>Well okay, for now what I&#39;ll do is say is &quot;if the spacebar is pressed we&#39;ll fire a bullet&quot;, so we can do this in a similar manner to everything else thus far...</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> bulletsLogic [state]</code></pre>
<p><em>Get the player out, and update the bullets into a seq called &#39;existingBullets&#39;</em></p>
<pre><code>  <span class="list">(<span class="title">let</span><span class="body"> [player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>
        existingBullets 
        <span class="list">(<span class="title">for</span><span class="body"> [bullet <span class="list">(<span class="body"><span class="keyword">:bullets</span> state)</span></span>]
          {
            <span class="keyword">:x</span> <span class="list">(<span class="body"><span class="keyword">:x</span> bullet)</span></span>
            <span class="keyword">:y</span> <span class="list">(<span class="title">dec</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:y</span> bullet)</span></span>)</span></span>
            <span class="keyword">:w</span> <span class="list">(<span class="body"><span class="keyword">:w</span> bullet)</span></span>
            <span class="keyword">:h</span> <span class="list">(<span class="body"><span class="keyword">:h</span> bullet)</span></span>
          }
        )</span></span>
      ]</code></pre>
<p><em>If the space bar is down, then create a new sequence with a new bullet and the existing bullets</em></p>
<pre><code>    <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="body">@keyStates <span class="number">32</span>)</span></span>
      <span class="list">(<span class="title">cons</span><span class="body"> 
        {
         <span class="keyword">:x</span> <span class="list">(<span class="body"><span class="keyword">:x</span> <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>)</span></span>
         <span class="keyword">:y</span> <span class="list">(<span class="body"><span class="keyword">:y</span> <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>)</span></span>
         <span class="keyword">:w</span> <span class="number">5</span>
         <span class="keyword">:h</span> <span class="number">5</span>
        }
        existingBullets
      )</span></span></code></pre>
<p><em>Else just return the existing bullets</em></p>
<pre><code>      <span class="title">existingBullets</span>
    )
  )
)</code></pre>
<p>This is pretty messy, although it&#39;s my first iteration at this so that&#39;s okay, I suspect I can be a bit cleverer about this and probably will end up being so!</p>
<p><strong>Don&#39;t change the collection, create a new one</strong></p>
<p>What we can see though, is that I don&#39;t &quot;add the new bullet to the sequence&quot;, I instead &quot;create a new sequence out of the old one plus the new items&quot;. That&#39;s what <em>cons</em> does according to the Clojure docs.</p>
<p>This is counter-intuitive to those of us used to our mutable collections, but apparently Clojure is quite clever about this stuff and I should trust that this is okay. (Just like so far I&#39;m trusting that everything else is going to be okay too).</p>
<p>At some point soon I&#39;ll start reading about these sequences, collections, maps etc and see how they&#39;re implemented - now I have some &quot;real&quot; examples of their usage.</p>
<p><strong>The result</strong></p>
<p><img src="/img/constant_flow.png"></p>
]]></description><link>http://codeofrob.com/entries/learn-functional-programming-with-me---adding-items-to-a-sequence.html</link><guid isPermaLink="true">http://codeofrob.com/entries/learn-functional-programming-with-me---adding-items-to-a-sequence.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 18 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Learn functional programming with me - keyboard input for our red square]]></title><description><![CDATA[<p>Now we have some enemies, let&#39;s add our player and see how we might achieve the handling of keyboard events to move him.</p>
<ul>
<li><a href="/entries/learn-functional-programming-with-me---a-mission-statement.html">Mission statement</a></li>
<li><a href="/entries/learn-functional-programming-with-me---drawing-a-square.html">Drawing a square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---moving-the-square.html">Moving the square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---attributes-and-vectors.html">Attributes and vectors</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-my-workflow.html">Improving my workflow</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-lots-more-state.html">Creating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---mutating-lots-of-state.html">Mutating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-our-data-structure-with-maps.html">Improving our data structure with maps</a></li>
</ul>
<p>Well, first off let&#39;s create the player</p>
<pre><code> <span class="symbol">:player</span> (initPlayer <span class="number">0</span> <span class="number">430</span> <span class="number">20</span> <span class="number">20</span>)</code></pre>
<p>Where</p>
<pre><code><span class="list">(<span class="title"><span class="built_in">defn</span></span> initPlayer <span class="collection">[x y w h]</span>
 <span class="collection">{
  <span class="attribute">:x</span> x
  <span class="attribute">:y</span> y
  <span class="attribute">:w</span> w
  <span class="attribute">:h</span> h
 }</span>
)</span></code></pre>
<p>There are some similarities here between the player and the enemy, and perhaps I&#39;ll address that when I&#39;m a position to tell how.</p>
<p>Now, I&#39;ll want to render that player, and I&#39;m actually going to take the bold step of pulling out a render function so my main loop now looks like this:</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> tick [ctx state]
  <span class="list">(<span class="title">clearScreen</span><span class="body"> ctx)</span></span> 
  <span class="list">(<span class="title">renderScene</span><span class="body"> ctx state)</span></span>
  <span class="list">(<span class="title">js/setTimeout</span><span class="body"> <span class="list">(<span class="title">fn</span><span class="body"> []
    <span class="list">(<span class="title">tick</span><span class="body"> ctx <span class="list">(<span class="title">doLogic</span><span class="body"> state)</span></span>)</span></span>
  )</span></span> <span class="number">33</span>  )</span></span>
)</span></span></code></pre>
<p>Just keeping things tidy!</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> renderScene [ctx state]
  <span class="list">(<span class="title">enemiesRender</span><span class="body"> ctx state)</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> enemiesRender [ctx state]
  <span class="list">(<span class="title">let</span><span class="body"> [enemies <span class="list">(<span class="body"><span class="keyword">:enemies</span> state)</span></span>]
    <span class="list">(<span class="title">doseq</span><span class="body"> [enemy enemies] 
      <span class="list">(<span class="title">let</span><span class="body"> [{<span class="keyword">:keys</span> [x y w h]} enemy]
        <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx x y w h)</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>Right, so now I have a player, I may as well render it</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> renderScene [ctx state]
  <span class="list">(<span class="title">enemiesRender</span><span class="body"> ctx state)</span></span>
  <span class="list">(<span class="title">playerRender</span><span class="body"> ctx state)</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> playerRender [ctx state]
  <span class="list">(<span class="title">let</span><span class="body"> [player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>]
    <span class="list">(<span class="title">let</span><span class="body"> [{<span class="keyword">:keys</span> [x y w h]} player]
      <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx x y w h)</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>And I&#39;ll need to copy it across to the new state each iteration</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> doLogic [state]
  {
    <span class="keyword">:direction</span> <span class="list">(<span class="title">directionLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:enemies</span> <span class="list">(<span class="title">enemiesLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:player</span> <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>
  }
)</span></span></code></pre>
<p>Nothing new here, this&#39;ll just give me an additional yellow square on my canvas...</p>
<p><img src="/img/player_added.png" alt="An additional yellow square on a canvas" title="The player has been added"></p>
<p><strong>Handling those input events</strong></p>
<p>Now I want to move it though, and this is where things are going to get fun, from what I can <em>imagine</em> off the top of my head (I&#39;m currently sat on a plane at 35,000ft with no internet so I can&#39;t look anything up), my options are:</p>
<ul>
<li>Attempt to mutate player state directly as input events happen</li>
<li>Keep some mutable state around to indicate whether certain keys are currently down, and apply these modifiers as part of logic</li>
</ul>
<p>I think I&#39;m going to opt for the second one and see how that plays out. It kinda makes sense to me in ignorant-land that isolating areas of mutable state from my (currently quite) clean program will be helpful.</p>
<p>This is pretty much what the structure will look like:</p>
<pre><code><span class="function"><span class="title">tick</span> <span class="params">(state)</span> =&gt;
  <span class="title">inputs</span> = <span class="title">getCurrentInputs</span><span class="params">()</span>
  <span class="title">tick</span> <span class="title">applyLogic</span><span class="params">(state, inputs)</span></code></pre>
<p>I don&#39;t have to care that behind that getCurrentInputs is some horrible interop with the browser and piles of mutability, and if I work out how to do it better later it should limit the area of change needing to be applied.</p>
<p>I can hook the events using the standard js interop, which looks like this</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> hookInputEvents []
  <span class="list">(<span class="body">.addEventListener js/document <span class="string">"keydown"</span> 
   <span class="list">(<span class="title">fn</span><span class="body"> [e]
    <span class="list">(<span class="title">setKeyState</span><span class="body"> e.KeyCode true)</span></span>
   )</span></span>
  )</span></span>
  <span class="list">(<span class="body">.addEventListener js/document <span class="string">"keyup"</span> 
   <span class="list">(<span class="title">fn</span><span class="body"> [e]

   )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>Okay, so what now? I need to get this information to the game somehow, and actually - the information I want is &quot;Is the key currently down&quot;, which is state I need to build up off those events.</p>
<p><strong>Up and Atom</strong></p>
<p>So I had to a bit of trawling to get this right, there is a notion of an &quot;atom&quot;, in Clojure which is effectively a mutable object with some synchronisation over the top of it.</p>
<p>I&#39;ve tried to avoid having any of this trickery yet, but this is somewhere I think going to need it.</p>
<p>So, an atom - I&#39;m putting this into my &#39;global&#39; scope (actually, it&#39;s namespaced into (ns game))</p>
<p><em>Define some state called keyStates, assign to it an atom (initial value is an empty map)</em></p>
<pre><code>(<span class="function"><span class="keyword">def</span> <span class="title">keyStates</span> <span class="params">(atom {})</span>)</code></pre>
<p>Now, if I want to access the value of keyStates, I can de-rererence it thusly</p>
<p><em>De-reference an atom</em></p>
<pre><code><span class="variable">@keystates</span></code></pre>
<p>I also wanted to know how to &quot;modify a single value of a map&quot;, for reasons that are about to become clear, the way to do this is</p>
<p><em>Create a new map, with a single property changed</em></p>
<pre><code><span class="list">(<span class="title">assoc</span><span class="body"> myMap <span class="keyword">:name</span> newValue)</span></span></code></pre>
<p> This function returns a new map which is the same as the old one, but with that value changed (Hey, this is quite useful!)</p>
<p>The final piece of my jigsaw is the ability to change the value of this mutable atom, to do this I can use &#39;swap&#39;</p>
<pre><code><span class="list">(<span class="title">swap</span><span class="body">! myAtom <span class="list">(<span class="title">fn</span><span class="body"> [oldValue] newValue)</span></span>)</span></span></code></pre>
<p> So how about that setKeyState function?</p>
<p><em>Set the new keyStates to be the same as the old keyStates, but with a new value for the current keycode</em></p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> setKeyState [code, value]
  <span class="list">(<span class="title">swap</span><span class="body">! keyStates assoc code value)</span></span>
)</span></span></code></pre>
<p>Swap will call assoc, passing in the old state and the other args specified (hey, this is quite functional!)</p>
<p>Now I have a global state for my current input, which means I can ask questions of it and apply those answers to my state.</p>
<p><strong>Applying input to my square</strong></p>
<p>Well, I&#39;ll make a function whose job it is to take in the old state and return the new state and that seems to be working well for me so far.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> playerLogic [state]

)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> doLogic [state]
  {
    <span class="keyword">:direction</span> <span class="list">(<span class="title">directionLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:enemies</span> <span class="list">(<span class="title">enemiesLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:player</span> <span class="list">(<span class="title">playerLogic</span><span class="body"> state)</span></span>
  }
)</span></span></code></pre>
<p>And in this, I&#39;ll work out from the input what to do to my state</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> playerLogic [state]
  <span class="list">(<span class="title">let</span><span class="body"> [player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>  
        left <span class="list">(<span class="body">@keyStates <span class="number">37</span>)</span></span>
        right <span class="list">(<span class="body">@keyStates <span class="number">39</span>)</span></span>
       ]
    <span class="list">(<span class="title">cond</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> left true)</span></span> <span class="list">(<span class="title">assoc</span><span class="body"> player <span class="keyword">:x</span> <span class="list">(<span class="title">dec</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> player)</span></span>)</span></span>)</span></span>
          <span class="list">(<span class="title">=</span><span class="body"> right true)</span></span> <span class="list">(<span class="title">assoc</span><span class="body"> player <span class="keyword">:x</span> <span class="list">(<span class="title">inc</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> player)</span></span>)</span></span>)</span></span>
          <span class="keyword">:else</span> player
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p> There is a whole lot to take where, but it boils down to</p>
<ul>
<li>Extract player from the state</li>
<li>Extract &#39;left&#39; from the de-referenced keyStates (37)</li>
<li>Extract &#39;right&#39; from the de-referenced keyStates (39)</li>
<li>Decide what new state to return based on this value</li>
</ul>
<p>Let&#39;s look at that last bit closer:</p>
<pre><code><span class="list">(<span class="title">cond</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> left true)</span></span> <span class="list">(<span class="title">assoc</span><span class="body"> player <span class="keyword">:x</span> <span class="list">(<span class="title">dec</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> player)</span></span>)</span></span>)</span></span>
      <span class="list">(<span class="title">=</span><span class="body"> right true)</span></span> <span class="list">(<span class="title">assoc</span><span class="body"> player <span class="keyword">:x</span> <span class="list">(<span class="title">inc</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> player)</span></span>)</span></span>)</span></span>
      <span class="keyword">:else</span> player</code></pre>
<p> This is kinda equivalent to</p>
<pre><code><span class="function"><span class="title">if</span><span class="params">(left)</span> { }
<span class="title">else</span> <span class="title">if</span><span class="params">(right)</span> {}
<span class="title">else</span> {}</code></pre>
<p>The expressions on the RHS will be evaluated and returned if the LHS is true.</p>
<p>We&#39;ve already looked at assoc, we recognise dec/inc and basically all I&#39;m doing is saying, &#39;return a new player with x changed, here is the new value of x, it&#39;s a modification of the current x&#39;</p>
<p>I bet there is a tidier way of doing this actually, maybe a built-in but I came up with</p>
<p><em>Please apply the specified function to the specified key in this map and return the result</em></p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> applyMod [m k func]
  <span class="list">(<span class="title">assoc</span><span class="body"> m k <span class="list">(<span class="title">func</span><span class="body"> <span class="list">(<span class="title">m</span><span class="body"> k)</span></span>)</span></span>)</span></span>
)</span></span></code></pre>
<p><em>And in usage:</em></p>
<pre><code><span class="list">(<span class="title">cond</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> left true)</span></span> <span class="list">(<span class="title">applyMod</span><span class="body"> player <span class="keyword">:x</span> dec)</span></span>
      <span class="list">(<span class="title">=</span><span class="body"> right true)</span></span> <span class="list">(<span class="title">applyMod</span><span class="body"> player <span class="keyword">:x</span> inc)</span></span>
      <span class="keyword">:else</span> player</code></pre>
<p><strong>Paint our player Red</strong></p>
<p>I said red square, and so far it&#39;s yellow, let&#39;s fix this problem.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> drawSquare [[ctx width height] x y w h c]
  <span class="list">(<span class="title">set</span><span class="body">! <span class="list">(<span class="body">. ctx -fillStyle)</span></span> c)</span></span>
  <span class="list">(<span class="body">.fillRect ctx x y w h)</span></span> 
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> enemiesRender [ctx state]
  <span class="list">(<span class="title">let</span><span class="body"> [enemies <span class="list">(<span class="body"><span class="keyword">:enemies</span> state)</span></span>]
    <span class="list">(<span class="title">doseq</span><span class="body"> [enemy enemies] 
      <span class="list">(<span class="title">let</span><span class="body"> [{<span class="keyword">:keys</span> [x y w h]} enemy]
        <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx x y w h <span class="string">"#FF0"</span>)</span></span>
      )</span></span>
    )</span></span>
  )</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> playerRender [ctx state]
  <span class="list">(<span class="title">let</span><span class="body"> [player <span class="list">(<span class="body"><span class="keyword">:player</span> state)</span></span>]
    <span class="list">(<span class="title">let</span><span class="body"> [{<span class="keyword">:keys</span> [x y w h]} player]
      <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx x y w h <span class="string">"#F00"</span>)</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>The drawing square function and repetition across my two types of entity still bugs me, but I figure I&#39;ll yet manage to tidy this up.</p>
<p><strong>The result</strong></p>
<p>See, it&#39;s <em>almost</em> Space Invaders already.</p>
<p><img src="/img/red_player.png" alt="Yellow invaders, red player" title="Red player"></p>
]]></description><link>http://codeofrob.com/entries/learn-functional-programming-with-me---keyboard-input-for-our-red-square.html</link><guid isPermaLink="true">http://codeofrob.com/entries/learn-functional-programming-with-me---keyboard-input-for-our-red-square.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 13 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Stand-ups are a crutch]]></title><description><![CDATA[<p><em>PUB RANT TIME</em></p>
<p>You know the feeling, you&#39;re hacking away on some feature on the to-do list, having a conversation about it with the team in the team-chat of your preference and perhaps you&#39;re dancing to some of your favourite music whilst you flick between the two. You are in the zone.</p>
<h1>Hey, <em>everyone</em>, stand-up time</h1>
<p>Boom, just like that you&#39;re back to reality and detaching yourself from your game zone. You&#39;re breaking up that conversation, you&#39;re turning off the music and worst of all you&#39;re leaving your <em>flow</em> so you can all talk about what everybody knows already because they&#39;ve been talking about it the whole time they&#39;ve been working.</p>
<h3>At one end of the spectrum</h3>
<p>Stand-ups in already-effective teams are at best a way to force some meat-space interaction between team members, and at worst a harmful distraction costing you hours of combined productivity in return for very little that couldn&#39;t have been achieved in the course of conversation over a beer at lunch.</p>
<p>In a good team, folk will have been pairing and watching the pull requests come in - people who aren&#39;t doing anything will tell you they aren&#39;t doing anything. People who are stuck will tell you that they&#39;re stuck. If someone isn&#39;t doing these things other developers will call them out on it because it&#39;s pretty obvious that nothing has come from their corner for a while. </p>
<p>In short an effective team doesn&#39;t need this crap because they&#39;re already <em>doing</em> what they should be doing - getting work done and sharing information about the work they&#39;re doing.</p>
<h3>At the other end of the spectrum</h3>
<p>In teams that aren&#39;t being effective, stand-ups are often used as a way to force some mumblings out of developers towards what they&#39;ve done and what they&#39;re doing today - and usually that&#39;s pretty much all you&#39;ll get out of them because they sure as hell don&#39;t want to admit they&#39;ve just been pushing code around this week.</p>
<p>Once they&#39;re back in their seats, they&#39;ll still not talk, they&#39;ll still not interact because hey, they had a stand-up and can get back to pushing meaningless code around.</p>
<p>Worst of all with daily stand-ups, crap teams with crap people on them won&#39;t even do any work before that organised daily stand-up because hey - the stand-up is coming and they don&#39;t want to be interrupted right? But you can&#39;t start the stand-up until everyone is there so everybody ends up starting work at 10am - <em>golf clap</em>.</p>
<h2>Don&#39;t work at the wrong end of the spectrum</h2>
<p>Fine, you&#39;re in a crap team - go and make it a not-crap team. I&#39;m not here to tell you how to do that, plenty of team management gurus are out there charging their thousands of dollars in order to give you a penny of their thoughts. I can tell you from experience that stand-ups won&#39;t fix your communication problems because in my experience they&#39;ll just get used as an excuse <em>not to communicate the rest of the time</em>.</p>
<p>Or accept you&#39;re in a crap environment and carry on doing whatever. This blog post is not for you.</p>
<h2>If you are the better end of the spectrum you don&#39;t need that stand-up</h2>
<p>I&#39;ve given up working for people who work at the wrong end of the spectrum, I&#39;m not working for crappy enterprise companies that have all of their other bullshit problems as well - I&#39;m hopefully never doing it again. My flitting about and <a href="/entries/i-am-not-looking-for-a-job.html">working for free</a> shone the light on the harm that was causing me.</p>
<p>Hopefully you&#39;ve made that call too at some point - well done you beat me to it, now think about why you&#39;re still having those stand-ups and who they&#39;re for. Are they for you and the team or are they for somebody else and is there another way you can get them that information?</p>
<p>In the modern age of distributed and online team-work, purposefully stopping what everybody is doing so they can stand in some sort of daily ritual circle is just plain bizarre.</p>
]]></description><link>http://codeofrob.com/entries/stand-ups-are-a-crutch.html</link><guid isPermaLink="true">http://codeofrob.com/entries/stand-ups-are-a-crutch.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 12 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Learn functional programming with me - Improving our data structure with maps]]></title><description><![CDATA[<p>Carrying on..</p>
<ul>
<li><a href="/entries/learn-functional-programming-with-me---a-mission-statement.html">Mission statement</a></li>
<li><a href="/entries/learn-functional-programming-with-me---drawing-a-square.html">Drawing a square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---moving-the-square.html">Moving the square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---attributes-and-vectors.html">Attributes and vectors</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-my-workflow.html">Improving my workflow</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-lots-more-state.html">Creating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---mutating-lots-of-state.html">Mutating lots of state</a></li>
</ul>
<p>I mentioned in the <a href="/entries/learn-functional-programming-with-me---mutating-lots-of-state.html">last entry</a> that I was uncomfortable passing vectors around the place, because it means all of the functions that take in these vectors dependent on the <em>order</em> of information in these vectors and it&#39;s not at all clear what we&#39;re passing around.</p>
<p>I&#39;ve been pointed in the direction of Maps and Records, and for now I&#39;ll start with Maps as they seem the most lightweight way of improving this situation.</p>
<p>Let&#39;s look at where we create our initial state first, as we&#39;ll refactor our way up from there.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initState []
 [
   <span class="number">1</span>
   <span class="list">(<span class="title">for</span><span class="body"> [x <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">16</span> <span class="number">2</span>)</span></span>
         y <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">8</span> <span class="number">2</span>)</span></span>]
     [<span class="list">(<span class="title">*</span><span class="body"> x <span class="number">30</span>)</span></span> <span class="list">(<span class="title">*</span><span class="body"> y <span class="number">30</span>)</span></span> <span class="number">20</span> <span class="number">20</span>]
   )</span></span>
 ]
)</span></span></code></pre>
<p>What I&#39;m doing here is creating a vector that looks like this</p>
<pre><code>[ <span class="number">1</span> [<span class="number">0</span> <span class="number">0</span>] ]</code></pre>
<p>What is 1? What is the second vector? What is this nonsense?</p>
<p>How about returning a map instead of a vector from initState?</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initState []
 { 
   <span class="keyword">:direction</span> <span class="number">1</span>
   <span class="keyword">:enemies</span> <span class="list">(<span class="title">for</span><span class="body"> [x <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">16</span> <span class="number">2</span>)</span></span>
                  y <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">8</span> <span class="number">2</span>)</span></span>]
               [<span class="list">(<span class="title">*</span><span class="body"> x <span class="number">30</span>)</span></span> <span class="list">(<span class="title">*</span><span class="body"> y <span class="number">30</span>)</span></span> <span class="number">20</span> <span class="number">20</span>]
   )</span></span>
 } 
)</span></span></code></pre>
<p>So the difference is we&#39;re now using curly braces, and specifying key-value pairs for our values. (Bear in mind that this returned map is for all intents and purposes going to be immutable, so we haven&#39;t got to worry too much about exposing this state (I think)</p>
<p>Well actually, the rest of this is bit opaque as well, why not split out the enemy constructor into its own function?</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initEnemy [x y w h]
 [<span class="list">(<span class="title">*</span><span class="body"> x <span class="number">30</span>)</span></span> <span class="list">(<span class="title">*</span><span class="body"> y <span class="number">30</span>)</span></span> <span class="number">20</span> <span class="number">20</span>]
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> initState []
 { 
   <span class="keyword">:direction</span> <span class="number">1</span>
   <span class="keyword">:enemies</span> <span class="list">(<span class="title">for</span><span class="body"> [x <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">16</span> <span class="number">2</span>)</span></span>
                  y <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">8</span> <span class="number">2</span>)</span></span>]
              <span class="list">(<span class="title">initEnemy</span><span class="body"> x y <span class="number">20</span> <span class="number">20</span>)</span></span>
   )</span></span>
 } 
)</span></span></code></pre>
<p>And if we&#39;ve gone that far, why not go further and make that a map as well?</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initEnemy [x y w h]
 {
  <span class="keyword">:x</span> <span class="list">(<span class="title">*</span><span class="body"> x <span class="number">30</span>)</span></span>
  <span class="keyword">:y</span> <span class="list">(<span class="title">*</span><span class="body"> y <span class="number">30</span>)</span></span>
  <span class="keyword">:w</span> w
  <span class="keyword">:h</span> h
 }
)</span></span></code></pre>
<p>Now my data structure looks like this</p>
<pre><code>{
  <span class="method">direction:</span> <span class="number">1</span>
  <span class="method">enemies:</span> [
    { <span class="method">x:</span> <span class="number">0</span>, <span class="method">y:</span> <span class="number">0</span>, <span class="method">w:</span> <span class="number">0</span>, <span class="method">h:</span> <span class="number">0</span> },
    { <span class="method">x:</span> <span class="number">0</span>, <span class="method">y:</span> <span class="number">0</span>, <span class="method">w:</span> <span class="number">0</span>, <span class="method">h:</span> <span class="number">0</span> },
    { <span class="method">x:</span> <span class="number">0</span>, <span class="method">y:</span> <span class="number">0</span>, <span class="method">w:</span> <span class="number">0</span>, <span class="method">h:</span> <span class="number">0</span> },
    { <span class="method">x:</span> <span class="number">0</span>, <span class="method">y:</span> <span class="number">0</span>, <span class="method">w:</span> <span class="number">0</span>, <span class="method">h:</span> <span class="number">0</span> },
    // etc

  ]
}</code></pre>
<p>Bloomin&#39; marvellous. Now, this all still builds - although if I run it it&#39;ll fall over in disaster. This is because of mis-matched function calls, as I&#39;m passing these maps around and the functions are expecting vectors.</p>
<p>Type safety was mentioned in relation to Maps and Records and perhaps Records give me some of that, I&#39;ll look at those later if it becomes a burden.</p>
<p>I need to update functions where I&#39;m using these data structures (which is everywhere), so let&#39;s have a look how I&#39;ll do that:</p>
<pre><code>(defn tick [ctx state]
  (let <span class="string">[[dir enemies] state]</code></pre>
<p>Well, here is my first change, I&#39;m passing in &#39;state&#39; to &#39;tick&#39;, but the de-structuring assignment assumes that state is a vector and un-packs it accordingly, this is a valid operation against a map but is junk to my code so nothing happens.</p>
<p>Instead what I want to do is unpack the state I need from the map so I can use it.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> tick [ctx state]
  <span class="list">(<span class="title">let</span><span class="body"> [enemies <span class="list">(<span class="body"><span class="keyword">:enemies</span> state)</span></span>]</code></pre>
<p>Now, this is going to say, let &#39;enemies&#39; equal the result of the value found at the key :enemies, so this is how we access maps.</p>
<p>&#39;<em>enemies</em>&#39; is now a sequence of maps, and in order to render I&#39;ll have to un-pack that too if we&#39;re taking a direct approach to getting this code working again.</p>
<pre><code><span class="list">(<span class="title">doseq</span><span class="body"> [enemy enemies] 
  <span class="list">(<span class="title">let</span><span class="body"> [{<span class="keyword">:keys</span> [x y w h]} enemy]
    <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx x y w h)</span></span>
  )</span></span>
)</span></span></code></pre>
<p>In this case, I&#39;m unpacking several keys from enemy at the same time using the special form &quot;:keys&quot;, that&#39;s kinda cool.</p>
<p>Our call to doLogic remains unchanged, as we merely pass in the state and expect the new state back in the same form.</p>
<pre><code><span class="list">(<span class="title">js/setTimeout</span><span class="body"> <span class="list">(<span class="title">fn</span><span class="body"> []
  <span class="list">(<span class="title">tick</span><span class="body"> ctx <span class="list">(<span class="title">doLogic</span><span class="body"> state)</span></span>)</span></span>
)</span></span> <span class="number">33</span>  )</span></span></code></pre>
<p>However, the doLogic function expects a vector and does things with more vectors, so it&#39;ll need changing as well.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> doLogic [[direction enemies]]
  [
    <span class="list">(<span class="title">getNextDirection</span><span class="body"> direction enemies)</span></span>
    <span class="list">(<span class="title">for</span><span class="body"> [[x y w h] enemies]
      <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">=</span><span class="body"> direction <span class="number">1</span>)</span></span>
        [<span class="list">(<span class="title">inc</span><span class="body"> x)</span></span> y w h]
        [<span class="list">(<span class="title">dec</span><span class="body"> x)</span></span> y w h]
      )</span></span>
    )</span></span>
  ]
)</span></span></code></pre>
<p>I&#39;ll not bother un-packing here, at the moment everything needs all of the state, but I will split out the enemy logic into its own function for easier comprehension.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> doLogic [state]
  {
    <span class="keyword">:direction</span> <span class="list">(<span class="title">directionLogic</span><span class="body"> state)</span></span>
    <span class="keyword">:enemies</span> <span class="list">(<span class="title">enemiesLogic</span><span class="body"> state)</span></span>
  }
)</span></span></code></pre>
<p><em>Now this is the old directionLogic</em>, we&#39;ll need to pull our enemies and direction out of our map.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> directionLogic [direction enemies]
  <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> direction <span class="number">1</span>)</span></span>
    <span class="list">(<span class="title">let</span><span class="body"> [right <span class="list">(<span class="title">apply</span><span class="body"> max <span class="list">(<span class="title">map</span><span class="body"> <span class="list">(<span class="title">fn</span><span class="body"> [[x y w h] e] x)</span></span> enemies)</span></span>)</span></span>]
      <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">&gt;</span><span class="body"> right <span class="number">600</span>)</span></span> <span class="number">-1</span> <span class="number">1</span>)</span></span>
    )</span></span>
    <span class="list">(<span class="title">let</span><span class="body"> [left <span class="list">(<span class="title">apply</span><span class="body"> min <span class="list">(<span class="title">map</span><span class="body"> <span class="list">(<span class="title">fn</span><span class="body"> [[x y w h] e] x)</span></span> enemies)</span></span>)</span></span>]
      <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">&lt;</span><span class="body"> left <span class="number">0</span>)</span></span> <span class="number">1</span> <span class="number">-1</span>)</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>So step by step</p>
<p><em>Our new signature and un-packing statement</em></p>
<pre><code><span class="list">(<span class="title"><span class="built_in">defn</span></span> directionLogic <span class="collection">[state]</span>
  <span class="list">(<span class="title"><span class="built_in">let</span></span> <span class="collection">[<span class="collection">{<span class="attribute">:keys</span> <span class="collection">[direction enemies]</span>}</span> state]</span></code></pre>
<p><em>We can pass in :x as the function to invoke (in this case the &#39;map&#39; operation will take :x out of each enemy)</em></p>
<pre><code><span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> direction <span class="number">1</span>)</span></span>
  <span class="list">(<span class="title">let</span><span class="body"> [right <span class="list">(<span class="title">apply</span><span class="body"> max <span class="list">(<span class="title">map</span><span class="body"> <span class="keyword">:x</span> enemies)</span></span>)</span></span>]
    <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">&gt;</span><span class="body"> right <span class="number">600</span>)</span></span> <span class="number">-1</span> <span class="number">1</span>)</span></span>
  )</span></span></code></pre>
<p><em>And the same for the other direction</em></p>
<pre><code>  <span class="list">(<span class="title">let</span><span class="body"> [left <span class="list">(<span class="title">apply</span><span class="body"> min <span class="list">(<span class="title">map</span><span class="body"> <span class="keyword">:x</span> enemies)</span></span>)</span></span>]
    <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">&lt;</span><span class="body"> left <span class="number">0</span>)</span></span> <span class="number">1</span> <span class="number">-1</span>)</span></span>
  )</span></span></code></pre>
<p>I&#39;ll look at tidying this up in a moment, but first I want to sort out my enemiesLogic function and check that my code still works
and I still have moving yellow squares in my browser.</p>
<p><em>Our old enemies logic</em></p>
<pre><code><span class="list">(<span class="title">for</span><span class="body"> [[x y w h] enemies]
  <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">=</span><span class="body"> direction <span class="number">1</span>)</span></span>
    [<span class="list">(<span class="title">inc</span><span class="body"> x)</span></span> y w h]
    [<span class="list">(<span class="title">dec</span><span class="body"> x)</span></span> y w h]
  )</span></span>
)</span></span></code></pre>
<p><em>Well first off, we now have a function for this, so that looks like this</em></p>
<pre><code><span class="list">(<span class="title"><span class="built_in">defn</span></span> enemiesLogic <span class="collection">[state]</span>
  <span class="list">(<span class="title"><span class="built_in">let</span></span> <span class="collection">[<span class="collection">{<span class="attribute">:keys</span> <span class="collection">[direction enemies]</span>}</span> state</code></pre>
<p><em>But I&#39;m going to do something different here</em></p>
<pre><code>    func (if(= direction <span class="number">1</span>) <span class="keyword">inc</span> <span class="keyword">dec</span>)
   ]</code></pre>
<p>Rather than the old if statement, I&#39;m going to choose a function (called &#39;func&#39;) based on direction to create the new x with.</p>
<p><em>Creating the new list of enemies</em></p>
<pre><code><span class="list">(<span class="title">for</span><span class="body"> [enemy enemies]
  {
    <span class="keyword">:x</span> <span class="list">(<span class="title">func</span><span class="body"> <span class="list">(<span class="body"><span class="keyword">:x</span> enemy)</span></span>)</span></span>
    <span class="keyword">:y</span> <span class="list">(<span class="body"><span class="keyword">:y</span> enemy)</span></span>
    <span class="keyword">:w</span> <span class="list">(<span class="body"><span class="keyword">:w</span> enemy)</span></span>
    <span class="keyword">:h</span> <span class="list">(<span class="body"><span class="keyword">:h</span> enemy)</span></span>
  }
)</span></span></code></pre>
<p>So here I copy the old state out of the old enemy, and make the new state with a modified x.</p>
<p>Hitting F5 in my browser</p>
<p><img src="/img/yellow_squares.png" alt="A load of yellow squares" title="Space invaders"></p>
<p>Success.</p>
<p><strong>Summary</strong></p>
<p>I&#39;m slightly happier with maps, as it means the order in which I put data into these structures becomes irrelevant, my OO self is crying out though because I&#39;m passing around effectively property bags on which I&#39;m performing decisions and logic from.</p>
<p>It feels as if I&#39;m going to be repeating myself a lot if I have to keep addressing state this way, and hopefully I&#39;ll discover a better way as I progress, as this just feels like procedural code written in Clojure.</p>
]]></description><link>http://codeofrob.com/entries/learn-functional-programming-with-me---improving-our-data-structure-with-maps.html</link><guid isPermaLink="true">http://codeofrob.com/entries/learn-functional-programming-with-me---improving-our-data-structure-with-maps.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 11 Jun 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Learn functional programming with me - Mutating lots of state]]></title><description><![CDATA[<p>It&#39;s all very well and good being able to render a load of squares based on a sequence of positions, but what I actually want to achieve now is moving all of those squares.</p>
<ul>
<li><a href="/entries/learn-functional-programming-with-me---a-mission-statement.html">Mission statement</a></li>
<li><a href="/entries/learn-functional-programming-with-me---drawing-a-square.html">Drawing a square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---moving-the-square.html">Moving the square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---attributes-and-vectors.html">Attributes and vectors</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-my-workflow.html">Improving my workflow</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-lots-more-state.html">Creating lots of state</a></li>
</ul>
<p><strong>Mutating lots of state</strong></p>
<p>Thing is, what I can&#39;t do is pop into that sequence and start <em>changing</em> state, what I want to do each frame is (I think), create a <em>new</em> sequence and pass that into the next call of &#39;tick&#39;, <em>erk</em>.</p>
<p>Well, actually this shouldn&#39;t be such a big deal, how about creating a method that takes in a sequence and returns a new sequence where each item is slightly different from the original?</p>
<pre><code>(defn doLogic [enemies]
  (<span class="keyword">for</span> <span class="string">[[x y] enemies]
    [(inc x) y]
  )
)</code></pre>
<p>doLogic takes in a sequence of enemies, then uses a list comprehension to create a new list of enemies but with &#39;x&#39; increased by one.</p>
<p>Now all we have to do is pass this new sequence into the next call of &#39;tick&#39;</p>
<pre><code><span class="list">(<span class="title">tick</span><span class="body"> <span class="list">(<span class="title">doLogic</span><span class="body"> enemies)</span></span>)</span></span></code></pre>
<p>Okay, that was <em>too</em> easy, from what I see here this is also going to be lazy up until the point we call &#39;doseq&#39;, it makes me feel kinda weird though that we&#39;re apparently creating a completely new sequence every single frame - memory-wise this has to be a bad idea and in the JS environment this is going to make me cry.</p>
<p>I have no idea what is going on under the hood though, so if any Clojurescript guru can enlighten me I&#39;d appreciate it.</p>
<p><strong>Making our invaders move left to right and back again</strong></p>
<p>Well, the first thing I actually need to do is set up my invaders properly in some sort of known &#39;game space&#39;, this isn&#39;t really related to the functional programming bit so I&#39;m going to pretty much side-step over it by modifying the code and explaining what I&#39;ve done. (normally I&#39;d use a camera system and be a bit more clever, but not the point of this exercise)</p>
<p><em>The first thing I&#39;ve done is moved the ctx call outside of tick</em></p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> ^<span class="keyword">:export</span> init []
  <span class="list">(<span class="title">let</span><span class="body"> [ctx <span class="list">(<span class="title">context</span><span class="body">)</span></span>] 
    <span class="list">(<span class="title">tick</span><span class="body"> ctx <span class="list">(<span class="title">initState</span><span class="body">)</span></span>)</span></span> 
  )</span></span>
)</span></span></code></pre>
<p>And actually, I&#39;m going to specify the width and height as 640x480 and hard-code the whole thing</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> ^<span class="keyword">:export</span> init []
  <span class="list">(<span class="title">let</span><span class="body"> [ctx <span class="list">(<span class="title">context</span><span class="body"> <span class="number">640</span> <span class="number">480</span>)</span></span>] 
    <span class="list">(<span class="title">tick</span><span class="body"> ctx <span class="list">(<span class="title">initState</span><span class="body">)</span></span>)</span></span> 
  )</span></span>
)</span></span>

<span class="list">(<span class="title">defn</span><span class="body"> context [width height]
  <span class="list">(<span class="title">let</span><span class="body"> [target <span class="list">(<span class="body">.getElementById js/document <span class="string">"target"</span>)</span></span>]
    [
      <span class="list">(<span class="body">.getContext target <span class="string">"2d"</span>)</span></span> 
      <span class="list">(<span class="title">set</span><span class="body">! <span class="list">(<span class="body">. target -width)</span></span> width)</span></span>
      <span class="list">(<span class="title">set</span><span class="body">! <span class="list">(<span class="body">. target -height)</span></span> height)</span></span>
    ]
  )</span></span>
)</span></span></code></pre>
<p>And now I&#39;ve done this, I can do a little bit of maths and say that if I make my space invaders 20x20, then I can fit 8 of them on the screen horizontally and 4 vertically (leaving space for our good guy and between them!)</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initState []
 <span class="list">(<span class="title">for</span><span class="body"> [x <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">16</span> <span class="number">2</span>)</span></span>
       y <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">8</span> <span class="number">2</span>)</span></span>]
   [<span class="list">(<span class="title">*</span><span class="body"> x <span class="number">30</span>)</span></span> <span class="list">(<span class="title">*</span><span class="body"> y <span class="number">30</span>)</span></span> <span class="number">20</span> <span class="number">20</span>]
 )</span></span>
)</span></span></code></pre>
<p>I&#39;m also now including a width and height with each of my little invaders, which means I&#39;ll need to modify my logic function</p>
<pre><code>(defn doLogic [enemies]
  (<span class="keyword">for</span> <span class="string">[[x y w h] enemies]
    [(inc x) y w h]
  )
)</code></pre>
<p>And rendering them now looks like this</p>
<pre><code>(doseq <span class="string">[[x y w h] enemies] (drawSquare ctx x y w h))</code></pre>
<p>Now this doesn&#39;t solve that what I want to do is change the direction of my squares when they reach the edge of the playing area, this is bit more interesting.</p>
<p><strong>Variable state changes</strong></p>
<p>Well, when do my space invaders switch direction? Well, I went on <a href="http://www.youtube.com/watch?v=437Ld_rKM2s">Youtube</a> to look at the original behaviour of space invaders and it seems that if you destroy a column of invaders then it won&#39;t switch direction until at least one invader has reached the edge of the screen.</p>
<p>What&#39;s an efficient way of handling this I wonder, well I&#39;ll need a direction as part of my main game state so I&#39;ll get that in first</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> initState []
 [
   <span class="number">1</span>
   <span class="list">(<span class="title">for</span><span class="body"> [x <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">16</span> <span class="number">2</span>)</span></span>
         y <span class="list">(<span class="title">range</span><span class="body"> <span class="number">0</span> <span class="number">8</span> <span class="number">2</span>)</span></span>]
     [<span class="list">(<span class="title">*</span><span class="body"> x <span class="number">30</span>)</span></span> <span class="list">(<span class="title">*</span><span class="body"> y <span class="number">30</span>)</span></span> <span class="number">20</span> <span class="number">20</span>]
   )</span></span>
 ]
)</span></span></code></pre>
<p>Okay, so now initState will return a vector containing a direction (1), and a sequence of enemies. I&#39;m really not confortable with these arbitrary lists of state so I&#39;ll look for some way to make them tidier shortly I think.</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> tick [ctx state]
  <span class="list">(<span class="title">let</span><span class="body"> [[dir enemies] state]
    <span class="list">(<span class="title">clearScreen</span><span class="body"> ctx)</span></span> 
    <span class="list">(<span class="title">doseq</span><span class="body"> [[x y w h] enemies] <span class="list">(<span class="title">drawSquare</span><span class="body"> ctx x y w h)</span></span>)</span></span>
    <span class="list">(<span class="title">js/setTimeout</span><span class="body"> <span class="list">(<span class="title">fn</span><span class="body"> []
      <span class="list">(<span class="title">tick</span><span class="body"> ctx <span class="list">(<span class="title">doLogic</span><span class="body"> state)</span></span>)</span></span>
    )</span></span> <span class="number">33</span>  )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>In my tick method, I&#39;ll use a destructuring assignment to unpack this vector into a direction and an enemies sequence so I can easily go through that sequence.</p>
<pre><code>(defn doLogic <span class="string">[[direction enemies]]</span>
  [
    direction
    (<span class="keyword">for</span> <span class="string">[[x y w h] enemies]
      [(inc x) y w h]
    )
  ]
)</code></pre>
<p>And in my doLogic method, I&#39;ll simply re-return the diretion, and the modified sequence of enemies.</p>
<p>All I need to do now is return a different direction if a certain condition is true</p>
<ul>
<li>Are we going right? Are any of the entities too far to the right?</li>
<li>Are we going left? Are any of the entities too far to the left?</li>
</ul>
<p>Okay, how about</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> doLogic [[direction enemies]]
  [
    <span class="list">(<span class="title">getNextDirection</span><span class="body"> direction enemies)</span></span>
    <span class="list">(<span class="title">for</span><span class="body"> [[x y w h] enemies]
      <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">=</span><span class="body"> direction <span class="number">1</span>)</span></span>
        [<span class="list">(<span class="title">inc</span><span class="body"> x)</span></span> y w h]
        [<span class="list">(<span class="title">dec</span><span class="body"> x)</span></span> y w h]
      )</span></span>
    )</span></span>
  ]
)</span></span></code></pre>
<p>We&#39;ll ask another function what the next direction is going to be, if the current direction is &#39;1&#39;, we&#39;ll inc x, anx if the current direction is not 1, we&#39;ll dec x.</p>
<p>I can implement getNextDirection like so, taking in current and enemies</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> getNextDirection [current enemies]
  <span class="list">(<span class="title">if</span><span class="body"> <span class="list">(<span class="title">=</span><span class="body"> current <span class="number">1</span>)</span></span>
    <span class="list">(<span class="title">let</span><span class="body"> [right <span class="list">(<span class="title">apply</span><span class="body"> max <span class="list">(<span class="title">map</span><span class="body"> <span class="list">(<span class="title">fn</span><span class="body"> [[x y w h] e] x)</span></span> enemies)</span></span>)</span></span>]
      <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">&gt;</span><span class="body"> right <span class="number">600</span>)</span></span> <span class="number">-1</span> <span class="number">1</span>)</span></span>
    )</span></span>
    <span class="list">(<span class="title">let</span><span class="body"> [left <span class="list">(<span class="title">apply</span><span class="body"> min <span class="list">(<span class="title">map</span><span class="body"> <span class="list">(<span class="title">fn</span><span class="body"> [[x y w h] e] x)</span></span> enemies)</span></span>)</span></span>]
      <span class="list">(<span class="title">if</span><span class="body"><span class="list">(<span class="title">&lt;</span><span class="body"> left <span class="number">0</span>)</span></span> <span class="number">1</span> <span class="number">-1</span>)</span></span>
    )</span></span>
  )</span></span>
)</span></span></code></pre>
<p>I can say, if we&#39;re going right, check out what the max x position is, and change direction if it&#39;s greater than 600, and vice versa if it&#39;s not.</p>
<p>This all works, my squares go from left to right and back again and keep bouncing around.</p>
<p><img src="/img/yellow_squares.png" alt="A load of yellow squares" title="Space invaders"></p>
<p>I have another question at this point, which is &quot;how many times is this list being iterated, should I be optimising this some how?&quot;</p>
]]></description><link>http://codeofrob.com/entries/learn-functional-programming-with-me---mutating-lots-of-state.html</link><guid isPermaLink="true">http://codeofrob.com/entries/learn-functional-programming-with-me---mutating-lots-of-state.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 06 Jun 2013 09:30:00 GMT</pubDate></item></channel></rss>