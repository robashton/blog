<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>RSS for Node</generator><lastBuildDate>Wed, 24 Jun 2020 22:57:55 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><author><![CDATA[Rob Ashton]]></author><item><title><![CDATA[Purerl - Some questions from #CodeMeshLdn]]></title><description><![CDATA[<p>Talk at CodeMesh now given, because of a demo god intervention (I discovered a Purerl compiler bug mid-demo, how&#39;s that for luck?) I didn&#39;t have time to receive questions during my actual session, but I kept a note of questions asked afterwards and will cover them here for those not present during their discussion.</p>
<p>I&#39;ll carry on linking these Purerl posts from each other before that however, &#39;cos it serves as a handy indexing mechanism in lieu of having a real blog engine..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
<li><a href="/entries/codemesh-2019---purerl-and-otp-talk.html">Codemesh 2019 - Purerl and OTP</a></li>
</ul>
<h1 id="useful-links">Useful links</h1>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<h1 id="some-questions-then">Some questions then.</h1>
<ul>
<li>What if I use the wrong types in my FFI</li>
<li>What if I don&#39;t use Effect in my FFI</li>
<li>How do you map complex union types back into Purerl when doing FFI (specifically, errors)</li>
<li>Are there any situations where you feel the types in Purescript would get in the way and you&#39;d just write Erlang instead?</li>
</ul>
<h1 id="wrong-types">Wrong types</h1>
<p>In one demo I did a very simple import of the base64 module from base Erlang:</p>
<pre><code class="language-erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(cool@foreign)</span>.

<span class="hljs-keyword">-export</span><span class="hljs-params">([base64/<span class="hljs-number">1</span>])</span>.

<span class="hljs-function"><span class="hljs-title">base64</span><span class="hljs-params">(String)</span> -&gt;</span> base64:encode(String).
</code></pre>
<p>Consumed in purescript with the following import</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> base64 :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
</code></pre>
<p>And all is right and proper, from the erlang shell, I can call this function</p>
<pre><code class="language-bash">Eshell V10.5  (abort with ^G)
1&gt; l(cool@ps).
{module,cool@ps}
2&gt; cool@ps:base64(&lt;&lt;<span class="hljs-string">"foo"</span>&gt;&gt;).
&lt;&lt;<span class="hljs-string">"Zm9v"</span>&gt;&gt;
3&gt;</code></pre>
<p>So.. what if we lie about the types at play here?</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> base64 :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Int</span>
</code></pre>
<p>Well, the result of calling the purescript function from Erlang isn&#39;t going to change because it doesn&#39;t care about types</p>
<pre><code class="language-bash">Eshell V10.5  (abort with ^G)
1&gt; l(cool@ps).
{module,cool@ps}
2&gt; cool@ps:base64(&lt;&lt;<span class="hljs-string">"foo"</span>&gt;&gt;).
&lt;&lt;<span class="hljs-string">"Zm9v"</span>&gt;&gt;
3&gt;</code></pre>
<p>How about using it in a purescript application?</p>
<pre><code class="language-haskell">
<span class="hljs-title">doSomething</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">doSomething</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> result = base64 <span class="hljs-string">"wow"</span>
  _ &lt;- <span class="hljs-type">Console</span>.log $ show result
  pure unit
</code></pre>
<pre><code class="language-bash">
&gt; (cool@ps:doSomething())().
** exception error: bad argument
     <span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span>  integer_to_binary/1
        called as integer_to_binary(&lt;&lt;<span class="hljs-string">"d293"</span>&gt;&gt;)
     <span class="hljs-keyword">in</span> call from data_show@foreign:showIntImpl/1 (output/Data.Show/data_show@foreign.erl, line 4)
     <span class="hljs-keyword">in</span> call from main@ps:<span class="hljs-string">'-doSomething/0-fun-0-'</span>/1 (/home/robashton/talks/purescript_beam/demo_2/src/Main.purs, line 19)
</code></pre>
<p>Passing the variable around in Purescript land, nothing cares - it is assumed that if you&#39;ve said something is a certain type, that it is that type and all type checking will be done on that basis - sooner or later, every bit of data will end up getting somewhere where it needs to be serialized whether for display, storage or transmission and that will involve passing the data into code that makes assumptions based on the type being passed in and you&#39;ll get a runtime crash.</p>
<p>So obviously the answer is &quot;don&#39;t do it&quot; - when building FFI, getting types correct is essential - definitely something worth testing.</p>
<h1 id="what-if-i-dont-use-effect-in-my-ffi">What if I don&#39;t use Effect in my FFI</h1>
<p>You maniac, why would you want to lie about side effects??! Well it turns out to not actually be a big deal, the main reason you&#39;re telling the type system about side effects is for your own benefit and if you choose to lie then at some point you will be hoisted on your own petard and we will all laugh at you. An example of places where this could happen is with legacy code and logging, I guess, probably, maybe.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-module</span><span class="hljs-params">(cool@foreign)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([ add/<span class="hljs-number">2</span> ])</span>.

<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(X,Y)</span> -&gt;</span>
  io:format(user, <span class="hljs-string">"WOW, I AM ADDING ~p and ~p"</span>, [ X, Y ]),
  X + Y.
</code></pre>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> add :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>

<span class="hljs-title">doSomething</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">doSomething</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> result = add <span class="hljs-number">5</span> <span class="hljs-number">6</span>
  _ &lt;- <span class="hljs-type">Console</span>.log $ show result
  pure unit
</code></pre>
<pre><code class="language-bash">8&gt; (main@ps:doSomething())().
WOW, I AM ADDING 5 and 611
unit</code></pre>
<p>Is this the future you want to be a part of? No I didn&#39;t think so - friends don&#39;t let friends write effectful code without declaring it as effectful.</p>
<h1 id="how-do-you-map-complex-union-types-back-into-purerl">How do you map complex union types back into Purerl </h1>
<p>Consider the <a href="http://erlang.org/documentation/doc-6.2/lib/kernel-3.0.3/doc/html/file.html#list_dir-1">read_dir API</a> in classic Erlang: </p>
<pre><code class="language-erlang">  list_dir(Dir) -&gt; {ok, Filenames} | {error, Reason}

  Types:

  Dir = name_all()
  Filenames = [filename()]
  Reason = posix()
         | badarg
         | {no_translation, Filename :: unicode:latin1_binary()}
</code></pre>
<p>There are some decisions to be made when writing code that exposes this API to the Purerl world, and none of them are <em>wrong</em> per se. The default position is usually &quot;Map the exact API across as it is, and if you don&#39;t like it then fix it by writing a somewhat more Purescripty wrapper&quot;.</p>
<p>So that would be.</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">module</span> Erl.File <span class="hljs-keyword">where</span>

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>Which means then passing in the constructors to the FFI so this can be constructed in Erlang without knowing about these types at the top level.</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> <span class="hljs-type">ListDir_</span> :: (<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">ListDirFailure</span>)  
                            -&gt; <span class="hljs-type">ListDirFailure</span> 
                            -&gt; (<span class="hljs-type">Binary</span> -&gt; <span class="hljs-type">ListDirFailure</span>) 
                            -&gt; <span class="hljs-type">ListDirFailure</span> -&gt; (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
                            -&gt; (<span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>)))
                            -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
<span class="hljs-title">listDir</span> = listDir_ <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">ListDirBadArg</span> <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Left</span> <span class="hljs-type">Right</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>Youch that&#39;s a mouthful, obviously we can make that a bit more legible with</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> <span class="hljs-type">ListDir_</span> :: (<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">ListDirFailure</span>)  
                            -&gt; <span class="hljs-type">ListDirFailure</span> 
                            -&gt; (<span class="hljs-type">Binary</span> -&gt; <span class="hljs-type">ListDirFailure</span>) 
                            -&gt; <span class="hljs-type">ListDirFailure</span> -&gt; <span class="hljs-type">ListDirResult</span>
                            -&gt; (<span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; <span class="hljs-type">ListDirResult</span>
                            -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">ListDirResult</span>

<span class="hljs-type">ListDir</span>  :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">ListDirFailure</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>))
<span class="hljs-type">ListDir</span> = listDir_ <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">ListDirBadArg</span> <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Left</span> <span class="hljs-type">Right</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">ListDirResult</span> = <span class="hljs-type">Either</span> <span class="hljs-type">ListDirResult</span> (<span class="hljs-type">List</span> <span class="hljs-type">String</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ListDirFailure</span> = <span class="hljs-type">ListDirPosixFailure</span> <span class="hljs-type">Atom</span></span>
                    | <span class="hljs-type">ListDirBadArg</span>
                    | <span class="hljs-type">ListDirNoTranslation</span> <span class="hljs-type">Binary</span>
</code></pre>
<p>And the FFI then looks like</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">listDir_</span><span class="hljs-params">(ListDirPosixFailure, ListDirBadArg, NoTranslationError, Failure, Success, Dir)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
    <span class="hljs-keyword">case</span> file:list_dir(Dir) <span class="hljs-keyword">of</span>
      { ok, Filenames } -&gt; Success(Filenames);
      { error, { no_translation, Encoded } } -&gt; Failure(NoTranslationError(Encoded));
      { error, badarg } -&gt; Failure(ListDirBadArg);
      { error, Posix } -&gt; Failure(ListDirPosixFailure(Posix));
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>If you wanted a nicer API on top of this, let&#39;s call it &quot;CoolFileApi&quot; for example, you&#39;d then wrap <em>that</em> binding with something nicer - having at least type-safe-ified the original API in all of its glory, and then you&#39;re doing the work in Purescript rather than Erlang, I haven&#39;t ran this through a compiler so I probably got it a bit wrong but you&#39;ll get picture..</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> CoolFileApi <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Erl.File <span class="hljs-keyword">as</span> File
<span class="hljs-keyword">import</span> Data.Newtype (<span class="hljs-title">unwrap</span>, <span class="hljs-title">wrap</span>)

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Filepath</span> = <span class="hljs-type">Filepath</span> <span class="hljs-type">String</span></span>
<span class="hljs-title">derive</span> <span class="hljs-keyword">instance</span> ntFilepath :: <span class="hljs-type">Newtype</span> <span class="hljs-type">Filepath</span> _

<span class="hljs-type">ListDir</span> :: <span class="hljs-type">Filepath</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">CoolListDirFailureReason</span> (<span class="hljs-type">List</span> <span class="hljs-type">Filepath</span>))
<span class="hljs-type">ListDir</span> <span class="hljs-type">Filepath</span> = <span class="hljs-keyword">do</span>
  result &lt;- <span class="hljs-type">File</span>.<span class="hljs-type">ListDir</span> $ unwrap <span class="hljs-type">Filepath</span>
  pure $ either (<span class="hljs-type">Left</span> &lt;&lt;&lt; nativeFailureToShinyFailure) (<span class="hljs-type">Right</span> &lt;&lt;&lt; wrap)


<span class="hljs-title">nativeFailureToShinyFailure</span> :: <span class="hljs-type">File</span>.<span class="hljs-type">ListDirFailure</span> -&gt; <span class="hljs-type">CoolListDirFailureReason</span>
<span class="hljs-title">nativeFailureToShinyFailure</span> reason =
  <span class="hljs-keyword">case</span> reason <span class="hljs-keyword">of</span>
    <span class="hljs-type">ListDirBadArg</span> -&gt; <span class="hljs-type">CoolListDirBadArg</span>
    <span class="hljs-type">ListDirNoTranslation</span> filename -&gt; <span class="hljs-type">CoolListDirNoTranslation</span> filename
    <span class="hljs-type">ListDirPosixFailure</span> a -&gt; <span class="hljs-type">CoolListDirPosixFailure</span> (atomToCool a)

<span class="hljs-title">atomToCool</span>  :: <span class="hljs-type">Erl</span>.<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">CoolListDirPosixFailure</span>
<span class="hljs-title">atomToCool</span> a = 
  <span class="hljs-keyword">case</span> a <span class="hljs-keyword">of</span>
    (atom <span class="hljs-string">"eacces"</span>) -&gt; <span class="hljs-type">Eaccess</span>
    (atom <span class="hljs-string">"enoent"</span>) -&gt; <span class="hljs-type">Enoent</span>
    <span class="hljs-comment">--- etc</span>
</code></pre>
<p>Essentially getting rid of those arbitary atoms and Erlang data types and representing them as native Purerl data types. You <em>could</em> just write your binding directly in this way from the get-go, but it&#39;s considered polite to write the low level bindings as directly as possible to the original API because it saves on mental load (and doing as little work as possible in the Erlang code), the documentation for the original API is then applicable to the low level bindings too.</p>
<h1 id="arent-types-a-huge-pain-in-the-ass">Aren&#39;t types a huge pain in the ass?</h1>
<p>I mean that&#39;s what I heard for this question, and it&#39;s a bit of a loaded one - people that aren&#39;t used to working in a sensibly typed environment tend to look at the typed environment as being a form of burden, instead of an aid to help you write better code. Some of the conversation around this was about whether we&#39;d be re-writing some of our core functionality in Purescript, and whether that would even be desirable as the types might get in the way of productivity.</p>
<p>I think that actually there is a lot of desire internally for us to do our next re-write of our orchestration logic in Purerl for example, but because  we&#39;re in a different language with a different way of looking at the world, the API and even the design of that would probably not look anything like the original (and the same goes for our media workflow engine too). We&#39;re not afraid of re-writes, we write code  to be thrown away after all - but usually when doing a re-write of a module, you get to learn from the previous iterations and Do It Better this time - the pendulum of compensation from past mistakes slowly zeroes in around an ideal design and by version 3 or 4 you&#39;re laughing.</p>
<p>The main pain of having to do things differently is while there will be some lessons that can be passed into the rewrites into Purescript, a lot of the design decisions don&#39;t come through to the new world and you&#39;re essentially going back to version 1/2 again for that component. That&#39;ll be the pain that we&#39;ll go through but we&#39;ll come out the other side as better Purescript developers so we&#39;re not afraid of that.</p>
<p>I really can&#39;t see a point where I&#39;d say that types are going to get in the way of Just Getting Stuff Done, in my experience so far, the type system is just a more honest way of looking at effort, when you&#39;re working in a sloppy-typed environment you can pretend that it&#39;s really easy and fun and you&#39;re dead smart so it&#39;s okay, but you end up paying the cost in bugs and mistakes eventually - the upfront cost might not be there but you&#39;ve just shifted it elsewhere. Types also typically enable you to write better abstractions to lessen the load of repeated operations - you can be a lot more clever when the compiler has your back.</p>
<p>It&#39;s very hard to currently view what a typed version of some of our core IP would look like, but that&#39;s down to our inexperience rather than it being an impossible task; it&#39;ll come in time.</p>
<h1 id="anyway">Anyway</h1>
<p>That&#39;s some answers, if you have more questions about Purerl/Stetson/Pinto <a href="http://twitter.com/robashton">hit me up on Twitter</a> and I&#39;ll do my best to help..</p>
]]></description><link>http://codeofrob.com/entries/purerl---some-questions-from-codemeshldn.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl---some-questions-from-codemeshldn.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 07 Nov 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Codemesh 2019 - Purerl and OTP talk]]></title><description><![CDATA[<p>Just a note that I&#39;ll be appearing at <a href="https://www.codemesh.io/conferences/code-mesh-ldn/">Codemesh</a> on Thursday (11:25) to give a talk where I go over some of the stuff we&#39;ve been working on at <a href="https://www.id3as.com/home">Work</a>(tm) this year - with a focus on some of the implementation details and nitty gritty/etc.</p>
<p>I silently blogged some of this recently, basically showing off how we&#39;ve now got the ability to write OTP applications in Purescript these days, and indeed are. The posts are all linked below for the majority of folk who are sensible enough not to not subscribe to this sorry excuse for a blog.</p>
<p>Here is a sneaky peek as to what a gen server looks like in this world, tasty no?</p>
<pre><code class="language-haskell">
<span class="hljs-title">findByIsbn</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findByIsbn</span> isbn = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    result &lt;- <span class="hljs-type">Redis</span>.get (dbId isbn) connection
    pure $ <span class="hljs-type">CallReply</span> result state

<span class="hljs-title">findAll</span> :: <span class="hljs-type">Effect</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findAll</span> = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    books &lt;- <span class="hljs-type">Redis</span>.findAll dbPrefix connection
    pure $ <span class="hljs-type">CallReply</span> books state

<span class="hljs-comment">-- Nothing special about this, just a function that returns a certain type</span>
<span class="hljs-comment">-- We can supply arbitrary arguments to this via the gensup</span>
<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.startLink serverName $ init args

<span class="hljs-comment">-- And those arguments can then end up in here, which just needs to return an effect of our State type</span>
<span class="hljs-title">init</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  connection &lt;- <span class="hljs-type">Redis</span>.open args.connectionString
  pure $ { connection }
</code></pre>
<h1 id="the-blog-entries">The blog entries</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="useful-links">Useful links</h1>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
]]></description><link>http://codeofrob.com/entries/codemesh-2019---purerl-and-otp-talk.html</link><guid isPermaLink="true">http://codeofrob.com/entries/codemesh-2019---purerl-and-otp-talk.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 05 Nov 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purescript interop with native Erlang - Interacting with Redis]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<p>We&#39;ve handwaved over the contents of the <a href="https://github.com/id3as/demo-ps/blob/master/server/src/Native/Redis.purs">Redis</a> module so far in the demo app, showing only that we can use it from our <a href="https://github.com/id3as/demo-ps/blob/master/server/src/BookLibrary.purs">BookLibrary.purs</a> like any other module as follows.</p>
<pre><code class="language-haskell">
<span class="hljs-title">update</span> :: <span class="hljs-type">Book</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Either</span> <span class="hljs-type">String</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">update</span> book =
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-type">Redis</span>.put (dbId book.isbn) book connection
    pure $ <span class="hljs-type">CallReply</span> (<span class="hljs-type">Right</span> book) state
</code></pre>
<p>That&#39;s pretty tidy, so let&#39;s look at the type of that function so we understand the Purescript side of things first and foremost</p>
<pre><code class="language-haskell">
<span class="hljs-title">put</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">DbId</span> -&gt; a -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
</code></pre>
<p>For any type &#39;a&#39; that implements WriteForeign, we&#39;re a function that takes a DbId, an A and a RedisConnection to produce an Effect of type Unit - this pretty much makes sense on the surface, DbId is just a newtype around String, and given a Key and a Value (which we can get from calling writeJSON on our type &#39;a&#39;), we can dump stuff in Redis - but how?</p>
<p>Let&#39;s take a step back a moment and approach this from the <em>other</em> end.</p>
<p>There is an application for accessing Redis in Erlang, called <a href="https://github.com/wooga/eredis">eredis</a> imaginatively enough, the usage of which looks a little like this.</p>
<pre><code class="language-erlang">
   { ok, C } = eredis:start_link(ConnectionString),

   eredis:q(C, [ &lt;&lt;<span class="hljs-string">"SET"</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">"key"</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">"value"</span>&gt;&gt; ]).
</code></pre>
<p>So what we want to do is surface this meaningfully to Purescript is define some foreign imports in our <em>Redis.purs</em>, which map onto their native counterparts in our <em>Redis.erl.</em></p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">ConnectionString</span> :: <span class="hljs-type">Type</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">RedisConnection</span> :: <span class="hljs-type">Type</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> open :: <span class="hljs-type">ConnectionString</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">RedisConnection</span>
</code></pre>
<p>By importing a foreign type, we&#39;re saying to Purescript &quot;Hey, this thing exists in Erlang but we don&#39;t know what is inside it, but we want to model it as something we can pass around thanks&quot;, the ConnectionString comes from sys.config and the RedisConnection is actually a Pid but we don&#39;t need to know that.</p>
<p>By importing a foreign function, we&#39;re saying that there is a function in Erlang with this name and signature and we&#39;d like to call it from Purescript. The &quot;open&quot; function we&#39;re importing from Erlang takes one of those ConnectionStrings and produces an Effect of type RedisConnection.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(ConnectionString)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, C } = eredis:start_link(ConnectionString),
      C
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>We wrap our actual functionality in a function, because that&#39;s how an Effect is modelled in Purerl, and we can return our &#39;Connection&#39; as an opaque type to Purescript when this Effect is processed. I&#39;ve made the decision here to match directly on <em>{ ok, C }</em> which means we&#39;ll crash at runtime if we can&#39;t open a connection - an alternative API could look like this.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">open_</span><span class="hljs-params">(ConnectionString, Just, Nothing)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, C } = <span class="hljs-keyword">case</span> eredis:start_link(ConnectionString) <span class="hljs-keyword">of</span>
                    { ok, C } -&gt; Just(C);
                    _ -&gt; Nothing
                    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>where</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> open_ :: <span class="hljs-type">ConnectionString</span> -&gt; (<span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>) -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>  -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">RedisConnection</span>)

<span class="hljs-title">open</span> :: <span class="hljs-type">ConnectionString</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">RedisConnection</span>
<span class="hljs-title">open</span> connectionString = open_ connectionString <span class="hljs-type">Just</span> <span class="hljs-type">Nothing</span>
</code></pre>
<p>I&#39;ve chosen to &quot;let it crash&quot;, as that fits with how I&#39;d build the supervsion tree in Erlang around this (Restart periodically every 30s until the connection works please), but either approach is valid and not one I have strong opinions on at this time. (an Either with the failure reason would also be an option).</p>
<p>Anyway, going back to that <em>put</em> function with all of this in mind, we want to keep the Erlang pretty minimal, so some transformation on the Purescript side will be required. </p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> put_ :: <span class="hljs-type">DbId</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>

<span class="hljs-title">put</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">DbId</span> -&gt; a -&gt; <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">put</span> id obj conn =
  put_ id (writeJSON obj) conn
</code></pre>
<p>Purescript knows how to turn our obj into JSON so we&#39;ll do that there, and then use a foreign function that takes just the primitive objects for use within Erlang with eredis.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-define</span><span class="hljs-params">(SET(Key, Value)</span>, [ &lt;&lt;"SET"&gt;&gt;, Key, Value ]).

<span class="hljs-function"><span class="hljs-title">put_</span><span class="hljs-params">(Id, Data, Pid)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
      { ok, &lt;&lt;<span class="hljs-string">"OK"</span>&gt;&gt;} = eredis:q(Pid, ?SET(Id, Data)),
      ok
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>Now, this is not necessarily how we should approach building an FFI for a native library, as we&#39;re making some decisions in Erlang that could be made in Purescript, a more traditional FFI would look like this.</p>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">q</span><span class="hljs-params">(Pid, Operation)</span> -&gt;</span>
  eredis:q(Pid, Operation).
</code></pre>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> q :: <span class="hljs-type">RedisConnection</span> -&gt; <span class="hljs-type">List</span> <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">Binary</span>)
</code></pre>
<p>And then we could build the API we <em>actually</em> want on top of <em>that</em> instead - I&#39;ve rather skipped that step in my demo for clarity, but if I was producing a library wrapper for publication that&#39;s probably the approach I&#39;d take, as unwieldy as it is to actually use it means we end up writing more Purescript and less Erlang.</p>
<p>This is the approach that erl-cowboy and Stetson took, whereas erl-pinto takes the direct approach to &quot;desired API&quot;, making the concession that it&#39;ll be easier to build without 1-1 FFI in existence. Either way, it&#39;s pretty easy to call into existing code in Erlang.</p>
<h1 id="next-up">Next up</h1>
<p>We&#39;ve pretty much covered the surface area of the demo project, so I&#39;ll be going off on a little journey talking about some of the common things that we like to do in Erlang and how to get that behaviour into Purerl, if I get any questions about these posts I&#39;ll follow up with answers in blog format also.</p>
]]></description><link>http://codeofrob.com/entries/purescript-interop-with-native-erlang---interacting-with-redis.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purescript-interop-with-native-erlang---interacting-with-redis.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 29 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Shared code twixt Purescript server and client]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<p>We&#39;ve got a basic model representing our &#39;book&#39;</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">module</span> Books <span class="hljs-keyword">where</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Book</span> = { <span class="hljs-title">isbn</span> :: <span class="hljs-type">String</span>
            , <span class="hljs-title">title</span> :: <span class="hljs-type">String</span>
            , <span class="hljs-title">author</span> :: <span class="hljs-type">String</span>
            }</span>
</code></pre>
<p>Which is pretty terribly exciting - the key thing to note here is that this is a plain ol&#39; record containing primitive types - this makes it pretty shareable as far as view models go (Let&#39;s ignore that we&#39;re using it for persistence here, demo code gonna demo code).</p>
<p>We&#39;ve shoved Books.purs into a folder called &#39;shared&#39; which has been softlinked from both the client and server directories, which means it will be separately compiled into JS And Purescript respectively.</p>
<p>There is a great library over in Purescript world called <a href="https://github.com/justinwoo/purescript-simple-json">simple-json</a> which defines a <em>ReadForeign</em> and <em>WriteForeign</em> for these basic types, which means that the functions readJSON and writeJSON will do the back and forth between JSON and the Purescript types.</p>
<p>There is also (thanks to the efforts of <a href="https://github.com/purerl/purescript-simple-json">@nwolverson</a>, a port of this library exists on the Purerl side of things which works in exactly the same way, using <a href="https://github.com/talentdeficit/jsx">JSX</a> under the hood. This is a fairly common pattern across the Purerl world, and you&#39;ll see when browsing the org repos that a lot of the code from the JS Purescript world has been ported across with minimal changes so that the two worlds look as alike as possible.</p>
<p>So, in the previous post we loaded a list of Books out of our genserver in Cowboy and simply called writeJSON on it.</p>
<pre><code class="language-haskell">
<span class="hljs-meta"># Rest.contentTypesProvided (\req state -&gt; Rest.result (jsonWriter : nil) req state)</span>

<span class="hljs-title">jsonWriter</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">Tuple2</span> <span class="hljs-type">String</span> (<span class="hljs-type">Req</span> -&gt; a -&gt; (<span class="hljs-type">Effect</span> (<span class="hljs-type">RestResult</span> <span class="hljs-type">String</span> a)))
<span class="hljs-title">jsonWriter</span> = tuple2 <span class="hljs-string">"application/json"</span> (\req state -&gt; <span class="hljs-type">Rest</span>.result (writeJSON state) req state)
</code></pre>
<p>If we open up the client code, we can see</p>
<pre><code class="language-haskell">
<span class="hljs-title">maybeBook</span> &lt;- <span class="hljs-type">H</span>.liftAff $ loadItem $ <span class="hljs-string">"/api/books/"</span> &lt;&gt; isbn

<span class="hljs-comment">-- where</span>

<span class="hljs-title">loadItem</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">ReadForeign</span> a =&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Aff</span> (<span class="hljs-type">Either</span> <span class="hljs-type">String</span> a)
<span class="hljs-title">loadItem</span> uri = <span class="hljs-keyword">do</span>
  response &lt;- <span class="hljs-type">AX</span>.get <span class="hljs-type">AXResponse</span>.string uri
  <span class="hljs-keyword">case</span> response.body <span class="hljs-keyword">of</span>
     <span class="hljs-type">Left</span> err -&gt; pure $ <span class="hljs-type">Left</span> <span class="hljs-string">"No"</span>
     <span class="hljs-type">Right</span> json -&gt; pure $ bimap show identity $ readJSON json
</code></pre>
<p>That is all that is required to shift data between the server Purescript and the client Purescript which is pretty tidy indeed! Because we&#39;re using the same library, any custom implementations of <em>ReadForeign</em> and <em>WriteForeign</em> we might choose to write can then also be shared between the two.</p>
<p>Obviously sharing code between both client and server is something that should be entered into with caution, typically sharing a lot of business logic is the sign of a problem - but I can easily see us ending up in a world where we can start using Halogen on the server-side to pre-render HTML for serving to the client much in the same way that the ReactJS community have started doing similar with NodeJS.</p>
<h1 id="next-up">Next up</h1>
<p>We&#39;ll look at our bindings to Redis, to get a feel for what interop with &quot;native&quot; Erlang with FFI looks like.</p>
]]></description><link>http://codeofrob.com/entries/shared-code-twixt-purescript-server-and-client.html</link><guid isPermaLink="true">http://codeofrob.com/entries/shared-code-twixt-purescript-server-and-client.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 27 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Building a Purescript web server with Stetson and Pinto]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowboy we&#39;re using)</li>
</ul>
<p>Having now gotten a basic OTP application up and running, it&#39;d be nice to get some data out to the world.</p>
<h1 id="cowboy">Cowboy</h1>
<p>Cowboy is the defacto web server in the Erlang world, each route loosely maps to a module which has callbacks defined in it to handle various stages of the decisioning process.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-module</span><span class="hljs-params">(my_handler)</span>.

<span class="hljs-keyword">-export</span><span class="hljs-params">([init/<span class="hljs-number">2</span>,
         get_text/<span class="hljs-number">2</span>,
         content_types_provided/<span class="hljs-number">2</span>
        ])</span>.

<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req, _Opts)</span> -&gt;</span>
  { cowboy_rest, Req, #state{} }.

<span class="hljs-function"><span class="hljs-title">content_types_provided</span><span class="hljs-params">(Req, State)</span> -&gt;</span>
  {[{ &lt;&lt;<span class="hljs-string">"text/plain"</span>&gt;&gt;, get_text}], Req, State}.

<span class="hljs-function"><span class="hljs-title">get_json</span><span class="hljs-params">(Req, State)</span> -&gt;</span>
  { &lt;&lt;<span class="hljs-string">"Hello World"</span>&gt;&gt;, Req, State }.
</code></pre>
<p>This is directly representable in Purescript, using <a href="https://github.com/purerl/purescript-erl-cowboy">erl-cowboy</a>.</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> MyHandler <span class="hljs-keyword">where</span>

<span class="hljs-title">init</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">InitHandler</span> a a
<span class="hljs-title">init</span> = mkEffectFn2 \req c -&gt; pure (initResult c req)

<span class="hljs-title">content_types_provided</span> :: <span class="hljs-keyword">forall</span> s. <span class="hljs-type">ContentTypesProvidedHandler</span> s
<span class="hljs-title">content_types_provided</span> =  mkEffectFn2 \req s -&gt; pure $
  restResult
    (contentTypesProvidedResult $ fromFoldable
      [ tuple2 (<span class="hljs-type">ContentType</span> <span class="hljs-string">"text"</span> <span class="hljs-string">"plain"</span> <span class="hljs-type">AnyParams</span>) (<span class="hljs-type">ProvideCallback</span> $ atom <span class="hljs-string">"asText"</span>) ]
    )
    s req


<span class="hljs-title">asText</span> :: <span class="hljs-keyword">forall</span> s. <span class="hljs-type">EffectFn2</span> <span class="hljs-type">Req</span> s (<span class="hljs-type">Tuple3</span> <span class="hljs-type">String</span> <span class="hljs-type">Req</span> s)
<span class="hljs-title">asText</span> = mkEffectFn2 \req s -&gt; pure $ tuple3 <span class="hljs-string">"Hello World"</span> req s
</code></pre>
<p>However, this doesn&#39;t make the best use of Purescript itself - and writing out a few dozen handlers like this would soon get a bit tedious, which is why I went away and wrote <a href="https://github.com/id3as/purescript-erl-stetson">Stetson</a>. Purescript is a functional programming language and it makes sense that rather than provide a bunch of loosely typed callbacks referred to by name using strings, that we built an API that took functions to do all the heavy lifting.</p>
<pre><code class="language-haskell">
<span class="hljs-title">helloWorld</span> :: <span class="hljs-type">StetsonHandler</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">helloWorld</span> =
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-type">Rest</span>.initResult req unit)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (tuple2 <span class="hljs-string">"text/html"</span> asText) req state)
    # <span class="hljs-type">Rest</span>.yeeha
    <span class="hljs-keyword">where</span> 
      asText req state = <span class="hljs-keyword">do</span>
        <span class="hljs-type">Rest</span>.result <span class="hljs-string">"Hello World"</span> req state)
</code></pre>
<p>The idea of course being that we can configure Stetson/Cowboy at the top level by providing a pile of functions and abstract over the common bits like &quot;This is an accept handler that turns state into JSON because State has the typeclass &quot;WriteForeign&quot;, and start to get rid of a lot of duplication across our routes.</p>
<pre><code class="language-haskell">
<span class="hljs-title">init</span> :: <span class="hljs-type">BookWebStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  <span class="hljs-type">Stetson</span>.configure
    # <span class="hljs-type">Stetson</span>.route <span class="hljs-string">"/api/books"</span> books
    # <span class="hljs-type">Stetson</span>.route <span class="hljs-string">"/api/books/:isbn"</span> book
    # <span class="hljs-type">Stetson</span>.static <span class="hljs-string">"/assets/[...]"</span> (<span class="hljs-type">PrivDir</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/assets"</span>)
    # <span class="hljs-type">Stetson</span>.static <span class="hljs-string">"/[...]"</span> (<span class="hljs-type">PrivFile</span> <span class="hljs-string">"demo_ps"</span> <span class="hljs-string">"www/index.html"</span>)
    # <span class="hljs-type">Stetson</span>.port args.webPort
    # <span class="hljs-type">Stetson</span>.bindTo <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>
    # <span class="hljs-type">Stetson</span>.startClear <span class="hljs-string">"http_listener"</span>
  pure $ <span class="hljs-type">State</span> {}
</code></pre>
<p>where books and book are handlers as described above. In our own applications, we have ended up with pretty much the entire web server and all routes in a single file - which is in stark contrast to our usual Erlang apps where we have a folder containing dozens of separate erlang modules.</p>
<pre><code class="language-haskell"><span class="hljs-title">books</span> :: <span class="hljs-type">StetsonHandler</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">books</span> =
  <span class="hljs-type">Rest</span>.handler (\req -&gt; <span class="hljs-keyword">do</span>
                        state &lt;- <span class="hljs-type">BookLibrary</span>.findAll
                        <span class="hljs-type">Rest</span>.initResult req state)
    # <span class="hljs-type">Rest</span>.allowedMethods (\req state -&gt; <span class="hljs-type">Rest</span>.result (<span class="hljs-type">Stetson</span>.<span class="hljs-type">POST</span> :  <span class="hljs-type">Stetson</span>.<span class="hljs-type">HEAD</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">GET</span> : <span class="hljs-type">Stetson</span>.<span class="hljs-type">OPTIONS</span> : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesProvided (\req state -&gt; <span class="hljs-type">Rest</span>.result (jsonWriter : nil) req state)
    # <span class="hljs-type">Rest</span>.contentTypesAccepted (\req state -&gt; <span class="hljs-type">Rest</span>.result ((tuple2 <span class="hljs-string">"application/json"</span> acceptJson) : nil)
                                req state)
    # <span class="hljs-type">Rest</span>.yeeha
    <span class="hljs-keyword">where</span> 
          acceptJson req state = <span class="hljs-keyword">do</span>
            body &lt;- allBody req mempty
            result &lt;- either (pure &lt;&lt;&lt; <span class="hljs-type">Left</span> &lt;&lt;&lt; show) <span class="hljs-type">BookLibrary</span>.create $ readJSON $ unsafeCoerce body
            <span class="hljs-keyword">case</span> result <span class="hljs-keyword">of</span>
                 <span class="hljs-type">Left</span> err -&gt; <span class="hljs-type">Rest</span>.result false (setBody err req) state
                 <span class="hljs-type">Right</span> c -&gt; <span class="hljs-type">Rest</span>.result true req state

<span class="hljs-title">jsonWriter</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">WriteForeign</span> a =&gt; <span class="hljs-type">Tuple2</span> <span class="hljs-type">String</span> (<span class="hljs-type">Req</span> -&gt; a -&gt; (<span class="hljs-type">Effect</span> (<span class="hljs-type">RestResult</span> <span class="hljs-type">String</span> a)))
<span class="hljs-title">jsonWriter</span> = tuple2 <span class="hljs-string">"application/json"</span> (\req state -&gt; <span class="hljs-type">Rest</span>.result (writeJSON state) req state)
</code></pre>
<p>So that&#39;s a handler that has a state of type <em>&#39;List Book&#39;</em>, which it gets from our <em>BookLibrary</em> via a call (as in the previous blog entry), jsonWriter being a function as decscribed above - simply taking that model and spitting it out as JSON, leveraging our model which happens to implement that type class.</p>
<p>We&#39;ll look more into that in the next entry, where we talk about that model and how we&#39;re using it on both client and server.</p>
]]></description><link>http://codeofrob.com/entries/building-a-purescript-web-server-with-stetson-and-pinto.html</link><guid isPermaLink="true">http://codeofrob.com/entries/building-a-purescript-web-server-with-stetson-and-pinto.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 22 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Building on top of OTP with Purescript with Pinto]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowbou we&#39;re using)</li>
</ul>
<p>We left the last post demonstrating that an end-to-end Purescript project was essentially a pile of Purescript written in the right place, in order that the usual Erlang application/rebar3/etc can just work with it.</p>
<h1 id="that-entry-point-again-then">That entry point again then</h1>
<p>We looked at <em>BookApp.purs</em>, which compiled into an Erlang module called <em>bookApp@ps</em>. which ends up in <em>src/compiled_ps</em> and gets picked up with the usual Erlang structure. Let&#39;s look at that file and see what we see:</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> BookApp <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Prelude
<span class="hljs-keyword">import</span> BookSup <span class="hljs-keyword">as</span> BookSup

<span class="hljs-keyword">import</span> Pinto.App <span class="hljs-keyword">as</span> App

<span class="hljs-title">start</span> = <span class="hljs-type">App</span>.simpleStart <span class="hljs-type">BookSup</span>.startLink</code></pre>
<p>That <em>simpleStart</em> function is just a Pinto helper that describes an entry point that doesn&#39;t worry about inputs, and provided a Supervisor will start that Supervisor when the application is started.</p>
<p>This gets compiled into the following Erlang</p>
<pre><code class="language-erlang"><span class="hljs-comment">% Generated by purs version 0.12.3</span>
<span class="hljs-keyword">-module</span><span class="hljs-params">(bookApp@ps)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([start/<span class="hljs-number">0</span>, start/<span class="hljs-number">2</span>])</span>.
<span class="hljs-keyword">-compile</span><span class="hljs-params">(nowarn_shadow_vars)</span>.
<span class="hljs-keyword">-compile</span><span class="hljs-params">(nowarn_unused_vars)</span>.
<span class="hljs-keyword">-compile</span><span class="hljs-params">(no_auto_import)</span>.
<span class="hljs-keyword">-file</span><span class="hljs-params">(<span class="hljs-string">"src/BookApp.purs"</span>, <span class="hljs-number">8</span>)</span>.
<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> -&gt;</span> (pinto_app@ps:simpleStart((bookSup@ps:startLink()))).
<span class="hljs-keyword">-file</span><span class="hljs-params">(<span class="hljs-string">"src/BookApp.purs"</span>, <span class="hljs-number">8</span>)</span>.
<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_@<span class="hljs-number">0</span>,_@<span class="hljs-number">1</span>)</span> -&gt;</span> ((pinto_app@ps:simpleStart((bookSup@ps:startLink())))(_@<span class="hljs-number">0</span>, _@<span class="hljs-number">1</span>)).</code></pre>
<p>If get rid of the cruft, that&#39;s essentially just</p>
<pre><code class="language-erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(bookApp@ps)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([start/<span class="hljs-number">0</span>, start/<span class="hljs-number">2</span>])</span>.
<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> -&gt;</span> (pinto_app@ps:simpleStart((bookSup@ps:startLink()))).
<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_@<span class="hljs-number">0</span>,_@<span class="hljs-number">1</span>)</span> -&gt;</span> ((pinto_app@ps:simpleStart((bookSup@ps:startLink())))(_@<span class="hljs-number">0</span>, _@<span class="hljs-number">1</span>)).</code></pre>
<p>This is just a standard application module that you&#39;d find in an Erlang application, exporting the usual start function that calls into a supervisor to start it. This is the only time I&#39;ll be loading up the compiled Purescript as it&#39;s the simplest example - but nearly all of the Pinto helpers are about making sure we can end up exposing a module that looks like the equivalent OTP erlang module.</p>
<p>The supervisor? More of the same</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> BookSup <span class="hljs-keyword">where</span>

<span class="hljs-comment">-- [[ imports redacted ]]</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Pinto</span>.<span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> = <span class="hljs-type">Sup</span>.startLink <span class="hljs-string">"book_sup"</span> init

<span class="hljs-title">init</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">SupervisorSpec</span>
<span class="hljs-title">init</span> = <span class="hljs-keyword">do</span>
  connectionString &lt;- <span class="hljs-type">BookConfig</span>.connectionString
  webPort &lt;- <span class="hljs-type">BookConfig</span>.webPort
  pure $ buildSupervisor
                # supervisorStrategy <span class="hljs-type">OneForOne</span>
                # supervisorChildren ( ( buildChild
                                       # childType <span class="hljs-type">Worker</span>
                                       # childId <span class="hljs-string">"book_web"</span>
                                       # childStart <span class="hljs-type">BookWeb</span>.startLink  { webPort } )
                                       : 
                                       ( buildChild
                                       # childType <span class="hljs-type">Worker</span>
                                       # childId <span class="hljs-string">"book_library"</span>
                                       # childStart <span class="hljs-type">BookLibrary</span>.startLink { connectionString } )
                                        : nil)</code></pre>
<p><em>Sup.startLink</em> is a Pinto helper that&#39;ll end up calling our usual <em>supervisor:start_link</em> under the hood, with our <em>init</em> function being invoked within the context of that created supervisor and returning a supervisor spec when invoked. </p>
<p>The supervisor spec structure is quite a complicated tangle of maps in Erlang, and while possible to directly represent these in Purescript with records, there are convenience builders/etc provided by Pinto to describe these specs in a more Purescripty and type safe manner - all of these values are pretty much relatable right back to the OTP documentation which is handy and intentional.</p>
<p>Now, let&#39;s break down one of these gen servers to see what we can see - we&#39;ll have to do this piece-meal as there is a lot to uncover. We&#39;ll be looking at <em>BookLibrary.purs</em>, invoked above in the second child of the supervision tree with BookLibrary.startLink and the code for which is shown below..</p>
<pre><code class="language-haskell">
<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">ServerName</span> <span class="hljs-string">"book_library"</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">BookLibraryStartArgs</span> = {
  <span class="hljs-title">connectionString</span> :: <span class="hljs-type">ConnectionString</span>
}</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.startLink serverName $ init args
</code></pre>
<p>So there is nothing too special about this, we&#39;re exporting a function called startLink that takes some configuration from the supervisor, and that calls into the Pinto function <em>Gen.startLink</em> with the serverName, and an init function to invoke within the context of the started GenServer along with those args. This isn&#39;t disimilar to how this looks in the Erlang world so far. </p>
<p>That serverName construct represents both the unique identifier for this started process, and also encapsulates the type of the &#39;state&#39; that is held by the GenServer, and will be used in all interactions with the <em>Gen</em> module.</p>
<p>That init function?</p>
<pre><code class="language-haskell">
<span class="hljs-title">init</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  connection &lt;- <span class="hljs-type">Redis</span>.open args.connectionString
  pure $ { connection }
</code></pre>
<p>Takes place inside the context of the newly started GenServer, and is responsible for effectfully creating the initial state of the GenServer, which is just a Redis connection (We&#39;ll talk about that later). This is actually all we need to create a running GenServer as everything else is entirely optonal.</p>
<p>Obviously that&#39;s useless, so let&#39;s look at how we can externally call into this GenServer to do something useful</p>
<pre><code class="language-haskell">
<span class="hljs-title">findAll</span> :: <span class="hljs-type">Effect</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findAll</span> = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    books &lt;- <span class="hljs-type">Redis</span>.findAll dbPrefix connection
    pure $ <span class="hljs-type">CallReply</span> books state
</code></pre>
<p>We can export a plain ol&#39; Purescript function called findAll that returns a plain ol&#39; Effect producing a List of Book, and we can do the rest of the work by invoking a &#39;call&#39; with the <em>Gen</em> module, by giving <em>Gen.doCall</em> our <em>serverName</em> construct, we are able to then provide a typed callback that  will be invoked within the context of the gen-server as part of a <em>handle_call</em>, and therefore gain access to the state and return some books by calling into the Redis connection.</p>
<p>The original Erlang would of course look a little like this.</p>
<pre><code class="language-erlang">
<span class="hljs-keyword">-export</span><span class="hljs-params">([start_link/<span class="hljs-number">1</span>, 
         init/<span class="hljs-number">1</span>,
         find_all/<span class="hljs-number">0</span>])</span>.

<span class="hljs-keyword">-record</span><span class="hljs-params">(args, {
    connection_string :: connection_string()
    })</span>.

<span class="hljs-keyword">-record</span><span class="hljs-params">(state, {
    connection :: redis:connection()
  })</span>.

<span class="hljs-function"><span class="hljs-title">find_all</span><span class="hljs-params">()</span> -&gt;</span>
  gen_server:call({via, gproc, {n, l, ?MODULE}}, find_all).

<span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(Args)</span> -&gt;</span>
  gen_server:start_link({via, gproc, {n, l, ?MODULE}}, ?MODULE, [Args], []).

<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([#args { connection_string = ConnectionString }])</span> -&gt;</span>
  { ok, Connection } = redis:open(ConnectionString),
  {ok, #state { connection = Connection }}.

<span class="hljs-function"><span class="hljs-title">handle_call</span><span class="hljs-params">(find_all, _Sender, State = #state { connection = Connection })</span> -&gt;</span>
  { ok, Result } = redis:find_prefix(dbPrefix, Connection),
  { reply, Result, State }.

</code></pre>
<p>This is a bit unwieldy, lacks any notion of type safety across the calls being made, but is still pleasantly relatable to the Purescript variant.</p>
<pre><code class="language-haskell">
<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">ServerName</span> <span class="hljs-string">"book_library"</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">BookLibraryStartArgs</span> = {
  <span class="hljs-title">connectionString</span> :: <span class="hljs-type">ConnectionString</span>
}</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = {
  <span class="hljs-title">connection</span> :: <span class="hljs-type">RedisConnection</span>
}</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> args =
  <span class="hljs-type">Gen</span>.startLink serverName $ init args

<span class="hljs-title">init</span> :: <span class="hljs-type">BookLibraryStartArgs</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">State</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  connection &lt;- <span class="hljs-type">Redis</span>.open args.connectionString
  pure $ { connection }

<span class="hljs-title">findAll</span> :: <span class="hljs-type">Effect</span> (<span class="hljs-type">List</span> <span class="hljs-type">Book</span>)
<span class="hljs-title">findAll</span> = 
  <span class="hljs-type">Gen</span>.doCall serverName \state@{ connection } -&gt; <span class="hljs-keyword">do</span>
    books &lt;- <span class="hljs-type">Redis</span>.findAll dbPrefix connection
    pure $ <span class="hljs-type">CallReply</span> books state
</code></pre>
<p>Note: Wrapping up a connection behind a genserver is nearly always not the thing you want to do (effectively it introduces a read/write lock), but sample code gonna sample code.</p>
<p>Next up, we&#39;ll look at how we could use this GenServer from Stetson to provide a restful JSON API to our client.</p>
]]></description><link>http://codeofrob.com/entries/building-on-top-of-otp-with-purescript-with-pinto.html</link><guid isPermaLink="true">http://codeofrob.com/entries/building-on-top-of-otp-with-purescript-with-pinto.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 20 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[The structure of an end-to-end Purescript OTP project]]></title><description><![CDATA[<p>All the posts so far..</p>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
</ul>
<p>Useful links</p>
<ul>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> The demo codebase we&#39;re talking about here</li>
<li><a href="https://github.com/id3as/purescript-erl-pinto">erl-pinto</a> (the opinionated bindings to OTP we&#39;re using)</li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">erl-stetson</a> (the opinionated bindings to Cowbou we&#39;re using)</li>
</ul>
<h1 id="the-structure-of-an-end-to-end-purescript-otp-project">The structure of an end-to-end Purescript OTP project</h1>
<p>Our <a href="https://github.com/id3as/demo-ps">demo-ps</a> can be viewed as two separate chunks of code, the base layer is just a plain old Erlang application built using rebar3 and such, and then on top of that we have a pile of Purescript that compiles into Erlang that can then be compiled and used by the usual development workflow.</p>
<h1 id="the-erlangy-bits">The Erlangy bits</h1>
<ul>
<li><em>release-files</em>: Assets to be shipped during the release process</li>
<li><em>src</em>: This is usually where the Erlang application lives, but there is no Erlang code<ul>
<li><em>demo_ps.app.src</em>: The entry point, just points at a Purescript module, we&#39;ll talk about that</li>
</ul>
</li>
<li><em>rebar.config</em>: Erlang dependencies and such</li>
<li><em>priv</em>: Assets/files we want access to from code (static html/js/etc is covered here)</li>
</ul>
<h1 id="the-purescript-bits">The purescript bits</h1>
<ul>
<li><em><a href="https://github.com/id3as/demo-ps/tree/master/server">server</a></em>: The Purescript application that we want to compile into Erlang lives here</li>
<li><em><a href="https://github.com/id3as/demo-ps/tree/master/client">client</a></em>: The Purescript application we want to compile into JS lives here</li>
<li><em>Makefile</em>: Turns the Purescript into JS/Erlang</li>
<li><em>shared</em>: Contains Purescript we&#39;ll share between JS/Erlang</li>
</ul>
<p>In an ideal world, we&#39;d just have a single Purescript entry point and forego our interaction with the Erlang world, but this would involve building out a lot more tooling - the result of this, is that sometimes you will be bringing Purescript dependencies down that require Erlang dependencies and then adding these to rebar.config and the entry point will be your responsibility.</p>
<p>The purescript dependencies can be found in in <em>psc-package.json</em> inside the server and client directories, and the Erlang dependencies can be found in rebar.config at the top level.</p>
<p>As a team already familiar with the Erlang ecosystem, this doesn&#39;t represent a hardship for us; but this definitely represents an area which could be improved by an enterprising developer or two, probably a plugin to the Purescript stack that stashes the rebar assets/etc in another build folder and allows us to just write PS/Erlang in the right place. (But this would then also involve modifying our editor plugins to know about this new structure, and as you can already see, it&#39;s a lot of work when we have something that is already functional..)</p>
<h1 id="that-entry-point-then">That entry point then</h1>
<pre><code class="language-erlang">{application, demo_ps,
 [{description, <span class="hljs-string">"An OTP application"</span>},
  {vsn, <span class="hljs-string">"0.1.0"</span>},
  {registered, []},
  {mod, { bookApp@ps, []}},
  {applications,
   [kernel,
    stdlib,
    lager,
    gproc,
    recon,
    cowboy,
    jsx,
    eredis
   ]},
  {env,[]},
  {modules, []},
  {maintainers, []},
  {licenses, []},
  {links, []}
 ]}.</code></pre>
<p>One of the key things to note here, is that we have cowboy as a dependency, this is to support (as mentioned), the Purescript libraries that binds to it (<a href="https://github.com/id3as/purescript-erl-stetson">stetson</a> and <a href="https://github.com/purerl/purescript-erl-cowboy">erl-cowboy</a>. </p>
<p>The other big note, is that entry point module is <em>&#39;bookApp@ps&#39;</em> - that module can be found in server/src/BookApp.purs, which defines a module <em>&#39;BookApp&#39;</em> - the Purescript compiler will compile Purescript modules into *<moduleName>@ps*, as this is unlikely to clash with anything else in the global application namespace. Beyond this entry point there is no Erlang code in the application itself - it&#39;s Purescript all the way down...</p>
<p>The Makefile in <em>server/Makefile</em> does the work of compiling this Purescript into Erlang that can then be compiled by the usual rebar3 toolchain. The gist of the below Makefile being that we take all the .purs files lying around in the &#39;server&#39; folder, and compile them into .erl files that end up in ../../src/compiled_ps.</p>
<p>We&#39;ll go into detail on the Purescript stuff in the next post, as that&#39;s the key; we put a pile of Erlang supporting files in the right location, and then write PS in the other location and everything &quot;just kinda works&quot;.</p>
]]></description><link>http://codeofrob.com/entries/the-structure-of-an-end-to-end-purescript-otp-project.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-structure-of-an-end-to-end-purescript-otp-project.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 15 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Introducing Pinto and Stetson - Opinionated Purescript bindings to OTP and Cowboy]]></title><description><![CDATA[<p>If you&#39;re reading this, you&#39;ve either been given the link to the posts ahead of time cos you&#39;ve asked to see what is going on, or I&#39;ve hit the publish button in which case hooray. Either way, this is a little series of posts going through some of the Purescript/Purerl code that we&#39;ve quietly open sourced on Github under the Apache 2.0 license. Hopefully betwen these posts, the published markdown docs and the sample application there will be enough to get started with.</p>
<p>Over the last year or so, we&#39;ve been gradually building out our capacity to create applications end-to-end in Purescript, compiled to JS on the front-end and compiled to Erlang on the back, building on top of both OTP and our existing libraries from nearly a decade of company history doing business on top of the Erlang stack.</p>
<p>The repositories we&#39;re looking at are:</p>
<ul>
<li><a href="https://github.com/purerl/">Purerl</a> itself</li>
<li>The <a href="https://github.com/purerl/package-sets">purerl-package-sets</a></li>
<li><a href="https://github.com/id3as/purescript-erl-stetson">Stetson</a> (Opinionated Cowboy bindings)</li>
<li><a href="git@github.com:id3as/purescript-erl-pinto.git">Pinto</a> (Opinionated OTP bindings)</li>
<li><a href="https://github.com/id3as/demo-ps">demo-ps</a> (end-to-end sample code)</li>
</ul>
<p>The best place to start if you want to dive right in, is probably the demo-ps project as it demonstrates the usage of most of the above, and that is indeed where we&#39;ll be starting in this series.</p>
<h1 id="purerl">Purerl</h1>
<p>The Purerl organisation contains the core sets of bindings to much of Erlang&#39;s base libraries, as well as the fork of the Purescript compiler that can generate Erlang as a backend. </p>
<h1 id="purerl-package-sets">Purerl-package-sets</h1>
<p>Essentially a pile of Dhall that generates a package.json containing a list of versions of the various Purerl libraries that work together, you&#39;ll not need to touch this directly unless you end up using Purerl internally in an organisation and you want to fork it and add your own internal/private Purerl dependencies.</p>
<h1 id="stetson">Stetson</h1>
<p><a href="https://github.com/ninenines/cowboy">Cowboy</a> is the de-facto webserver in the Erlang world, and <a href="https://github.com/purerl/purescript-erl-cowboy">direct bindings</a> exist for the project already, however when it came time to start building applications on top of this, it was clear that there was little gain to be had by directly using them over simply writing Erlang in the first place. Stetson was my attempt to mirror the experience I&#39;ve had in other functional languages using libraries such as <a href="https://github.com/weavejester/compojure">Compojure</a> and <a href="https://github.com/scotty-web/scotty">Scotty</a>. It isn&#39;t by any means complete, and merely serves as a statement of intent around the kind of interaction I&#39;d personally like to have around routing/etc in a Purerl world. I fully hope/expect that somebody will write a native http server in time rather than simply wrapping Cowboy as I have done here.</p>
<h1 id="pinto">Pinto</h1>
<p>There have been a <a href="https://github.com/purerl/purerl_otp_sandbox">few examples</a> written demonstrating how to interact with OTP from Purerl, but again at the point of building a real application, direct bindings don&#39;t offer a good user experience once you start building out functionality and repeating yourself a whole ton. I cheated a lot when putting together Pinto and skipped the direct bindings step, going straight to the &quot;desired usage&quot; step and doing a pile of cheats around types and such. It seeks to largely mirror the existing OTP interactions, but in a more functional manner. Much like with Stetson, I fully expect/hope that in time somebody (maybe even us) will want a more idiomatic Purescript experience and choose to build something even more opinionated outside the familiar comfort of the OTP vocabulary. For now, we have Pinto.. :)</p>
<h1 id="demo-ps">Demo-ps</h1>
<p>This is a completely pointless web app that uses <a href="https://github.com/id3as/purescript-erl-stetson">purescript-erl-stetson</a>, <a href="https://github.com/id3as/purescript-erl-pinto">purescript-erl-pinto</a>, <a href="https://github.com/purerl/purescript-simple-json">purescript-simple-json</a> and <a href="https://github.com/slamdata/purescript-halogen">purescript-halogen</a> to store data in Redis using some FFI and display it in a single page application, sharing the view models between the server and client components. It seeks to demonstrate rough usages of all of these without cluttering up the interactions with &quot;real code&quot; (read: business logic).</p>
<p>Next post, we&#39;ll look at the structure of the demo-ps project, as understanding this is essential if you wish to build your own.</p>
]]></description><link>http://codeofrob.com/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html</link><guid isPermaLink="true">http://codeofrob.com/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 13 Aug 2019 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purescript on the BEAM - OTP from scratch]]></title><description><![CDATA[<p>Previous entries..</p>
<ul>
<li><a href="/entries/functional-erlang---purescript-on-the-beam---intro.html">Intro</a></li>
<li><a href="/entries/purescript-on-the-beam:-getting-started.html">Getting Started</a></li>
<li><a href="/entries/purescript-on-the-beam---writing-some-basic-code.html">Writing some basic code</a></li>
<li><a href="/entries/purescript-on-the-beam---basic-interop-with-erlang.html">Basic interop with Erlang</a></li>
<li><a href="/entries/purescript-on-the-beam---otp-from-scratch.html">Calling Purecript from Erlang</a></li>
</ul>
<p>Armed with the tools from the last explorations, it should be relatively trivial to start interacting with OTP in Purescript, and we&#39;ll give that a bash directly in this entry to see how well <em>that</em> goes..</p>
<h1 id="writing-a-gen-server-in-purescript">Writing a Gen Server in Purescript</h1>
<p>Ignoring applications and supervisors for a moment, we can probably write a genserver fairly trivially in Purescript directly using an FFI to call into OTP and shuffle some data types</p>
<p>The low level FFI could look a little like this, where the call is just an effect that results in a genserver starting.</p>
<pre><code class="language-erlang">
    -module(genServer@foreign).

    -export([startLinkImpl/<span class="hljs-number">3</span>]).

    startLinkImpl(ServerName, Module, Args) -&gt;
      <span class="hljs-keyword">fun</span>() -&gt;
        gen_server:start_link(ServerName, Module, Args, [])
    <span class="hljs-keyword">end</span>.
</code></pre>
<pre><code class="language-haskell">
    <span class="hljs-keyword">module</span> GenServer <span class="hljs-keyword">where</span>

    <span class="hljs-keyword">import</span> Prelude
    <span class="hljs-keyword">import</span> Erl.Atom
    <span class="hljs-keyword">import</span> Erl.Data.List
    <span class="hljs-keyword">import</span> Erl.Data.Tuple
    <span class="hljs-keyword">import</span> Effect.Uncurried (<span class="hljs-title">mkEffectFn1</span>, <span class="hljs-type">EffectFn1</span>)
    <span class="hljs-keyword">import</span> Effect

    <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">StartLinkResult</span> :: <span class="hljs-type">Type</span>

    <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> startLinkImpl :: forall args. (<span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">Atom</span>) -&gt; <span class="hljs-type">Atom</span> -&gt; args -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>

    startLink :: <span class="hljs-keyword">forall</span> args. (<span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">Atom</span>) -&gt; <span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">EffectFn1</span> args <span class="hljs-type">StartLinkResult</span>
    startLink serverName mod =
      mkEffectFn1 \args -&gt; startLinkImpl serverName mod args
</code></pre>
<p>Note the mkEffectFn1 allowing us to pass this effectful function into Erlang code, and the parameterised argument type allowing us to have custom arguments for the gen server we&#39;re writing.</p>
<p>Allowing us to write a gen server that looks like this:</p>
<pre><code class="language-haskell">
    <span class="hljs-keyword">module</span> TestServer <span class="hljs-keyword">where</span>

    <span class="hljs-keyword">import</span> Prelude
    <span class="hljs-keyword">import</span> Erl.Atom
    <span class="hljs-keyword">import</span> Erl.Data.List
    <span class="hljs-keyword">import</span> Erl.Data.Tuple
    <span class="hljs-keyword">import</span> GenServer <span class="hljs-keyword">as</span> GenServer
    <span class="hljs-keyword">import</span> Effect.Uncurried (<span class="hljs-title">mkEffectFn1</span>, <span class="hljs-type">EffectFn1</span>)
    <span class="hljs-keyword">import</span> Effect.Console (<span class="hljs-title">log</span>)

    <span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">State</span> = <span class="hljs-type">State</span> {}</span>

    startLink :: <span class="hljs-type">EffectFn1</span> <span class="hljs-type">String</span> <span class="hljs-type">GenServer</span>.<span class="hljs-type">StartLinkResult</span>  
    startLink = <span class="hljs-type">GenServer</span>.startLink (tuple2 (atom <span class="hljs-string">"local"</span>) (atom <span class="hljs-string">"testServer"</span>)) (atom <span class="hljs-string">"testServer@ps"</span>)

    init :: <span class="hljs-type">EffectFn1</span> <span class="hljs-type">String</span> (<span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">State</span>)
    init = mkEffectFn1 \args -&gt;  <span class="hljs-keyword">do</span>
      _ &lt;- log $ <span class="hljs-string">"Gen server started with args: "</span> &lt;&gt; args
      pure $ tuple2 (atom <span class="hljs-string">"ok"</span>) (<span class="hljs-type">State</span> {})
</code></pre>
<p>In this case, we&#39;ve decided our start args are a string and we&#39;ll just log that out on startup, and we return a newtype with a record containing our gen server state from the init function, and of course we can just plug this into a standard Erlang supervision tree and we&#39;ll end up with a gen server running which if sent any messages will simply crash :).</p>
<pre><code class="language-erlang">
    init([]) -&gt;
        {ok, { {one_for_all, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>}, [ #{ start =&gt; { testServer@ps, startLink, [&lt;&lt;<span class="hljs-string">"Your args"</span>&gt;&gt;] },
                                         type =&gt; worker,
                                         id =&gt; test_server
                                       }
                                    ]} }.
</code></pre>
<p>Already we can see that we&#39;ve not gained an awful lot by writing this thin wrapper allowing us to write gen servers in this way</p>
<ul>
<li>There are no guarantees that the arguments passed in from the supervisor are the right type</li>
<li>Erlang probably can&#39;t even construct the arguments properly if it&#39;s anything more complicated than a string (say, a record or ADT)</li>
<li>There is no requirement for init/startLink to align their types, the args are going to be coerced back and forth and we&#39;ll get runtime crashes if we make a mistake there</li>
<li>Low level wrappers are cumbersome, and gen servers are a very common tool in our arsenal, this could get old fast.</li>
<li>We haven&#39;t even started to cover passing of arbitrary messages into the gen server (handle call, info, etc) (Spoiler alert: They&#39;re cumbersome too)</li>
<li>There is no guarantee that certain methods (handle_info/etc) are actually present, although most of these behaviours are optional these days thankfully!</li>
</ul>
<p>We can see that manually writing and using 1:1 mappings between Purescript and Erlang code for use across an application is not going to be a sustainable ideal - and yet we will press on and look at a few of the attempts made to do this in the following blog entries before finally trying to do something a little more idiomatic.</p>
]]></description><link>http://codeofrob.com/entries/purescript-on-the-beam---otp-from-scratch.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purescript-on-the-beam---otp-from-scratch.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 20 Nov 2018 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purescript on the BEAM - Calling Purescript from Erlang]]></title><description><![CDATA[<p>Previous entries..</p>
<ul>
<li><a href="/entries/functional-erlang---purescript-on-the-beam---intro.html">Intro</a></li>
<li><a href="/entries/purescript-on-the-beam:-getting-started.html">Getting Started</a></li>
<li><a href="/entries/purescript-on-the-beam---writing-some-basic-code.html">Writing some basic code</a></li>
<li><a href="/entries/purescript-on-the-beam---basic-interop-with-erlang.html">Basic interop with Erlang</a></li>
</ul>
<p>Why would we want to call Purescript <em>from</em> Erlang? Given that moving <em>from</em> Erlang <em>to</em> Purescript as our day to day language is one of our stated goals? Well the answer is in the whole &quot;Module Function Arguments&quot; thing, a lot of APIs in Erlang make you provide an MFA for callback with your state/the library state for performing operations. This is true for all of the web frameworks certainly, and most of OTP (Again, more on that later..)</p>
<h1 id="calling-purescript-from-erlang">Calling Purescript from Erlang</h1>
<p>Consider the following contrived example first.. </p>
<p><em>my_erlang.erl</em></p>
<pre><code class="language-erlang">
    -module(my_erlang).

    -export([ init/<span class="hljs-number">0</span>, callback/<span class="hljs-number">1</span> ]).

    init() -&gt;
      ok = some_library:configure(my_erlang, callback).

    callback(SomeLibraryState) -&gt;
      NewLibraryState = some_library:do_something(SomeLibraryState),
      { ok, NewLibraryState }.
</code></pre>
<p>This is a very familiar pattern for anybody used to writing Erlang, and it isn&#39;t immediately obvious how we&#39;re going to give that library anything from Purescript - most APIs in a functional language if they want a callback, will just ask for a function to callback. This isn&#39;t typically the case in Erlang because this would get in the way of the (somewhat important) code hotloading which is used during development for a rapid experience, and in production to upgrade live systems without incurring downtime.</p>
<p>Ignoring further steps that we might take to then prettify the interaction with Erlang/Purescript here, it turns out that Purescript (currently) compiles modules/functions to fairly predictable names which we can use in our FFI.</p>
<p>So first up, we&#39;d need to write the code to talk from Purescript to Erlang as covered in the previous post (Assuming that both configure/do_something are impure and require effects).</p>
<p><em>SomeLibrary.erl</em></p>
<pre><code class="language-erlang">
    -module(someLibrary@foreign).

    -export([configure/<span class="hljs-number">2</span>, doSomething/<span class="hljs-number">1</span>]).

    configure(Module, Function) -&gt;
      <span class="hljs-keyword">fun</span>() -&gt; some_library(Module, Function) <span class="hljs-keyword">end</span>.

    doSomething(OpaqueState) -&gt;
      <span class="hljs-keyword">fun</span>() -&gt; some_library:do_something(OpaqueState) <span class="hljs-keyword">end</span>.
</code></pre>
<p><em>SomeLibrary.purs</em></p>
<pre><code class="language-haskell">
    <span class="hljs-keyword">module</span> SomeLibrary <span class="hljs-keyword">where</span>

    <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">LibraryState</span> :: <span class="hljs-type">Type</span>

    <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> configure :: <span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Atom</span>
    <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> doSomething :: <span class="hljs-type">OpaqueState</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">OpaqueState</span>
</code></pre>
<p>Using this FFI we can now re-write our original Erlang in Purescript, or at least have a go at it</p>
<pre><code class="language-haskell">
    <span class="hljs-keyword">module</span> MyCode <span class="hljs-keyword">where</span>

    init :: <span class="hljs-type">Effect</span> <span class="hljs-type">Atom</span>
    init = <span class="hljs-type">SomeLibrary</span>.configure (atom <span class="hljs-string">"myCode@ps"</span>) (atom <span class="hljs-string">"callback"</span>)

    callback :: <span class="hljs-type">OpaqueState</span> -&gt; <span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">OpaqueState</span>
    callback state = tuple2 $ (atom <span class="hljs-string">"ok"</span>) state <span class="hljs-comment">-- don't actually do anything yet</span>
</code></pre>
<p>A problem immediately presents itself, we can&#39;t use the doSomething function from our callback because it&#39;s an Effectful function and our callback function is not, this means callback is pure and can&#39;t actually have any side effects.</p>
<p>We can try to re-write callback so it is Effectful</p>
<pre><code class="language-haskell">
    <span class="hljs-keyword">module</span> MyCode <span class="hljs-keyword">where</span>

    init :: <span class="hljs-type">Effect</span> <span class="hljs-type">Atom</span>
    init = <span class="hljs-type">SomeLibrary</span>.configure (atom <span class="hljs-string">"myCode@ps"</span>) (atom <span class="hljs-string">"callback"</span>)

    callback :: <span class="hljs-type">OpaqueState</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">OpaqueState</span>)
    callback state = <span class="hljs-keyword">do</span>
      newState &lt;- <span class="hljs-type">SomeLibrary</span>.state
      pure $ tuple2 $ (atom <span class="hljs-string">"ok"</span>) newState 
</code></pre>
<p>But now we&#39;ll just get a runtime error because the native Erlang code expects a function of <em>(LibraryState -&gt; { ok, Library State })</em>, and we&#39;ve now giving it a function that is <em>LibraryState -&gt; (() -&gt; { ok, LibraryState})</em> - essentially passing a function reference back to Erlang instead of the result of that function (ew).</p>
<p>We can dance around this in a number of ways, the simplest being to lie about the effect and use unsafePerformEffect in our &quot;pure&quot; function (No thanks).</p>
<p>We can also use the namespace Effect.Uncurried to return an effectively negative arity effect back to Erlang (IE, the direct result) without writing any code that lies about what it actually is.</p>
<pre><code class="language-haskell">
    <span class="hljs-keyword">module</span> MyCode <span class="hljs-keyword">where</span>

    init :: <span class="hljs-type">Effect</span> <span class="hljs-type">Atom</span>
    init = <span class="hljs-type">SomeLibrary</span>.configure (atom <span class="hljs-string">"myCode@ps"</span>) (atom <span class="hljs-string">"callback"</span>)

    callback :: <span class="hljs-type">EffectFn1</span> <span class="hljs-type">OpaqueState</span> (<span class="hljs-type">Tuple2</span> <span class="hljs-type">Atom</span> <span class="hljs-type">OpaqueState</span>)
    callback = mkEffectFn1 \state -&gt; <span class="hljs-keyword">do</span>
        newState &lt;- <span class="hljs-type">SomeLibrary</span>.state
        pure $ tuple2 $ (atom <span class="hljs-string">"ok"</span>) newState 
</code></pre>
<p>(IE, the direct result) without writing any code that lies about what it actually is.</p>
<p>This is typically how we will interact directly with Erlang libraries and will get us pretty far when creating low level bindings with those libraries, but we will see as we progress into creating our wrappers around OTP we&#39;ll uncover some better patterns for making this less brittle (Passing atoms all over the show is pretty dull). For one-off cases the above is perfectly fine, but in reality we&#39;ll only be using this mechanism when writing the wrappers themselves and presenting higher level APIs to the application itself.</p>
]]></description><link>http://codeofrob.com/entries/purescript-on-the-beam---calling-purescript-from-erlang.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purescript-on-the-beam---calling-purescript-from-erlang.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 15 Nov 2018 09:30:00 GMT</pubDate></item></channel></rss>