<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>RSS for Node</generator><lastBuildDate>Tue, 28 Jun 2016 07:35:02 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><author><![CDATA[Rob Ashton]]></author><item><title><![CDATA[A Londoner's guide to emigrating to Glasgow]]></title><description><![CDATA[<p>I&#39;ve been asked a couple of times already about moving to Glasgow in Scotland from depressed folks in England knowing that</p>
<ul>
<li>The economy is going to shit (crashy crashy yay)</li>
<li>The community is going to shit (racism, etc)</li>
<li>The UK is going to be a bad place to do business from if it&#39;s not part of the EU</li>
</ul>
<p>And part of this is the hope that</p>
<ul>
<li>Scotland was very pro-remain</li>
<li>Scotland recognises the value of immigrants</li>
<li>Scotland may have another #indyref and they want to come here to vote &quot;yes&quot; in it</li>
</ul>
<p>My own personal feelings? I voted no to independence because being part of the UK which was part of the EU was economically and globally sensible and given how things are now, I&#39;d change my vote to yes and hope that whoever was in charge put in place incentives for the tech industry/etc to start hiring and building in Scotland as it&#39;s a relatively cheap place to do business already and we could do with the income if we&#39;re no longer relying on money from England. (Sorry Cybernats, you were always wrong about this).</p>
<h1 id="why-glasgow-">Why Glasgow?</h1>
<p>So step one on that plan, get the tech community to start moving up here anyway - here are some reasons for you to consider moving to Glasgow</p>
<p><em>It&#39;s not London</em></p>
<p>I moved to Glasgow because it wasn&#39;t London; okay I moved to Glasgow because I had a nasty break-up and needed a change of scenery and it made me very happy indeed. A metaphor perhaps? It worked for me and it could work for you too.</p>
<p>You don&#39;t want to move to Edinburgh because Edinburgh is like a mini-London and is full of the same kinds of people in London that you&#39;d rather not hang out with. Not to mention that just like some parts of London it&#39;s impossible to move around because tourists are shuffling all over the place. Tourism is good for Scotland and thankfully they have a place to go and it&#39;s called Edinburgh.</p>
<p>Okay, so Edinburgh has better coffee, food and cocktails; c&#39;est la vie, it&#39;s less than an hour away by train and the tourists haven&#39;t discovered that yet, long may it stay that way.</p>
<p>So yeah, Glasgow = Not London. It&#39;d be nice to keep it that way too so keep your expectations to yourself and come and love Glasgow for what it is.</p>
<p><em>It&#39;s cheap</em></p>
<p>This is a hard one to wrestle with, telling everybody about Glasgow may increase rental and purchase prices and may damage those that already live here (not me, the indigineous Glaswegians). My hope is that the buy-to-invest nightmare that is London won&#39;t be repeated up here because since #brexit nobody wants to buy anything in GBP any more.</p>
<p>But you can&#39;t deny it, Glasgow is a cheap place to live - from the rent, the buses, the nights out and even the flights across to the continent; come up here and hire some of the locals and let&#39;s build a new tech hub eh?</p>
<p><em>The people are amazing</em></p>
<p>They can be scary at times the Glaswegians, but that&#39;s mostly because we&#39;ve been indoctrinated by the media to view their accent as one step away from getting a &quot;bottling&quot; to the face (Pretty sure that the verbification of the word &quot;bottle&quot; was a Scottish thing too) but honestly it&#39;s not like that at all. I have found conversations in the most unlikely of places with the most unlikely of people and so long as you&#39;re not putting on airs or trying to be something you&#39;re not you&#39;ll get on well with everybody up here.</p>
<p>I&#39;m often asked (especially since I started spending time in Japan) why I&#39;d return to Glasgow and the answer is always the people. Doing my circuit of the coffee shops and bars when I get back is an absolute pleasure and it&#39;s amazing to see the hard work people are putting in to building sustainable business that doesn&#39;t alienate the local crowd.</p>
<h1 id="so-where-do-i-move-to-">So where do I move to?</h1>
<p>You&#39;re sold? Excellent; my advice would be to get on a train up this way and get yourself in an AirBNB for a week, walk around and find an area that suits you. One of the great things about Glasgow not being London is that you don&#39;t need to sign the paperwork in blood before renting a house and pay up to six months in advance. Nae bother - sign your contract, pay a month&#39;s rent and deposit and that apartment is yours. This isn&#39;t the same level of commitment you have previously been used to.</p>
<p>One of the other great things about Glasgow is that no matter where you live, is that most places around the Subway are within 20 minutes of everywhere else around the Subway. There is only one Subway, it is a circle and it goes to most of the places you&#39;d like to be.</p>
<p>Taxis are cheap too, so if you end up going for a night out in Finnieston and you want to get home to your apartment in East Glasgow you&#39;re not going to have to take out a new mortgage to afford one.</p>
<p>So location isn&#39;t actually that important and I&#39;d probably encourage the tech community to think before clustering together in a single area and pricing everyone else out of it. That said, let&#39;s look at a few of the distinct areas and see what you&#39;re getting into if you hit them.</p>
<p><em>The West End</em></p>
<p>Ah the west end; this is where a lot of the more &quot;posh&quot; restaurants and bars are, Porter and Rye, The Finnieston, Ox &amp; Finch, Kelvingrove Cafe etc. It can be a bit pricey to plonk yourself in the &quot;nicer&quot; looking parts of this because it&#39;s probably also one of the wealthiest parts of town. It&#39;s surprisingly unconnected to the Subway - the nearest stops being a 20 minute walk across Kelvingrove park or west across to Kelvinhall or Partick.</p>
<p>I&#39;d probably not advise people to set up here, the extra cost isn&#39;t really worth it and you&#39;re better off being somewhere quieter nearby if you&#39;re wanting to hang out here a lot. If you&#39;re wanting to get the train regularly from Glasgow Central then you&#39;re best off between here and centre (The M8 is smack between the two locations, so somewhere near that) but if you&#39;re not fussed go further west around the Subway for cheaper digs and quieter evenings.</p>
<p>Similar to: The posher bits of Shoreditch</p>
<p><em>The East End</em></p>
<p>There is a lot of theatre around here and it&#39;s where the Barrowlands is. You can have a very good night out in this neck of the woods without spending anywhere near as much as you would in Finnieston. There is an occasional lost tourist looking for the Glasgow Museum of Modern Art or the Necropolis (both worth checking out by the way) but again you&#39;re better off being somewhere quieter nearby if you&#39;re wanting to hang out here a lot. Further east is lots of housing (and a good deli!) but the Subway doesn&#39;t reach out that far so you&#39;re either going to be looking at the mainline trains or buses to get back into town if you&#39;re in a hurry.</p>
<p>Similar to: North London, think zone 2/3 onwards if they had theatres</p>
<p><em>Southside</em></p>
<p>I&#39;m starting to think that this is where it&#39;s all happening but it&#39;s only just kicking off. The best bakery in the world is down here (Bakery47) and down in Strathbungo there are some interesting restaurant happenings. It&#39;s cheap and it&#39;s not sexy and it&#39;s also (mostly) not on the Subway but there are so many trains both in and out of Glasogw (plus NextBike + Bus) that this isn&#39;t a big deal. If you&#39;re going out in the East/West ends then it&#39;s a definite taxi home but that&#39;s only going to be a tenner so it&#39;s probably worth it.</p>
<p>Similar to: I don&#39;t think we can really draw comparisons, London is far too busy to have a place like this - even in the outskirts.</p>
<p><em>The Centre</em></p>
<p>I wouldn&#39;t try and live here, you won&#39;t be spending that much time here anyway outside of the occasional coffee shop visit, to go shopping or to catch a train; it&#39;s not worth it for the lack of sleep all the noise would cost you.</p>
<p>Similar to: Probably that bit of scrub between Farringdon and City, er yeah.</p>
<p><em>The North</em></p>
<p>I&#39;m sure I&#39;ll offend some people here but there is nothing there but housing, maybe if you&#39;re buying a house and don&#39;t mind a bit of a trek to get into town then I&#39;m sure this is fine. Think Borehamwood, look it up - you have time.</p>
<p><em>Recommendation</em></p>
<p>I&#39;d probably look at somewhere within 15 minutes walk of a Subway stop and call it a day. It&#39;s all good and Glasgow isn&#39;t that big. Location doesn&#39;t matter in the same way that it does in London because it doesn&#39;t take two hours to get everywhere. Read the info below and look at where all the things are on a map and work out what&#39;s going to work for you.</p>
<h1 id="getting-out-of-the-country">Getting out of the country</h1>
<p>The extra flight from Glasgow when going international can be a bit of a burden although it rarely increases the price of the ticket all that much. A return flight to London can often be had for less than £90 which is less then the train ticket in most cases and can get you in before the first meeting of the day.</p>
<p>The main international hub is sadly Amsterdam which means going with KLM and Air France if you&#39;re wanting fast convenience, I usually stick with BA however and go via London because for the longer flights the overhead is worth it. </p>
<p>The train down to London is about six hours and there is little phone coverage on the way down (plus the line is as shakey AF), don&#39;t expect to get much work done even in first class if you&#39;re prone to feeling a bit sick when you&#39;re being jolted around all over the place.</p>
<p>I have found that I have fewer reasons to visit London than I expected however, you probably will too. </p>
<h1 id="where-can-i-work-">Where can I work?</h1>
<p>Assuming you already have a job (if you don&#39;t then you&#39;re on your own, they do exist though) you probably want to find coffee shops and co-working spaces to hang in.</p>
<p>Let&#39;s start with coffee shops/etc.
-</p>
<p><em><a href="http://labespr.tumblr.com/">Laboratorio Espresso</a></em></p>
<p>Probably some of the best coffee in Glasgow, it isn&#39;t a large establishment but most of their custom comes from takeaway so nobody is going to worry if you&#39;re sat there with a laptop for an hour or two (especially if you share a table with somebody else). I usually perch on the bar so I can natter to the baristas/customers as they come by and can do this for an hour or two. No power but there is wifi.</p>
<p>Best: In the early morning when you still have battery left on the laptop.</p>
<p><em><a href="http://avenue.coffee/location/great-western-road/">Avenue GWR</a></em></p>
<p>A great place to work, plenty of space although they do get busy around lunchtime; I usually perch on the bar (this is a trend I know) but there are ample tables to set up shop on too and most people do just that.</p>
<p>Best: Either side of lunch is good, not lunch though</p>
<p><em><a href="http://www.spitfireespresso.com/">Spitfire Espresso</a></em></p>
<p>Amazing breakfasts, fun sound track (you&#39;ll get bored of it after a while though), wifi and lots of seating and tables and power. This is a good place to recharge for an hour with a bite to eat while you get some work done.</p>
<p>Best: Either at breakfast time or anytime in the afternoon; the lunchtime rush is strong here so don&#39;t be taking up those tables if you&#39;re not eating lunch.</p>
<p><em><a href="http://allthatissolid.co.uk/">All that is Coffee</a></em></p>
<p>Bright and airy artspace with a coffee shop on the ground floor. I usually tether to my phone for internet and I don&#39;t think there is power down here but there is a lot of space and it&#39;s a good place to hit up for a couple of hours when you&#39;re with other people because of the ample seating.</p>
<p>Across the road is <em><a href="http://www.monocafebar.com/">Mono</a></em>, a vegan restaurant/record shop where you can usually get a bit of work done with a beer or two for very little money but when it&#39;s busy it&#39;s very busy indeed and it&#39;s always worth bearing that in mind.</p>
<p><em><a href="http://www.stereocafebar.com/">Stereo</a></em></p>
<p>Vegetarian bar near central station - banging tunes and food and nobody minds you sitting there in the afternoon plugging away at work with a plate of nachos and a beer to hand (or diet coke, whatever floats your boat). </p>
<p><em><a href="http://theoldhairdressers.com/">The Old Hairdressers</a></em></p>
<p>Across the road from Stereo, often a good place to head if Stereo is too busy.</p>
<p><em><a href="http://www.stravaigin.co.uk/">Stravaigin</a></em></p>
<p>This is a restaurant with two floors, the ground floor is a less formal bar area and you can happily sit here with a glass of wine and a laptop and not get bothered for a couple of hours. Again lunchtime is busy and you know the drill - the lunch is great though so perhaps an hour of work before lunch and an hour or two after lunch and you&#39;re golden.</p>
<p><em><a href="http://www.alstonglasgow.co.uk/">Alston Bar &amp; Beef</a></em></p>
<p>It&#39;s a gin bar underneath Glasgow Central that has power and wifi and gin - you&#39;ll find me here towards the end of a day working in town when I need to recharge both mentally and electrically.</p>
<p>Co-working spaces
-</p>
<p>There are a few that I know of and they&#39;re fairly decent..</p>
<p><em><a href="http://www.thewhiskybond.co.uk/">The Whisky Bond</a></em></p>
<p>£200 a month for a fixed desk, £20 day rate, fast wifi etc. This is a place that advertised heavily and is pretty commercial. It&#39;s in &quot;the north&quot;, but is actually only 10 minutes from Cowcaddens Subway so isn&#39;t so bad to get to. There is little nearby but thankfully there is a cafe in the building and while their coffee isn&#39;t to my taste they do some great sandwiches. Convenient.</p>
<p><em><a href="https://rookieoven.com">Rookie Oven</a></em></p>
<p>Younger and fresher and at a cool location at the Fairfield Shipyard Offices just south of the river, this is also 10 minutes walk from a Subway station (Govan) and again there isn&#39;t that much around here. It&#39;s cheaper than the Whisky Bond (£175 monthly fixed desk) and for better or for worse they advertise as having a Sonos playing the very best 80s tunes but hey - did I mention it&#39;s at the Fairfield Shipyard Offices? They have a museum to visit! This is where the Glasgow Elixir/Erlang meet-up takes place so it&#39;s not a bad place to be.</p>
<p><em><a href="http://thinktankglasgow.com">Thinktank</a></em></p>
<p>Super professional city-centre co-working at £300 a desk. This is quieter and more serious than Rookie Oven and comes with free tea/coffee. Advantage of being in the centre is there are no shortage of lunch spots nearby and all the amenities (post offices/etc) are there so those little things can get done that need doing during the day.</p>
<p>What Rob Does
-</p>
<p>I personally choose to work from home at home - I know it&#39;s a novel idea but I make some of the best coffee in Glasgow and with far more interesting beans than you&#39;ll find in most shops. That said, occasionally I&#39;ll have a day out and I&#39;ll just hop between the various locations listed above as I see fit/when I get bored. It&#39;ll cost me about £30 to spend the whole day out of the house including lunch and coffee and it&#39;s generally worth it.</p>
<p>I&#39;ll often grab lunch at <em>Riverhill</em> while I&#39;m down there, Glasgow isn&#39;t big and it doesn&#39;t take long to get around it.</p>
<h1 id="the-basics-coffee-and-brunch-">The basics (Coffee and Brunch)</h1>
<p>I get it, you&#39;re coming from London where you have a gazillion options for brunching around and coming to Glasgow can be a bit of a culture shock on that front. Nowhere serves booze before 11am/12pm and  that 9am bloody mary just ain&#39;t gonna happen.</p>
<p>That said there are some great options for some really good breakfasts with coffee at the start of the day and your liver will thank you for not killing it with the London drinking culture. Some of these were covered above for &#39;working spaces&#39; but I&#39;ll cover them again with more detail here.</p>
<p><em><a href="http://papercupcoffeecompany.bigcartel.com/where">Papercup GWR</a></em></p>
<p>Tiny shop, small menu but AMAZING EATS. This is my favourite breakfast in Glasgow and I love coming here. Some of the filter coffee is <em>great</em> - get here early if you don&#39;t want an awkward wait for a table. No booze.</p>
<p><em><a href="http://papercupcoffeecompany.bigcartel.com/where">Papercup High Street</a></em></p>
<p>Bigger version of the above with a slightly different menu and a different coffee set-up. I&#39;ve not had the espresso here yet as they only opened recently but they&#39;re rocking an EK43 so it&#39;s probably quite good. No booze.</p>
<p><em><a href="http://avenue.coffee/location/byres-road/">Avenue Byres Road</a></em></p>
<p>Weekends will see you a good fry up here alongside some pretty decent coffee, gerronit. No Booze.</p>
<p><em><a href="http://www.riverhillcafe.com/west-nile.htm">Riverhill West Nile Street</a></em></p>
<p>Brunchy lunchy, they do a bone marrow bloody mary and some damned good breakfasts to boot. Coffee is from the local roastery Dear Green and while the espresso isn&#39;t usually to my tastes you can order a flat white and be happy with what you get. But you&#39;re here for the bloody mary anyway aren&#39;t you?</p>
<p><em><a href="http://www.spitfireespresso.com/">Spitfire Espresso</a></em></p>
<p>Eggs and eggs and fry ups and eggs, this is the stuff of dreams when you just need some stodge to get over that hangover. Espresso is a very safe medium roast and I prefer it in milk. OH GOD THOSE FRY UPS. No Booze.</p>
<p><em><a href="http://www.hutchesonsglasgow.com">Hutchesons Glasgow</a></em></p>
<p>Posh breakfast or brunch - the latter comes with bubbles and this is definitely a place to head to when you want something a bit more special.</p>
<p><em><a href="http://13thnote.co.uk/">Thirteenth Note</a></em></p>
<p>Vegetarian breakfast :) Booze once the law allows it..</p>
<p><em><a href="http://www.cafegandolfi.com/">Cafe Gandolfi</a></em></p>
<p>I&#39;ve been here for a dinner date and it was reeet good. Holy crap though if the breakfast doesn&#39;t completely blow the socks off the East End; huge variety including vegetarian options and I assume given they have a license that at some point towards lunchtime the booze will start flowing.</p>
<h1 id="date-night-eating-boozing">Date night - Eating/Boozing</h1>
<p>Okay most of these are in the West End, like I said above that&#39;s just where this stuff is clustered. Some of these places are owned by larger companies or by the same people - you can look this up yourself if you&#39;re bothered. The G1 group own a lot of things in Glasgow and we try to avoid anything they have their grubby mitts on.</p>
<p><em><a href="http://www.oxandfinch.com">Ox and Finch</a></em></p>
<p>Some of the best foods; classic western stuff with an occasional twist. Large vegetarian menu as well as a non-patronising children&#39;s menu make this a pretty great place to bring an inclusive party.</p>
<p><em><a href="http://www.thefinniestonbar.com/">The Finnieston</a></em></p>
<p>Seafood focused restaurant with a fairly decent cocktail bar which you can go to even if you&#39;re not dining (and a lot of people do!). It gets crowded in the evenings but don&#39;t let that put you off ordering a couple of good drinks to stand around and natter with.</p>
<p><em><a href="http://www.porterandrye.com/">Porter &amp; Rye</a></em></p>
<p>Sometimes the steak here is better than some of the best I&#39;ve had from Hawksmoor, it&#39;s all dry-aged in-house and they do some stonking rye-based cocktails (as well as other classics). I love this place and I love their menu and I often treat myself to a solo-dinner here when I&#39;m feeling blue.</p>
<p><em><a href="http://www.kelvingrovecafe.com/">Kelvingrove Cafe</a></em></p>
<p>Probably the best cocktails in Glasgow, nice long bar to sit on if you&#39;re by yourself. Best off reserving a table if you&#39;re coming with a party - they do food too.</p>
<p><em><a href="http://www.alstonglasgow.co.uk/">Alston Bar &amp; Beef</a></em></p>
<p>Second best steak in Glasgow and SO MUCH GIN TO CHOOSE FROM. A few barrel aged cocktails too, definitely a great place to come if you&#39;re in the area.</p>
<p><em><a href="http://www.stravaigin.co.uk/">Stravaigin</a></em></p>
<p>Posh food downstairs in the basement, more rustic food upstairs and it&#39;s all great and all local. I&#39;d say it has an Indian/Asian theme going for it as most of the good stuff is curry-based but it&#39;s hard to pin it down as the ingredients are locally sourced and black pudding and haggis aren&#39;t exactly asian fare...</p>
<h1 id="some-other-cool-stuff">Some other cool stuff</h1>
<p><em><a href="http://www.bakery47.com/">Bakery47</a></em></p>
<p>Mostly baking for catering, the owners Sam and Anna open some days of the week (and usually post a picture of their opening hours on Instagram each week). </p>
<p>Usually they&#39;ll open shop on Sunday morning at 9am with a rotating guest barista (All Started Here/Back to Black/Fun in a cup/Dear Green) serving coffee and stay open until they&#39;re sold out; a process that usually takes about three hours.</p>
<p>Get there at 9am for the best croissants you&#39;re going to get probably in the UK, and grab a loaf of bread to take home for the week ahead. Weep because it&#39;s going to be another week until you get to come here again.</p>
<p><em><a href="http://www.ranjitskitchen.com">Ranjit&#39;s Kitchen</a></em></p>
<p>Homemade punjabi food, super busy, super affordable, south of the river. I don&#39;t need to say anything else about this.</p>
<h1 id="getting-around">Getting around</h1>
<p>The <em><a href="http://www.spt.co.uk/subway/">Subway</a></em> will do 90% of the job for you, it runs in a circle through most of the neighbourhoods that you&#39;ll need access to on a day to day basis and is affordable as it&#39;s a flat day rate (£3.4 at time of writing) once you&#39;ve used it twice in one day.</p>
<p>That said, it&#39;s not open on Sunday mornings or evenings, public holidays tend to be an issue as well and if you want to get somewhere it doesn&#39;t go you&#39;ll need to find other options.</p>
<p><em><a href="http://www.nextbike.co.uk/en/glasgow/">Nextbike</a></em> is our equivalent to the Boris Bike - they&#39;re lighter and more balanced, cheaper and you can download an app to your phone that lets you pay by the bike (you can press the right buttons on your walk to the bike stand and know which bike is yours before you even get there). There is an annual rate available if this is something you&#39;re going to use a lot. This is how I get to the Bakery on Sunday mornings.</p>
<p><em>The buses</em> are frustration incarnate, exact change required, ran by various different companies and who even knows how much it&#39;s going to cost in advance without being the kind of person who looks that up and counts out the right money in advance. One day they&#39;ll upgrade to contactless payment but until then I&#39;m going to cary on relying on the bikes and subway.</p>
<p><em>Taxi</em>s are cheap and plentiful from the town centre, but I mostly only use them once it gets late and I can&#39;t be bothered walking home. It&#39;s cheaper if you call private hire</p>
<p>You only need a <em>car</em> if you&#39;re going to be doing your large weekly shop at one of the large out of town supermarkets or wanting to do tourism outside of Glasgow without relying on public transport.</p>
<h1 id="the-music">The Music</h1>
<p>Scottish music is amazing, it must be the weather. Frightened Rabbit, Twilight Sad, Belle and Sebastien, James Yorkston, Glasvegas, Mogwai, etc. (Also did you know Mark Knopfler was born in Glasgow? He was! Look it up!</p>
<p>Anyway we have some great music venues (some of them are already listed) and there is always something on - I don&#39;t need to list them out, just go look at a gig guide already..</p>
<h1 id="the-arts">The Arts</h1>
<p>I have a friend who is well into theatre and I&#39;ve been to quite a few of the productions in the east end, there is some fantastic and weird stuff happening in the art scene in Glasgow and it&#39;s fun to play lucky dip with the theatre productions that are on here.</p>
<p>My favourite experience so far has been in the (sadly now closed) Arches, lying in bed with a complete stranger and being asked to share some very intimate things as part of a performance on sexuality; did I mention fantastic and weird?</p>
<h1 id="getting-out-of-glasgow">Getting out of Glasgow</h1>
<p>One of the greatest things until last then; </p>
<h2 id="this-is-what-awaits-you-a-mere-30-minute-train-ride-out-of-glasgow">This is what awaits you a mere 30 minute train ride out of Glasgow</h2>
<p><img src="/img/lomond.jpg" width="400px" /></p>
<h2 id="this-is-what-awaits-you-30-minutes-train-30-minutes-boat-out-of-glasgow">This is what awaits you 30 minutes train + 30 minutes boat out of Glasgow</h2>
<p><img src="/img/arran.jpg" width="400px" /></p>
<h2 id="this-is-what-awaits-you-in-autumn">This is what awaits you in Autumn</h2>
<p><img src="/img/autumn.jpg" width="400px" /></p>
<h2 id="and-over-in-edinburgh">And over in Edinburgh</h2>
<p><img src="/img/edinburgh.jpg" width="400px" /></p>
<h1 id="summary">Summary</h1>
<p>Sod England, it&#39;s all down hill from here; come and make Scotland great again, it&#39;s a cheaper place to do business, full of really great people and amazing ways to relax the brain (whisky!). It&#39;s going to take a lot less effort to make this the kind of open and liberal place we want to live in because we&#39;re already 90% of the way there; let&#39;s do this together.</p>
<p>I&#39;ll make you some coffee at Cafe Ashton once you&#39;re in town. It&#39;s a promise.</p>
]]></description><link>http://codeofrob.com/entries/a-londoners-guide-to-emigrating-to-glasgow.html</link><guid isPermaLink="true">http://codeofrob.com/entries/a-londoners-guide-to-emigrating-to-glasgow.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 27 Jun 2016 09:30:00 GMT</pubDate></item><item><title><![CDATA[Why you can't be a good .NET developer]]></title><description><![CDATA[<p>I was on Twitter today and I saw this tweet by <a href="https://twitter.com/ICooper/">Ian Cooper</a></p>
<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/jbogard">@jbogard</a> Agreed, it&#39;s crazy. The self-loathing mystifies me. All web C# use multiple languages (SQL and JS?) <a href="https://twitter.com/Adron">@Adron</a> <a href="https://twitter.com/aliostad">@aliostad</a> <a href="https://twitter.com/randompunter">@randompunter</a></p>&mdash; Ian Cooper (@ICooper) <a href="https://twitter.com/ICooper/status/742758275133890560">June 14, 2016</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>My first reaction was simply to laugh, because the idea of self-loathing .NET developers is a funny one, my second reaction was to say something pithy on Twitter and then I remembered I had a blog which <em>somehow</em> despite my best efforts is still running for some reason &quot;in the cloud&quot; and thought I&#39;d disagree here instead.</p>
<h1 id="it-s-not-self-loathing">It&#39;s not self loathing</h1>
<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/jbogard">@jbogard</a> The worst part of this is the old belief that I have to classify as an X developer and join or leave <a href="https://twitter.com/Adron">@Adron</a> <a href="https://twitter.com/aliostad">@aliostad</a> <a href="https://twitter.com/randompunter">@randompunter</a></p>&mdash; Ian Cooper (@ICooper) <a href="https://twitter.com/ICooper/status/742756504642674688">June 14, 2016</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>There is a reason this mentality exists and it isn&#39;t one of self loathing. The reason why people &quot;leave&quot; .NET is because <em>it is impossible to be a good .NET developer</em>. To work in a development shop with a team is to continually cater for the lowest common denominator of that team and the vast majority of software shops using .NET have a whole lot of lowest common denominator to choose their bad development decisions for.</p>
<p>Tangible examples? I remember well the insistence of one boss that we use TFS because some developers would find it hard to use git. I remember the steadfast committal to ASP.NET web forms because the &quot;new concepts&quot; in ASP.NET MVC were going to take too long for the team to become productive in. There is now this furore over .NET core and the new thing in the tiny 0.001% of people that care are whether they persist in using Windows or switch to more productive environments. Of course <a href="https://twitter.com/aliostad">@aliostad</a> gets it right here and points out that the primary &quot;<em>Important Thing</em>&quot; should be a focus on <a href="http://byterot.blogspot.co.uk/2016/06/after-all-it-might-not-matter-commentary-status-of-dotnet-dotnetcore-csharp-oss-fsharp-dnx.html">functional programming in languages like F#</a> and of course the reason it doesn&#39;t happen is because &quot;it&#39;s too hard for most people in our team&quot;.</p>
<p>It&#39;ll not happen because as long as you&#39;re working on a platform that is primarily used by derpy enterprise shops, you will continually be held back because those derpy enteprise shops are continually be held back by the derpy enterprise developers that work in the derpy enterprise shops.</p>
<p>It isn&#39;t self loathing, it&#39;s self preservation and an eventual realisation that you can&#39;t actually progress so long as you&#39;re being held back by bad decisions made to cater for the slow and the stupid. Self loathing is just an intermediate stage that people go through while they still believe they can make an impact on the environment around them by caring and shouting into the void to enact tiny changes that help nobody.</p>
<p>The easiest way to progress is always to jump ship and leave, that&#39;s why people do it; moving to a community of people who have seen how to be more effective and productive and leaving the old one behind. In my own case it has been to move to a community that barely exists because the team has to be pretty much self reliant and there is no room for lowest common denominators and long meetings over whether you should use semi-colons or not.</p>
<p><em>This</em> is why you can&#39;t be a good .NET developer, sooner or later the frustration sets in and you go and do something better. The average ability and desire for something better just keeps on plummetting whilst Microsoft try to chase the brain drain by casting little nuggets of mediocrity at the people left behind scrabbling in the mud. </p>
]]></description><link>http://codeofrob.com/entries/why-you-cant-be-a-good-.net-developer.html</link><guid isPermaLink="true">http://codeofrob.com/entries/why-you-cant-be-a-good-.net-developer.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 14 Jun 2016 09:30:00 GMT</pubDate></item><item><title><![CDATA[Erlang and Make - Okay together]]></title><description><![CDATA[<p>We don&#39;t tread the same path as most Erlangers, as <a href="/entries/the-ashton-disinterest-curve---erlang.html">mentioned</a> having been through more than a few of the standard build systems in that ecosystem we&#39;ve settled on our own (the original hard work done by somebody else). All on top of a <a href="/entries/erlang---getting-started-with-vir.html">pile of bash</a> that organically came from real world production use of Erlang.</p>
<h1 id="so-why-make-">So why Make?</h1>
<p>Well firstly we already know it; our other language other than Erlang at work is C (okay and (<em>spit</em>) JavaScript, oky three languages - and Bash... etc). Secondly if you look at an Erlang project and compilation of that Erlang project you&#39;ll see that we have a bunch of files that need compiling into another format (mostly independent to each other), let&#39;s have a wee look at that.</p>
<pre><code>src/<span class="variable">%.</span>erl       -&gt;    ebin/<span class="variable">%.</span>beam
src/<span class="variable">%.</span>app.src   -&gt;    ebin/<span class="variable">%.</span>app
src/<span class="variable">%.</span>xrl       -&gt;    ebin/<span class="variable">%.</span>beam
src/<span class="variable">%.</span>yrl       -&gt;    ebin/<span class="variable">%.</span>beam
priv/mibs/<span class="variable">%.</span>bin -&gt;    mins/<span class="variable">%.</span>mib
</code></pre><p>Etc.</p>
<p>If only there was a tool which allowed you to declaratively wildcard a bunch of inputs to a bunch of outputs and use timestamps to determine whether individual files needed re-compiling again. Hmmmmm.</p>
<p>So yeah, this is our fork of <a href="http://github.com/id3as/erl-mk.git">erl-mk</a>, although in a few days this will be renamed to <a href="http://github.com/id3as/id3as.mk">id3as.mk</a> so check which link doesn&#39;t 404 and this will see you right.</p>
<h1 id="conventions">Conventions</h1>
<p>There is a standard structure to an Erlang project, and it looks like this</p>
<pre><code class="lang-bash">    relx.config
    src/%.erl
    src/%.app.src
    release-files/sys.config
    release-files/*.anything.<span class="keyword">else</span>
    include/%.hrl
</code></pre>
<p>We can only get away with using a standard one-size-fits-all Makefile if you conform to some convention and given that there is already a convention to Erlang projects this is the one that we are using. Additionally you can also have</p>
<pre><code class="lang-bash">    apps/&lt;app-name&gt;/&lt;the same as above&gt;
</code></pre>
<p>To have multiple apps in the same project, and</p>
<pre><code class="lang-bash">    deps/&lt;dep-name&gt;/&lt;the same as above&gt;
</code></pre>
<p>To rely on other Erlang projects and their source code - more on that in a little bit.</p>
<h1 id="using-id3as-mk">Using id3as.mk</h1>
<p>To configure and use id3as.mk, we use an entry point Makefile to set up some variables and download id3as.mk - this would usually be called &quot;Makefile&quot; or &quot;makefile&quot; and sit in the top level of the project (vir will generate this if you&#39;re using it).</p>
<pre><code class="lang-cmake">    DEPS_DIR = $(addsuffix /deps, $(realpath .))
    ERL_LIBS = $(DEPS_DIR):$(realpath apps)

    <span class="keyword">export</span> DEPS_DIR
    <span class="keyword">export</span> ERL_LIBS

    <span class="keyword">export</span> ERLCFLAGS = +debug_info +warn_export_vars +warn_shadow_vars +warn_obsolete_guard +'{lager_truncation_size, <span class="number">10240</span>}'
    <span class="keyword">export</span> ERLMIBFLAGS =

    DEPS = lager cowboy gproc jsx

    dep_lager = git://github.com/basho/lager.git <span class="number">2.0</span>.<span class="number">1</span>
    dep_cowboy = git@github.com:extend/cowboy.git master
    dep_gproc = git://github.com/esl/gproc.git <span class="number">0.2</span>.<span class="number">12</span>
    dep_jsx = git://github.com/talentdeficit/jsx.git master

    id3as.mk:
      @wget --no-cache -nv -O $@ 'https://raw.github.com/id3as/id3as.mk/master/id3as.mk' || rm -f $@

    -<span class="keyword">include</span> id3as.mk
</code></pre>
<p>I&#39;m not a huge fan of using this for dependency downloads (I&#39;d prefer a bash script) but it&#39;s just a single operation at the start to download all dependencies to the DEPS_DIR and then build is just standard Make. You&#39;d still need to specify which dependencies you had because the Makefile uses this to build up a dependency tree and only build each dependency once (in the right order).</p>
<p>Anyway, it&#39;s self explanatory - you&#39;ll see that in Erlang we haven&#39;t got a package manager (although some misguided but well meaning folk are trying to change that), and we just download source into a deps folder and build that ourselves. (No, they&#39;re not submodules, <em>ew</em>)</p>
<p>For each dep, id3as.mk checks if there is a Makefile present (in which case it&#39;ll run that), checks if there is a rebar.config present (in which case it&#39;ll run rebar) and falls back to re-executing itself in the dep dir. For all the id3as.mk based dependencies it&#39;ll honour timestamps all the way down. Rebar is a little more dumb and once you&#39;re in the world of rebar it can be a little slow as it insists on recursing over deps multiple times during a single build (boo, hiss).</p>
<p>I&#39;m a big fan of having dep source available - it means if you build up a tags file for your editor you can jump into the source code of even the third party dependencies you&#39;re using and see how they work (what better documentation than the actual code okay just joking devs we should all be writing better documentation).</p>
<h1 id="make-commands">Make commands</h1>
<ul>
<li>&quot;make get-deps&quot; - initial download of deps</li>
<li>&quot;make&quot; - build <em>everything</em></li>
<li>&quot;make apps&quot; - just build the apps</li>
<li>&quot;make clean&quot; - clean up our app</li>
<li>&quot;make clean-all&quot; - ruthlessly gut everything</li>
<li>&quot;make apps/[foo]&quot; - just build the foo app</li>
<li>&quot;make deps&quot; - just build the deps</li>
<li>&quot;make deps/[foo]&quot; - just build that dep (useful if you&#39;re debugging a third party dep)</li>
<li>&quot;make rel&quot; - make a release</li>
</ul>
<p>Neato. Everything is just timestamp checking and then for bonus points</p>
<ul>
<li>make -j <anything from above>   - DO IT IN PARALLEL</li>
</ul>
<p>Seeing as most of these steps and most of the erl/beams are independent of each other a build is much faster if you run it in parallel.</p>
<h1 id="on-package-managers">On package managers</h1>
<p>I often get a few eyebrows raised when I say we don&#39;t need one of these - so the next entry will write about why they&#39;re unnecessary (in any of the incarnations so far) and why we should do without.</p>
]]></description><link>http://codeofrob.com/entries/erlang-and-make---okay-together.html</link><guid isPermaLink="true">http://codeofrob.com/entries/erlang-and-make---okay-together.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 24 Mar 2015 08:30:00 GMT</pubDate></item><item><title><![CDATA[Erlang - Getting started with vir]]></title><description><![CDATA[<p><a href="http://github.com/robashton/vir">Vir</a> is a bunching together of various scripts we had lying around our projects written in a combination of Bash and Erlang to manage the execution/release/etc process for our applications. It does what we need to do and stops about there - I suspect the best way of using Vir is to either use it as it is or fork it for your own organisation rather than trying to make it help everybody.</p>
<p>The easiest way to get started with vir is to clone it to ~/.vir and add this folder to the path, but it&#39;ll work if you just add it to a GH repo and run it locally to so... whatever - do what you want it&#39;s just a bash script.</p>
<p>Anyway, running vir should give us a list of possible commands, for now we&#39;ll just create an empty web application in a folder, so do something like the below..</p>
<pre><code>mkdir awesomeapp
cd awesomeapp
git init
vir init -t web awesome
git commit <span class="keyword">...</span>
</code></pre><p>This creates an application called &quot;<em>awesome</em>&quot; (and builds it) based off the <em>web</em> and gives us a folder structure that looks similar to below:</p>
<p>As mentioned in a previous blog entry, this is at immediate glance a lot to digest, but we can go through it a little at a time and see just what has been created for us.</p>
<p><strong>Config</strong></p>
<pre><code><span class="title">apps</span>/awesome/release-files/sys.config
<span class="title">apps</span>/awesome/src/awesome_config.erl
</code></pre><p>sys.config is a standalone file containing various key-value pairs of config and awesome_config is a wrapper that provides an API to read that file. Not much to see here.</p>
<p><strong>Application startup</strong></p>
<pre><code><span class="title">apps</span>/awesome/src/awesome_app.erl
<span class="title">apps</span>/awesome/src/awesome_sup.erl
</code></pre><p>An application requires something that implements the OTP Behaviour &quot;Application&quot; (<em>awesome_app.erl</em>), and if I want child processes within the structure I&#39;ll need a supervisor to manager them, that&#39;s (<em>awesome_sup.erl</em>).</p>
<p><strong>A web application</strong></p>
<pre><code>apps/awesome/src/<span class="filename">awesome_cowboy.erl
</code></pre><p>This is just a OTP genserver that uses Cowboy (one of our dependencies) to create a simple http listener.</p>
<p><strong>Release artifacts</strong></p>
<pre><code><span class="title">deployment</span>/build_no
<span class="title">deployment</span>/major_ver
<span class="title">deployment</span>/minor_ver
</code></pre><p>This is a cheap way of bumping version for the application during a release cycle.</p>
<p><strong>Dependencies</strong></p>
<pre><code><span class="title">deps</span>/cowboy/
<span class="title">deps</span>/cowlib/
<span class="title">deps</span>/edown/
<span class="title">deps</span>/gen_leader/
<span class="title">deps</span>/goldrush/
<span class="title">deps</span>/gproc/
<span class="title">deps</span>/jsx/
<span class="title">deps</span>/lager/
<span class="title">deps</span>/ranch/
</code></pre><p>Lots of folders containing lots more of the above. They were cloned and brought in because the Makefile contains a list of dependencies.</p>
<p>In reality we&#39;re only explicitly bringing in <em>cowboy</em>, <em>gproc</em>, <em>jsx</em> and <em>lager</em> and the others are further dependencies of these. Because Erlang operates in a single global namespace you can&#39;t do explicit imports ala NodeJS and have multiple versions of things in the application.</p>
<p>It doesn&#39;t matter too much anyway because dependency applications often spin up a fleet of processes on start-up rather than simply operating as library code, so you wouldn&#39;t want more than one version of an application running within a project.</p>
<p><strong>Various Manifests</strong></p>
<pre><code>apps/awesome/relx<span class="variable">.config</span>
apps/awesome/src/awesome<span class="variable">.app</span><span class="variable">.src</span>
</code></pre><p><em>relx.config</em> is a manifest specifying how to do a release with all the appropriate files, and <em>awesome.app.src</em> tells the boot system what state our application needs to be in before it can be started.</p>
<p><strong>A Makefile</strong></p>
<pre><code><span class="attribute">Makefile
</code></pre><p>Yup, we use make.</p>
<h1 id="using-it">Using it</h1>
<p>So how do we use this? Well the bash script we just ran probably did all this already but loosely our general dev cycle will be</p>
<pre><code><span class="title">make</span> -j apps         <span class="comment">#  "make in parallel, the apps only, ignore the deps"</span>
vir run awesome      <span class="comment">#  "vir, run the app please"</span>
</code></pre><p>If we add new dependencies, then we&#39;ll need to run the following command after a build before running</p>
<pre><code>vir boot             # <span class="keyword">Generate</span> bootscripts <span class="keyword">for</span> each application based <span class="keyword">on</span> the manifests
</code></pre><p>So what do we have when it starts up? Well, let&#39;s look at the logs first</p>
<pre><code>Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.1</span>] [source] [<span class="number">64</span>-bit] [smp:<span class="number">4</span>:<span class="number">4</span>] [async-threads:<span class="number">10</span>] [kernel-poll:<span class="constant">false</span>]

<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.978</span> [info] Application lager started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.979</span> [info] Application ranch started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.979</span> [info] Application crypto started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.980</span> [info] Application cowlib started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.988</span> [info] Application cowboy started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.998</span> [info] Application gproc started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.998</span> [info] Application shared started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
Mode dev <span class="keyword">not</span> found
<span class="number">13</span>:<span class="number">08</span>:<span class="number">50.024</span> [info] Application awesome started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
Eshell V6<span class="number">.1</span>  (abort <span class="keyword">with</span> ^G)
</code></pre><p>Neato, we see all the applications specified in <em>awesome.app.src</em> started up. (Mode dev isn&#39;t found because we haven&#39;t got one and that&#39;s the default mode)</p>
<p>This is awesome.app.src for reference.</p>
<pre><code><span class="cell">{application, awesome,
 [
  {description, ""}</span>,
  <span class="cell">{vsn, "<span class="number">1.0</span><span class="number">.0</span>"}</span>,
  <span class="cell">{registered, []}</span>,
  <span class="cell">{modules, []}</span>,
  <span class="cell">{included_applications, []}</span>,
  <span class="cell">{applications,
   [
    kernel,
    jsx,
    stdlib,
    lager,
    cowboy,
    gproc,
    shared
   ]}</span>,
  <span class="cell">{mod, { awesome_app, []}</span>},
  <span class="cell">{env, []}</span>
  ]}.
</code></pre><p>See what I mean about dependencies not simply being a pile of code, that list of folders we have in deps contain actual applications that are started up before awesome_app itself.</p>
<p>Is it working?</p>
<pre><code>curl http://localhost:3000/index.html
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>Yup.</p>
<h1 id="next-up">Next up</h1>
<p>I&#39;ll look at our Makefile and how we handle dependencies, and explain a bit more our decisions around that.</p>
]]></description><link>http://codeofrob.com/entries/erlang---getting-started-with-vir.html</link><guid isPermaLink="true">http://codeofrob.com/entries/erlang---getting-started-with-vir.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 19 Mar 2015 09:30:00 GMT</pubDate></item><item><title><![CDATA[Erlang - How we do it]]></title><description><![CDATA[<p>Having <a href="/entries/the-ashton-disinterest-curve---c.html">established</a> that I <a href="/entries/the-ashton-disinterest-curve---javascript-and-node.html">apparently</a> <a href="/entries/the-ashton-disinterest-curve---clojure.html">hate</a> <a href="/entries/the-ashton-disinterest-curve---erlang.html">everything</a>, let&#39;s get a bit more constructive and go over how at the company I work at, we do Erlang and do Erlang effectively.</p>
<p>Let&#39;s start off with a little history first though to build context for this series... I&#39;ll use &quot;we&quot; a lot, but what I really mean is &quot;me and my current understanding of our way&quot;.</p>
<h1 id="where-we-are">Where we are</h1>
<p>There were a couple of .NET developers, and they had need to build a distributed system and they looked at .NET and went &quot;hell no, let&#39;s do that little bit in Erlang&quot; and then a little bit later &quot;Oh sod it, let&#39;s do everyting in Erlang this is actually great&quot;. Lots of mistakes were made over the next few years and they were learned from as they were made. Eventually a developer called Rob (me) joined the team and most of the important mistakes had already been made and a lot of decisions had been made about how best to be effective at Erlang development.</p>
<p>We&#39;ve been through our own custom build systems/runners, to using <a href="https://github.com/rebar/rebar">Rebar</a>, to using fairly <a href="https://github.com/ninenines/erlang.mk">poorly written</a> Makefiles to using <a href="https://github.com/fenollp/erl-mk">reasonably written</a> Makefiles to just forking the best one and making it <a href="https://github.com/id3as/erl-mk">our own</a>. We&#39;ve been through the &quot;let&#39;s make everything a gen server&quot; to &quot;why do we need gen servers anyway&quot; to &quot;okay, here is the happy medium&quot;. We&#39;ve had bash scripts lying around a bunch of projects for automation purposes that have diverged from each other, converged again and been merged into a &quot;<a href="https://github.com/robashton/vir">single tool to rule them all</a>&quot;. We have sensible ways to build up APIs between gen servers, between running applications and we have a common swiss army knife of a common library that every time I go to write Erlang without for personal stuff I wonder how on earth I ever got on without.</p>
<p>It&#39;s a pretty mature stack and because we own most of it outside of our basic dependencies we&#39;re not subject to the whims of third parties changing their minds about how projects should be written and managed. Leaning on a large platform like Erlang is relaxing because it has been around for a few decades and generally doesn&#39;t undergo massive shifts every year just because some hipster somewhere decides they don&#39;t like <em>that sort</em> of paren or semi-colon.</p>
<p>We&#39;re pretty much against package managers, binary dependencies or other opaque tooling that we can&#39;t understand and simply make our own. We&#39;ve learned the hard way that sometimes the best tools are the ones that we&#39;ve all been using since the dawn of time (Bash and Make) and slowly over time these ideas have converged and become crystalised as a standard set of tools we all understand and are happy with.</p>
<h1 id="a-series-then">A series then</h1>
<p>So we have these bash scripts and makefiles and our standard application structure and while we&#39;ve been using them for years in various forms we&#39;ve never really publicised that they&#39;re actually OSS on Github. We&#39;ve never talked about how to use them to build Erlang applications (new starters? Pair for half a year and you&#39;ll have it all down like second nature anyway).</p>
<p>Now that most of this has stabilised (for now), it&#39;s quite a good time to write a blog series about our workflow, how to bootstrap a new application, how to do builds and releases and best practises around gen servers and processes and APIs and inter-process communication. We&#39;re also heavy Docker users (for now) so I&#39;ll cover our loose workflow around how we use that for development etc.</p>
<p>On board? The next entry will be about bootstrapping an empty application.</p>
]]></description><link>http://codeofrob.com/entries/erlang---how-we-do-it.html</link><guid isPermaLink="true">http://codeofrob.com/entries/erlang---how-we-do-it.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 17 Mar 2015 09:30:00 GMT</pubDate></item><item><title><![CDATA[The Ashton Disinterest Curve - Erlang]]></title><description><![CDATA[<p>I&#39;ve complained about <a href="/entries/the-ashton-disinterest-curve---c.html">.NET</a> (nothing has changed by the way) and <a href="/entries/the-ashton-disinterest-curve---javascript-and-node.html">JS</a> (or here) and I&#39;ve been pretty nice about <a href="/entries/the-ashton-disinterest-curve---clojure.html">Clojure</a> (or so I thought) and I&#39;ve managed to delay doing anything about Erlang at all because reasons.</p>
<h1 id="erlang-mundane-brilliance">Erlang - mundane brilliance</h1>
<p>I&#39;m not passionate about Erlang; I&#39;ve never been passionate about Erlang and I&#39;ve never hated it either. Perhaps this explains why I&#39;m over a year into working with it professionally and I still don&#39;t feel the need to talk loudly about it one way or another. (That and I have a great team of colleagues, work remotely and build pretty awesome products that are actually being used by people - okay then).</p>
<p>Let&#39;s get something out of the way then, I&#39;m not an Erlang evangelist - I was even asked in a talk the other day what my three sentence elevator pitch for Erlang would be and I haven&#39;t got one. If you want to put in the effort to work in the Erlang ecosystem then the rewards will become apparent fast enough but trying to explain how exactly such an ugly language contributes positively in any way to our product quality/stability in a tidy soundbite just isn&#39;t something I&#39;m interested in doing.</p>
<h1 id="erlang-is-ugly">Erlang is Ugly</h1>
<p>Contrived bit of code I just wrote in the airport:</p>
<pre><code class="lang-erlang">
    -module(greeter).

    -export([hello/2]).

    -record(state, {
        targets :: list(target_config())
      })

    init() -&gt;
      spawn_link(fun chat_loop/0).

    hello(Pid, Str, Names)
      case Names of
        [] -&gt;  ok;
        [ Head | Tail ] -&gt;
          Pid ! { hello, Str, Head },
          hello(Pid, Str, Names)
      end.

    chat_loop(State) -&gt;
      NewState = receive
        { hello, Str, Name } -&gt;
          Target = lookup_name(Name),
          Target:write(Str),
          State,
        { register, Name, Cfg } -&gt;
          register_name(State, Name, Cfg)
        after 1000
          housekeeping(State)
      end,
      chat_loop(NewState).

    register_name(State = #state { targets = Targets }, Name, Cfg) -&gt;
      State#state { targets = [ { Name, Cfg } | Targets ] }.
`
</code></pre>
<p>Or whatever. This is all fairly standard code and certainly there is nothing unusual in here that you&#39;d not expect to see in any old module from around the place. This is probably about 5% of the syntax of Erlang and you can start to see why a lot of people start to pick up Erlang via the medium of &quot;Learn Erlang for Great Good&quot; or something similar and after a week of syntax lessons throw their arms in frustration and exclaim &quot;What on earth is the point?&quot; and either switch to Elixir or something even worse (okay it&#39;s relative) like NodeJs.</p>
<p>No <em>real</em> type system, no polymorphism, hilariously inconsistent APIs for processing lists, queues, dictionaries (even within the list API itself it&#39;s not consistent with the argument orders etc), no real way of doing function composition or guaranteeing purity in functions (which means guard clauses can only use built-ins) and what you really have is a way of writing locally &quot;pure&quot; code across imperative operations on networks and filesystems.</p>
<h1 id="erlang-has-moving-parts">Erlang has moving parts</h1>
<p>How do you do releases? How do you build your application? How do you test it? How do you run it? What do you need for all of this to work? A quick scan of an &quot;empty&quot; project built from scratch just now on my machine contains:</p>
<ul>
<li>Makefile (for building stuff)</li>
<li>Relx (for releasing stuff)</li>
<li>sys.config (for configuring stuff)</li>
<li>relx.config (for configuring the release)</li>
<li>foo_app.src (a manifest for the application)</li>
<li>foo_app.erl (the application entry point)</li>
<li>foo_web.erl (a gen server for spinning up the web process hierarchy)</li>
<li>foo_sup.erl (a supervisor for managing the process hierarchy)</li>
<li>foo_config.erl (a little wrapper for accessing sys.config)</li>
<li>a &#39;deps&#39; folder containing &quot;gproc (process utils), lager (logging), cowboy (web)</li>
</ul>
<p>And a few other bits. This is astonishingly daunting and no amount of &quot;just use rebar&quot; will ever make that easy. I&#39;m generally against scaffolding because it allows awkward design to survive but you almost <em>need</em> to scaffold the basic Erlang application somehow because of all the bits you need to just spin it up. Contrast that to a simple node project with its app.js. node_modules and ... oh wait you can pretty much write something useful from this point and <em>discover as you go</em> while still building something tangible that somebody might want to use.</p>
<p>Oh, and unlike Clojure there is no real REPL (stop saying erl is a REPL or like a REPL because it really is not a REPL and it offers none of the same experiences you&#39;d expect from a REPL and nobody does applications which can be bootstrapped easily via a REPL and there is very little tooling support for talking to this from your editor so really it&#39;s nothing like Clojure omg stop you guys)</p>
<p>At this point the folk in the Erlang community reading this will be thinking &quot;but it&#39;s not quite like that - once you have a workflow it&#39;s all sensible enough&quot; or &quot;You don&#39;t need most of those things for an application really&quot; or &quot;why would you want to do things in a REPL anyway?&quot; or all sorts of self-deluding statements because they&#39;ve been blinded by some of the better things in Erlang and things like working and profitable products for years and that&#39;s sort of okay but in a way also really frustrating because it seems that after a few years of Erlang development Erlangers seem to forget just how awful some of the tools they&#39;re working with actually are.</p>
<h1 id="erlang-s-oss-is-moving-sands">Erlang&#39;s OSS is moving sands</h1>
<p>Every few months we decide we need to make http calls from our applications and we have to do the dance of working out which library is still being maintained or compiles in the current version of Erlang, ibrowse caused us issues until we switched to lhttpc but unicode and R17 really pissed us off and then lhttpc was deprecated so we looked at gun (which uses maps) but actually shotgun is a better wrapper but there is also fusco except that&#39;s not ready yet yes it&#39;s 2015 and we don&#39;t have a consensus on a http client. (Actually Gun is pretty neat and there are reasons to be re-writing http clients with the advent of http2 etc but okay this is a little frustrating and a small example of the ecosystem).</p>
<p>The language itself is still evolving and some libraries just stop working between releases, there aren&#39;t too many active users of most Erlang libs once you get out of the basic world of http and databases and you will find bugs and you&#39;ll have to fix those bugs and you&#39;ll have to invest time in doing that if you want to be effective in this world - so you&#39;ll need to be a competent Erlang developer to build an Erlang application but is that such a bad thing given that 90% of developers working in their chosen language are incompetent and at least we have this as a safeguard to keep that sort of person out? I really don&#39;t know I&#39;m just thinking out loud).</p>
<p>Oh - and every month I find another Erlang library that hasn&#39;t written their manifest properly so doesn&#39;t work in the releases that we build using relx and we&#39;re relying on dangling forks or commits of quite a few projects because nobody seems to be around to take our call for fixing them or merging our fixes.</p>
<p>It&#39;s not brilliant but...</p>
<h1 id="erlang-does-seem-to-work">Erlang does seem to work</h1>
<p>It doesn&#39;t just work, it excels. Once you&#39;ve fought and made peace with all of the above (and more) and you&#39;re using the bash scripts and makefiles that the rest of your company is using for automating the build/test/release process and you&#39;ve spent the time learning how all of it fits together then you can spend some time looking at supervision trees and process ownership and you realise that it&#39;s pretty hard to crash an Erlang application and leave anything open or dangling or in a weird state if you reasoned about your supervision structure at all.</p>
<p>OTP is pure wonder (gen_server, supervisors, applications etc) and the libraries that ship wth Erlang using the process model and underlying abstractions are battle-tested, stable and well thought out.</p>
<p>Consider that I can write the following code anywhere in any old gen server and if it fails (IE, write doesn&#39;t return &#39;ok&#39;, the entire process tree crashes and subject to the rules in the supervisor either will be restarted, kill siblings or parents or pass the error up automatically to the next supervision level and we&#39;ll have a log about all of this including the current state of the offending process and there won&#39;t be a dangling open handle to the file and a whole bunch of other useful &quot;none-artifacts&quot; that you&#39;d easily overlook if you hadn&#39;t put in the time to avoid them.</p>
<pre><code><span class="setting">ok = <span class="value">file:write(Handle, Bytes).</span></span>
</code></pre><p>Not having to dance around exceptional error cases in most file or networking scenarios and writing your code on top of these built-ins means you can spend more time writing the code you need to write for the feature itself (Okay admittedly if you&#39;ve gotten around the syntax issues). This philosophy and things like it hold true across the various libraries we use from across the ecosystem and mean we don&#39;t tend to get too many support calls at 2am because web servers have disappeared because something is locked, crashed, down permanently, corrupt or whatever.</p>
<p>Easy inter process communication means it is easy to build self-contained little workers around little balls of state and not worry about concurrency (most of the time) because everything is safe if you&#39;re following the happy path. Generally it also means that shifting cpu heavy stuff around our stack is easy because we can always take one of these processes and spin it up somewhere else. I mentioned that in Clojure we ended up with Actors in core.async but without error handling or safe handle management and here is the answer neatly packaged for us in a platform that has been around and battle-tested for 10x as long. Neat.</p>
<h1 id="but-what-about-elixir">But what about Elixir</h1>
<p>If I mention Erlang, this is always the first thing that comes up and it sorta annoys me. I have a few issues with Elixir and they&#39;re not really to do with the language itself because y&#39;know, I couldn&#39;t care less about syntax in general but I do care about philosophy/focus. It&#39;s irrational but here goes:</p>
<p>1) I&#39;ve worked in Ruby, the Ruby community might be friendly but they&#39;re mostly godawful developers and their tendency to overload operators with magic, or monkey patch internals or generally do any sort of meta-programming because ahahaaha lols made me almost quit programming altogether in frustration when I stared into that abyss for the duration of that job</p>
<p>2) Elixir comes from that background, with that sort of developer and now with ADDED MACROS (oh man no don&#39;t give these kids more metaprogramming tools)</p>
<p>You see - Clojure is allowed to have Macros because the rules of Macro club are clearly written down and stated as thus:</p>
<ul>
<li>Don&#39;t use Macros</li>
<li>Don&#39;t use Macros</li>
<li>Don&#39;t use Macros</li>
<li>Okay, re-write those rules - we&#39;re going to use Macros because our name is Rich Hickey</li>
</ul>
<p>This general sensibility means that you don&#39;t generally bring in libraries in Clojure and then have to wonder why everything in your application no longer works because somebody decided to re-define basic mathematical operators (for those not doing Ruby <em>yes this is actually a thing I don&#39;t know what even</em>).</p>
<p>Erlang doesn&#39;t cost us any money because we can&#39;t pretend records/maps are objects, we don&#39;t need that functionality. Erlang doesn&#39;t cost us money because we can&#39;t do meta-programming (actually we sorta can but sssh don&#39;t tell the Ruby devs) - and while the syntax might be ugly it isn&#39;t something that is a fundamental issue beyond the initial learning curve because you should be learning OTP, not the language. Putting the focus on that shiny language takes a lot of focus away from the things in Erlang that are actually <em>useful</em> as in the ode above. This is further chronicled by the sheer number of blog entries of &quot;Ruby vs Elixir&quot;, &quot;Node vs Elixir&quot; etc as if somehow the language is at all anything you should be interested in. I find it incredibly hard to trust Elixir, anything written <em>in</em> Elixir or anything written by the Elixir devs (see Ruby metaprogramming above).</p>
<p>The new and shiny detracts from the old and gnarly without really adding that much in tangible benefits and bringing in the hipster brigade who all totally missed the point when it came to the bit in the chapter &quot;What do you mean you can&#39;t re-assign variables&quot;.</p>
<p>If you&#39;re a great dev then you can probably be more effective in Elixir (probably), but bear in mind they&#39;re re-building all the shitty infrastructure around packaging management, build tools, scaffolding etc that it has been quite a relief to stay away from in this last year of doing Erlang (I&#39;ll cover this in the upcoming series). So thanks but no thanks - you are all incorrect in your thinking and I&#39;ll see you in a couple of years when you work that out for yourself.</p>
<h1 id="lfe">LFE</h1>
<p>An interesting idea, and we&#39;re looking at trialling it in our low value webby bits side by side with the Erlang (because it&#39;s not trying to do anything magic beyond offering a fairly simple syntax change - you know I love a good LISP). At the moment there are a pile of things that we&#39;d want in it (I found some issues the first six hours I jumped in and while Robert Virding is very fast at fixing them we&#39;d need to keep it in low value code while we helped grow the project).</p>
<p>Bonus: It&#39;s not being ran by Ruby script kiddies, so that&#39;s a Good Thing (tm).</p>
<h1 id="state-on-the-disinterest-curve">State on the disinterest curve</h1>
<p>Still not really that interested in Erlang, simply building things in it and enjoying it - this process is pretty mundane and perhaps that&#39;s what I&#39;ve been looking for all this time. I&#39;m going to throw in some more blog entries after this one covering how <em>we</em> build things in Erlang because we do things <em>our</em> way and I&#39;ve been asked about this a few times now. This should be fun.</p>
]]></description><link>http://codeofrob.com/entries/the-ashton-disinterest-curve---erlang.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-ashton-disinterest-curve---erlang.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 09 Mar 2015 10:30:00 GMT</pubDate></item><item><title><![CDATA[The Ashton Disinterest Curve - Clojure]]></title><description><![CDATA[<p>Do you like <em>anything</em> Rob? You said you were going to be nice and all you&#39;ve done is complain about <a href="/entries/the-ashton-disinterest-curve---c.html">.NET</a> and <a href="/entries/the-ashton-disinterest-curve---javascript-and-node.html">JS</a> so far. Point taken - let&#39;s talk about Clojure.</p>
<h1 id="an-ode-to-the-lisp">An ode to the lisp</h1>
<p><em>(parens (love (i)))</em>. I love s-expressions; code written in Clojure tends to be beautifully expressive thanks to the terseness and minimal syntax provided the humble s-expr. When you go on to add easy composition and a rich library of &quot;All the basic things you might want to do to a list or a key-value structure&quot; the magic starts to happen. The focus on data-oriented code that gave birth to that heavily re-usable core library and an emphasis on referential transparency means that things generally do just what you expect them to and you can usually just focus on the functionality that led you to open up an editor in the first place.</p>
<p>Speaking of editors, once you have your editor of choice set up with REPL integration, Paredit (if you want to edit expressions and not lines) and you&#39;ve downloaded the internet with Maven, the low syntastical burden of the language makes it ideal for hacking around in even for people who are new to the language. Spending evenings at the London Clojure Dojo was one of my favouite ways to use time as every week there would be new people to play with in whatever bizarre challenge had been set by the group.</p>
<p>That community was instrumental in keeping me going with the journey as I wrote <a href="http://robashton.github.io/cravendb/">CravenDB</a> and did my best to learn through that action. Over the year I wrote that I entered the top 100 committers on Github and entered the top five committers for Clojure itself. Being able to spend some time at <a href="/entries/the-use-of-clojure-in-the-cdec-open-health-data-platform.html">MastodonC</a> working on some unrelated OSS in Clojure was also an amazing experience and cemented my love of the humble paren and the people who wielded them.</p>
<p>Clojure is therefore a great gateway language in that it makes functional programming accessible to anybody with the JVM installed.</p>
<h1 id="concurrency">Concurrency</h1>
<p>Clojure had a goal of making concurrency on the JVM easy with its built in constructs for utilising STM. Atoms, agents and simple support for transactions meant that managing access to shared data structures was very simple indeed. Then core.async came along and pretty much took over every library and application I tried writing with it. Core.async definitely made the experience of writing Clojurescript more elegant given its hosting environment and the forced asynchronisity of the JavaScript world. Setting up your entire application as a series of communicating sequential processes around managable chunks of state is definitely something to be celebrated in that ecosystem.</p>
<p>This is where the love affair starts to unravel however as there is some amount of pain this world.</p>
<h1 id="the-pain">The pain</h1>
<p><em>Stack traces and errors</em>; Ever seen a Java stack trace? Now add a few more pages of scrolling for all the Java written to make Clojure possible (shudder) - now make those errors occur inside a core.async block and be amazed if anything useful gets  dumped out as your application ceases to work.</p>
<p><em>Start-up time</em>; build a real application, now it takes 30 seconds to start-up on my MBA before hitting any actual code. The ardent Clojurites therefore commit a great deal of time and energy avoiding ever having to bounce the REPL - indeed designing their entire systems around development from a REPL standpoint. That isn&#39;t such an awful thing because I really enjoyed the feedback loop that REPL-first development provides and keeping small parts of your system bootstrappable makes it easy to write tests when needed but having this start-up time on my pet database and having to re-engineer it around not wanting to bounce the REPL just felt awkward.</p>
<p><em>The real world</em>: Occasionally when programming it becomes useful to do things like read and write from files/sockets/etc. In Haskell we talk about Laziness requiring Purity, in most other places we&#39;re Strict and Impure (Unless you count the 100s of gloriously awful things done in the name of LINQ/C#). Clojure is both Lazy and Impure with no real control over where those side effects take place. You can call a seemingly pure function that calls a dozen other pure fuctions and at the bottom somebody is holding onto an atom just to spite you. That&#39;s a made up problem but replace that atom with a file handle and we start to have issues.</p>
<p><em>Types</em>: Or lack of; we&#39;re lazy and impure and we have no type system, combine that with a complete lack of decent error handling constructs and giant stack traces and say hello to wasting hours debugging problems if they&#39;re so cruel as to slip through your REPL driven development process. Yes there is core.typed which is a wonderful project but it makes Erlang&#39;s spec notation looks beautiful and completely ruins the elegance of the original code. A big bucket of nope.</p>
<p><em>JVM</em>: &#39;nuff said.</p>
<p>Rather than just repeat myself, there is a <a href="https://skillsmatter.com/skillscasts/6040-resource-management-in-clojure">10 minute video</a> and <a href="http://slides.com/robashton/resource-management-in-clojure">slides</a> of me trolling a Clojure conference with a talk on this very subject.</p>
<h1 id="the-path-towards-erlang">The path towards Erlang</h1>
<p>So okay; simplifying things a lot - you either need to pass file handles (or something that represents them, so handle handles) up to the users of your library for short lived access or wrap up long lived resources in core.async blocks to manage concurrent access to them.</p>
<p>This ends up looking like this (keeping most of the code out of the core.async block so it can be tested in the REPL easily)</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> go-index-head [_ {<span class="keyword">:keys</span> [command-channel] <span class="keyword">:as</span> engine}]
  <span class="list">(<span class="title">debug</span><span class="body"> <span class="string">"being asked to start"</span>)</span></span>
  <span class="list">(<span class="title">go</span><span class="body">
    <span class="list">(<span class="title">loop</span><span class="body"> [state <span class="list">(<span class="title">initial-state</span><span class="body"> engine)</span></span>]
    <span class="list">(<span class="title">if-let</span><span class="body"> [{<span class="keyword">:keys</span> [cmd data]} <span class="list">(<span class="title">&lt;</span><span class="body">! command-channel)</span></span>]
     <span class="list">(<span class="title">do</span><span class="body">
      <span class="list">(<span class="title">debug</span><span class="body"> <span class="string">"handling index loop command"</span> cmd)</span></span>
       <span class="list">(<span class="title">recur</span><span class="body"> <span class="list">(<span class="title">case</span><span class="body"> cmd
         <span class="keyword">:schedule-indexing</span> <span class="list">(<span class="title">main-indexing-process</span><span class="body"> state)</span></span>
         <span class="keyword">:notify-finished-indexing</span> <span class="list">(<span class="title">main-indexing-process-ended</span><span class="body"> state)</span></span>
         <span class="keyword">:new-index</span> <span class="list">(<span class="title">add-chaser</span><span class="body"> state data)</span></span>
         <span class="keyword">:chaser-finished</span> <span class="list">(<span class="title">finish-chaser</span><span class="body"> state data)</span></span>
         <span class="keyword">:storage-request</span> <span class="list">(<span class="title">storage-request</span><span class="body"> state data)</span></span>)</span></span>)</span></span>)</span></span>
      <span class="list">(<span class="title">do</span><span class="body">
        <span class="list">(<span class="title">debug</span><span class="body"> <span class="string">"being asked to shut down"</span>)</span></span>
        <span class="list">(<span class="title">wait-for-main-indexing</span><span class="body"> state)</span></span>
        <span class="list">(<span class="title">wait-for-chasers</span><span class="body"> state)</span></span>
        <span class="list">(<span class="title">close-open-indexes</span><span class="body"> state)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>
</code></pre><p>Basically re-invent actors but without decent error handling, supervision trees, named processes... So yeah - Clojure, glorious syntax, clever libraries, great data structures, but it&#39;s not Erlang for getting things done in the kind of projects I&#39;m working on at the moment.</p>
<h1 id="where-is-it-then-">Where is it then?</h1>
<p>I can&#39;t see myself using Clojure as a backend language on its own anytime soon. If I&#39;m forced to do something on the JVM (legacy integration, cross my fingers I haven&#39;t got to do that for a while) I can see myself using Clojure to integrate with the legacy syste and export data using the wonderful library Liberator.</p>
<p>I <em>can</em> see myself using Clojurescript rather than the mess that is JS if I have to do any higher value front-end code. (Some of the React wrappers look <em>amazing</em>) and it&#39;s a lot more professional than trying to bodge it together in a broken language. There is a project coming up next year that represents value on the front-end and I suspect it&#39;ll make an appearance there if I can persuade our editors to do sensible CLJS/REPL integration and I can persuade my colleagues to adopt a REPL driven development method on the front-end.</p>
<p><em>Position on the curve:</em> Still interested, I just don&#39;t have use for it at the moment.</p>
]]></description><link>http://codeofrob.com/entries/the-ashton-disinterest-curve---clojure.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-ashton-disinterest-curve---clojure.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 19 Dec 2014 09:30:00 GMT</pubDate></item><item><title><![CDATA[The Ashton Disinterest Curve - Javascript and Node]]></title><description><![CDATA[<p>So far on the &quot;making a point that I&#39;m not all bitterness and hatred&quot; over things tried in the past, I have managed to pretty much write the same <a href="/entries/the-ashton-disinterest-curve---c.html">negative diatribe about .NET</a> that everybody else seems to write after an age of bashing their head against the wall. (Note to naysayers: Maybe there is something to this after all, and no, the decision to OSS a bunch of .NET changes very little about the root problems found in most shops that choose that technology)</p>
<h1 id="i-digress">I digress</h1>
<p>Aaaanyway - when the crippling pain in my wrists got too bad, the first place I sought refuge was a combination of Linux + Vim + JavaScript.</p>
<p>I had always used JS and I had written some pretty cool things in it; It seemed like a natural progression if I wanted to carry on being paid decent money for developing software without having to immediately just drop everything and develop a new career from scratch. Sadly the need to integrate with the Visual Studio users (JS in project files, seriously piss off) eventually put an end to that attempt and I ended up doing node.js at actual node.js based development shops and accidentally ditching Windows forever.</p>
<p>I got a <em>lot</em> done in JS (both on client and server) and for a while really enjoyed writing software in it. A large part of this was because I was used to the type systems in C# and Java style languages and being able to develop software without needless layers of interfaces impeding my progress made feel very warm and fuzzy.</p>
<p>Obviously this came with the price of requiring many more tests, develop everything in self contained modules (not necessarily a bad thing) and dealing with some wildly varying opinions on what constituted &quot;readable JS&quot;.</p>
<p>The saving grace of this language was that it was still pretty untamed and the language had very few features to abuse; maintaining explicitness at the expense of terseness meant that you could fling together some relatively comprehensible systems rather quickly without too much forethought or trouble. Obviously my feelings on steps to &quot;improve&quot; JS are well known, Typescript, Dart and frameworks like Angular trying to treat JS as an actually sensible platform were akin to biblical efforts to build houses on sand or whatever parable you prefer for that purpose here.</p>
<h1 id="where-i-now-stand">Where I now stand</h1>
<p>Since starting to learn languages like Haskell and realising that type systems don&#39;t have to be burdemsone, since developing with Erlang/OTP and seeing first-hand what a sensible networking platform should look like, since learning Clojure and realising terseness doesn&#39;t have to come at the expense of understandability - JS has lost a lot of that initial appeal. Since acknowledging the value of &quot;hammock time&quot; and how certain languages can encourage the use of up-front reasoning I can see that the &quot;<em>just ship some code</em>&quot; mentality  found in the JS world is probably harmful to our long term survival as a professional industry.</p>
<p>It is a language that as an profession we should be pretty ashamed for letting become so popular; it is for cowboy developers writing cowboy systems and anybody setting out to build new applications on top of this (with the intention of longevity) should strongly reconsider. I think that the motivation of using JS to teach programming is understandable because of how accessible it can be to new people but it is also a mistake because it teaches the wrong message about our industry - it is the antithesis to professionalism. If we were ever in a &quot;race to the bottom&quot; then JS can be considered to have won; it has lowered the barrier to entry so far that we&#39;ll be dealing with the consequences of this mistake for decades to come.</p>
<p>For low value UIs, for hackdays, for gamejams, for rapidly building that proof of concept, for that minimal viable product I think that both JS and Node probably have their place. JS is an incredibly fun language to get shit done in providing that you don&#39;t plan on being responsible for that code two <s>years</s> weeks down the line. Every Ludum Dare that I write games for I pick up JS, put on a Stetson and arm myself with a whip and yell YEEHHAAWWW because I&#39;m a cowboy and I like to ride my horse without a saddle.</p>
<p>I <em>love</em> JS for this - despite its contradictions (and mine in this post), I can&#39;t think of any other language or platform where I can simply arm myself with a text editor and see results on my screen immediately in the form of shiny graphics and interactivity. While it is true that more professional languages would aid me in writing something that would be more formal and surviveable - just like writing tests, in the short term it would slow you down and diminish that immediate fun factor.</p>
<p>When we&#39;re are only dealing with the short term or we&#39;re happy that what we are writing is disposable (or just incredibly dull) then JS is a great language because it doesn&#39;t have any of the safeguards that any of the more professional languages or platforms do and as we all know - safeguards are for wusses.</p>
<p>Position on the curve: <em>Shrodingeresque - until directly observed you won&#39;t know if I love it or hate it.</em></p>
]]></description><link>http://codeofrob.com/entries/the-ashton-disinterest-curve---javascript-and-node.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-ashton-disinterest-curve---javascript-and-node.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 17 Nov 2014 09:30:00 GMT</pubDate></item><item><title><![CDATA[The Ashton Disinterest Curve - C#]]></title><description><![CDATA[<p>Kicking off this little series, we enter into the first language/platform I used professionally which is .NET  - I don&#39;t tend to make a secret of this history although I don&#39;t usually admit that I also spent a year writing VB.NET before switching to C# for most things. (This is true, and in some ways VB was actually better at the time)</p>
<h1 id="nothing-new-to-read-here-">Nothing new to read here...</h1>
<p>There is very little I can say negatively about C# and .NET that hasn&#39;t been said before but as I built a lot of software in it I&#39;d be remiss to ignore it in a series like this. The industry built up around it is probably my biggest beef when it comes to being irritated rather than the language and platform itself. The managers who are persuaded by salespeople that what they need is TFS and WCF and other TLAs and then development will be easy. The hordes of developers who blindly just use whatever Microsoft has provided because thinking for yourself is too hard. The tooling and environments that pretty much destroyed my wrists from the crappy mouse-driven UIs (Visual Studio and Windows) and the developers who tried to persuade me every year that &quot;things were changing or different now and it wasn&#39;t like that any more&quot;.</p>
<h1 id="the-software">The software</h1>
<p>Trying to step away from that environment and carry on using C# in a way that wasn&#39;t inside the tooling jail that Microsoft had built for us with esoteric combinations of OmniSharp and ctags and other such things always ended up as a war of attrition and the language itself seemed to be the personal playground for the designers to just stick anything in that people thought was cool two years beforehand. (The inevitable point where Scala and C# are almost the same language draws near...).</p>
<p>Then let&#39;s talk about that; the language started off as a simple Java clone (not starting out brilliantly when you consider the mess of factories and abstract bean providers in that world) and then tacked on layers of complexity solving problems that any real language simply doesn&#39;t have. One thing that moving onto pastures anew has taught me is that the solution to most things is rarely to add more features (and XML rarely solves anything other than data-interchange).</p>
<p>Yet in small projects once you had indeed fought the system and got your mono based development environment up and running C# wasn&#39;t too bad providing you stayed away from the dynamic keyword and frameworks and libraries with their layers of indirection and either over-design based on IOC container magic or lack of it entirely. Compared to other technologies that by default would just work in your choice of environments there just didn&#39;t seem to be enough benefit to justify the effort of getting to this point.</p>
<p>Yes - F# did and does still exist and it is a shining beacon in that world; it is going against the grain much like trying to use alternative environments is and finding a .NET job that <em>actually</em> does F# is like looking for a needle in a haystack. The fervour shown by its many adherents is admirable and I suspect were I forced to do .NET for a project (perhaps integration) this is what I would choose to use and even enjoy but I can&#39;t imagine this happening in the future given the direction my career/life ended up taking.</p>
<h1 id="the-community">The community</h1>
<p>The community and friends that I built up from my time in this pit <em>has</em> stayed with me ever since the beginning; in the same way that being trapped in a broken elevator can bring people together or being held hostage forces people to make connections with those around them - working in the .NET environment forced us to find nearby developers with similar experiences so we could have a few beers at the end of the working day and talk about our shared pains.</p>
<p>The constant aches pains and frustration also led to a lot of conversations about the basic acts of software development (most of it bike-shedding of course) but the constant arguments about tests, SOLID, interface-use and framework adoption and the push to constantly be improving is what pushed me off into different pastures in the first place. This kind of activity going on at community events everywhere even now and these entry level discussions have their use in helping developers to learn to move beyond the status quo and go further than &quot;just enough to make some cash&quot;.</p>
<p>Perhaps this kindergarten has its use, but we all have to grow up and it would be nice if that pain wasn&#39;t even needed.</p>
<p>Current position of .NET on the disinterest curve: <em>Bitter, bitter memories</em>.</p>
<p>Next up is JS/Node, I have nicer things to say about this - promise.</p>
]]></description><link>http://codeofrob.com/entries/the-ashton-disinterest-curve---c.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-ashton-disinterest-curve---c.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 12 Nov 2014 09:30:00 GMT</pubDate></item><item><title><![CDATA[The Exponential Ashton Disinterest Curve]]></title><description><![CDATA[<h1 id="the-catalyst">The catalyst</h1>
<p>I was lucky enough to be able to attend <a href="http://vimeo.com/111028823">Dan North&#39;s recent closing keynote at Oredev</a> in Sweden (and he was lucky enough to be played on by our last-minute rag-tag ukelele troupe).</p>
<p>It&#39;s worth checking out in its entirety as he&#39;s a wonderfully engaging speaker and there were some great stories told during this hour long closing speech.</p>
<p>At one point in the session when discussing passion and motivating people to try new things he made a few remarks concerning the &quot;Exponential Ashton Interest Curve&quot; or something to that end. The gist being that while he might not agree with the way I do it sometimes (Fair: I&#39;m don&#39;t agree with the way I do it sometimes either!), the passion and energy being expended by myself and others like me are what often fuel other people&#39;s interest to go along and start trying something out.</p>
<h1 id="the-curve">The curve</h1>
<p>Over the years many technologies and opinions have appeared on this blog and on the conference circuit as I discover something and decide they are worth discussing. The flipside of this of course is a general perception that once I stop talking about something the only time I&#39;ll ever mention it is if I want to talk about the things I didn&#39;t like about it.</p>
<p>  <blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/RobAshton">@RobAshton</a> it&#39;s been a few weeks since your talk on React, how much do you hate it now :p</p>&mdash; Chris McKee (@chrismckee) <a href="https://twitter.com/chrismckee/status/531830959596118016">November 10, 2014</a></blockquote>
  <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<p>I had more than a few jokes made at my expense on this subject over the next few days as I hung about at the Cheers Booth (The Jetbrains stand where everybody knows your name).</p>
<h1 id="-is-there-anything-you-ve-used-and-actually-like-rob-">&quot;Is there anything you&#39;ve used and actually like Rob?&quot;</h1>
<p>One of the big problems with launching yourself wholeheartedly into learning something deeply enough to do more than simply make a Pluralsight video about it (oof), is that you end up covering a <em>lot</em> of ground with the chosen technology. You internalise a lot of the good things and start storing up a list of the reasons that the technology wasn&#39;t such a good fit for the project you embarked on.</p>
<p>A good example of this is is the database I wrote in Clojure two years ago; shuffling binary data from the public endpoints into an unmanaged storage engine, the concurrency issues over the top of unmanaged resources and the event loops that ended up solving those problems led me to the conclusion that Erlang would have been a better fit for the task at hand. I say that freely when I give talks on Clojure because I think it&#39;s a good example of where Erlang would have shined. What I don&#39;t often mention in these talks is that I really liked working with the REPL (and I miss this every day in Erlang), I miss the polymorphism (Erlang&#39;s built in data structures and modules are a mess) and I miss the terseness of expressions written designed to perform logic around data.</p>
<p>Possibly because I&#39;m British, I tend to focus on the negative aspects of things that I&#39;ve used rather than the positive ones. I also find that in an industry where people constantly wave flags for whatever they&#39;re selling that being loud about the problems I&#39;ve had personally with those technologies helps keep beginners grounded in their expectations. If you&#39;ve ever talked to the Erlang crowd you&#39;ll have encountered the kool-aid addicts and know what I&#39;m talking about.</p>
<p>This tends to give the outward impression that I only like the things I&#39;m currently using and dislike everything else I&#39;ve ever used. In a break from my usual &quot;Urgh, all of this is crap&quot; spiel, let&#39;s have a look at an obvious example: How I currently feel about each language I&#39;ve used over the last decade and whether I actually do indeed hate my past decisions. (I&#39;ll ignore my brief Ruby phase, I couldn&#39;t find it in my heart to say anything nice about it).</p>
<p>First off will be C# (coming tomorrow). Originally I was going to write this as a single blog post but on hitting 3000 words I have decided to split it up into a single technology per entry... If anybody wants anything in particular covered that I&#39;ve gone off about over the last decade feel free to ask how I currently feel and I&#39;ll squeeze it in too.</p>
]]></description><link>http://codeofrob.com/entries/the-exponential-ashton-disinterest-curve.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-exponential-ashton-disinterest-curve.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 10 Nov 2014 09:30:00 GMT</pubDate></item></channel></rss>