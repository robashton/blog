<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>RSS for Node</generator><lastBuildDate>Thu, 07 Oct 2021 16:53:27 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><author><![CDATA[Rob Ashton]]></author><item><title><![CDATA[Purerl - three years on]]></title><description><![CDATA[<p>It has been about three years since I first sat in a hotel in Lithuania throwing together the first versions of <a href="https://github.com/id3as/purescript-erl-pinto">purescript-erl-pinto</a> and <a href="https://github.com/id3as/purescript-erl-stetson">purescript-erl-stetson</a> so that we could get started on a project for one of our clients.</p>
<p>Quite a lot of code has been written against those projects internally by colleagues and myself and over time:</p>
<ul>
<li>Various improvements/patterns have been discovered within core libraries such as <a href="https://github.com/purerl/purescript-erl-process">purescript-erl-process</a>. </li>
<li>A heap of Erlang specific packages have been written and released</li>
<li>Another mountain of packages have been ported across from Purescript </li>
<li>Pinto and Stetson have been upgraded repeatedly by various colleagues as our understanding of what we need them to do has evolved.</li>
</ul>
<p>The <a href="https://purerl-cookbook.readthedocs.io/">purerl cookbook</a> has been updated for these latest releases, as has the <a href="https://github.com/id3as/demo-ps">demo-ps</a> but felt it worthwhile highlighting some of the changes in a few (of my increasingly rare) blog posts.</p>
<p>In this post we&#39;ll be looking at Processes and the concept of &#39;self&#39;</p>
<h1 id="processes">Processes</h1>
<p>A common practise in Erlang codebases is to spawn a new process and use its Pid for communication.</p>
<pre><code class="language-erlang"><span class="hljs-function"><span class="hljs-title">example</span><span class="hljs-params">()</span> -&gt;</span>
  Pid = spawn_link(fun receive_message/0)
  Pid ! hi.

<span class="hljs-function"><span class="hljs-title">receive_message</span><span class="hljs-params">()</span> -&gt;</span>
  <span class="hljs-keyword">receive</span>
    SomeMessage -&gt; 
      ?PRINT(<span class="hljs-string">&quot;Got a message&quot;</span>),
      ok
   <span class="hljs-keyword">end</span>.</code></pre>
<p>In Purerl, the type <em>Pid</em> lives in <em>Erl.Process.Raw</em> and is just an imported foreign type</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">Pid</span> :: <span class="hljs-type">Type</span></code></pre>
<p>This typically isn&#39;t used to any great amount except in some specific FFI cases, it being far better generally to use the types found in <em>Erl.Process</em> which have the phantom type <em>msg</em> floating around meaning all the sends and receives are limited to the types of message that that process has declared it will receive. <em>Process msg</em> itself is just a newtype around Raw.Pid of course.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Process</span> (<span class="hljs-title">a</span> :: <span class="hljs-type">Type</span>)</span>
  = <span class="hljs-type">Process</span> <span class="hljs-type">Raw</span>.<span class="hljs-type">Pid</span></code></pre>
<p>To create a typed process, one could call <em>spawnLink</em> and provide a callback which will be executed in the process created in that underlying call to <em>spawn_link</em> in Erlang. A change made fairly early on in development was to change this callback from something that took some context, to something that operated inside <em>ProcessM msg r</em>, with the context being provided by that monad - this will become important later on in this blog entry so I&#39;ll demonstrate this here.</p>
<h2 id="the-old-way">The old way</h2>
<p>&quot;Given a callback that accepts a <em>SpawnLinkContext</em> typed around <em>msg</em>, run that callback inside a new process and return that new process, also typed around <em>msg</em>&quot;</p>
<pre><code class="language-haskell"><span class="hljs-title">spawnLink</span> :: <span class="hljs-keyword">forall</span> msg. (<span class="hljs-type">SpawnLinkContext</span> msg -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>) -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Process</span> msg)</code></pre>
<p>That context then provided the means of receiving messages, being defined as something like</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">SpawnLinkContext</span> msg = </span>
  { receive :: <span class="hljs-type">Effect</span> msg 
  , receiveWithTimeout :: <span class="hljs-type">Timeout</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Maybe</span> msg)
  }</code></pre>
<p>Thus, the Erlang example, re-written in Purerl would have looked something like this</p>
<pre><code class="language-haskell"><span class="hljs-title">example</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">example</span> = <span class="hljs-keyword">do</span>
  pid &lt;- spawnLink receiveMessage
  pid ! <span class="hljs-string">&quot;hi&quot;</span>

<span class="hljs-title">receiveMessage</span> :: <span class="hljs-type">SpawnLinkContext</span> <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">receiveMessage</span> c = <span class="hljs-keyword">do</span> 
  msg &lt;- c.receive
  log <span class="hljs-string">&quot;Got a message&quot;</span></code></pre>
<h2 id="the-new-way">The new way</h2>
<p>&quot;Evaluate the given code in the context of a <em>ProcessM</em> typed around <em>msg</em>&quot;</p>
<pre><code class="language-haskell"><span class="hljs-title">spawnLink</span> :: <span class="hljs-keyword">forall</span> msg. <span class="hljs-type">ProcessM</span> msg <span class="hljs-type">Unit</span> -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">Process</span> msg)</code></pre>
<p>And quite simply, any calls to receive/etc are defined as functions that operate inside ProcessM, again all typed around <em>msg</em></p>
<pre><code class="language-haskell"><span class="hljs-title">receive</span> :: <span class="hljs-keyword">forall</span> msg. <span class="hljs-type">ProcessM</span> msg msg
<span class="hljs-title">receive</span> = <span class="hljs-type">ProcessM</span> <span class="hljs-type">Raw</span>.receive</code></pre>
<p>This cuts down on the cruft somewhat, as instead of having to pass a context everywhere, one can simply write functions in that context, re-writing that initial example now looks like this (Note that the log call needs lifting into <em>ProcessM</em> because it is written as an <em>Effect</em>)</p>
<pre><code class="language-haskell"><span class="hljs-title">example</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">example</span> = <span class="hljs-keyword">do</span>
  pid &lt;- spawnLink receiveMessage
  pid ! <span class="hljs-string">&quot;hi&quot;</span>

<span class="hljs-title">receiveMessage</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">String</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">receiveMessage</span> = <span class="hljs-keyword">do</span> 
  msg &lt;- receive
  liftEffect $ log <span class="hljs-string">&quot;Got a message&quot;</span></code></pre>
<h2 id="extending-this-model">Extending this model</h2>
<p>It turns out that this is quite a nice pattern for representing the different <em>types</em> of process available in Erlang (OTP, Cowboy and indeed our own application code), consider:</p>
<ul>
<li>Cowboy Loop handlers</li>
<li>Cowboy Websocket handlers</li>
<li>OTP gen_server</li>
<li>OTP supervisor</li>
<li>OTP gen_statem</li>
</ul>
<p>All of these could be ran as <em>ProcessM</em>, except they have more types associated with them <em>and</em> various functions available designed for use in those specific contexts, for example in the simple case of cowboy..</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">WebSocketInfoHandler</span> msg state</span>
  = msg -&gt; state -&gt; <span class="hljs-type">WebSocketResult</span> msg (<span class="hljs-type">WebSocketCallResult</span> state)</code></pre>
<p>We have the types <em>msg</em> and <em>state</em> in our type because the callbacks involved tend to take <em>state</em> and there is a callback (<em>info</em>) for messages received by the loop handler typed around <em>msg</em></p>
<p>In the more complicated case of an OTP GenServer, this looks like this</p>
<pre><code>type C<span class="hljs-literal">all</span>Fn reply cont stop msg <span class="hljs-keyword">state</span>
  = From reply -&gt; <span class="hljs-keyword">state</span> -&gt; ResultT cont stop msg <span class="hljs-keyword">state</span> (C<span class="hljs-literal">all</span>Result reply cont stop <span class="hljs-keyword">state</span>)</code></pre><p>Most operations take place inside that <em>ResultT</em> which encodes the <em>cont</em>, <em>stop</em>, <em>msg</em>, and <em>state</em> types for use with our operations. (<em>cont</em> being the message that can be received by <em>handle_continue</em>, <em>stop</em> being a custom stop reason, <em>msg</em> being messages received by <em>handle_info</em> and <em>state</em> being the state of the gen server).</p>
<p>We also end up with our own contexts in our own codebases for specific process types around common units of business logic. </p>
<h2 id="common-functionality">Common Functionality</h2>
<p>In most of these cases, just like with <em>Process.spawnLink</em>, something gets returned that represents the started process - for example the GenServer.</p>
<pre><code class="language-haskell"><span class="hljs-title">startLink</span> :: <span class="hljs-keyword">forall</span> cont stop msg state. 
  (<span class="hljs-type">ServerSpec</span> cont stop msg state) 
  -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">StartLinkResult</span> (<span class="hljs-type">ServerPid</span> cont stop msg state))</code></pre>
<p>Here we have a <em>ServerPid cont stop msg state</em> returned to the caller - again keeping a lot of useful information around to help us make calls into a GenServer but the type we&#39;re interested in here is <em>msg</em>. Most generic APIs will be written around the concept of a <em>Process msg</em> and what we have here is a <em>ServerPid cont stop msg state</em></p>
<p>The logical step here is to expose</p>
<pre><code class="language-haskell"><span class="hljs-title">toProcess</span> :: <span class="hljs-type">ServerPid</span> cont stop msg state -&gt; <span class="hljs-type">Process</span> msg</code></pre>
<p>It turns out that this is a very common operation and so a typeclass is born and added to Erl.Process for everybody to implement when writing this kind of code.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">HasProcess</span> b a <span class="hljs-keyword">where</span></span>
  getProcess :: a -&gt; <span class="hljs-type">Process</span> b</code></pre>
<p>In fact, two typeclasses are born because some APIs only need a Pid after all.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">HasPid</span> a <span class="hljs-keyword">where</span></span>
  getPid :: a -&gt; <span class="hljs-type">Pid</span></code></pre>
<p>Most functions that take a <em>Process msg</em> therefore don&#39;t actually care about it <em>being</em> a <em>Process msg</em>, but only that a <em>Process msg</em> can be gotten from the type</p>
<pre><code class="language-haskell"><span class="hljs-title">callMe</span> :: <span class="hljs-keyword">forall</span> p msg. 
  <span class="hljs-type">HasProcess</span> msg p =&gt; 
  p -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span></code></pre>
<p>And now all of those custom types can be used with a whole suite of APIs without having to unpack a convoluted structure of newtypes.</p>
<h2 id="self">Self</h2>
<p>There is one more common operation that has been ignored so far, and that is the concept of self. An incredibly common thing in Erlang is to invoke <em>self</em> to get the Pid of the current process.</p>
<pre><code class="language-erlang">Self = self(),
some_api:call_me(Self)</code></pre>
<p>For a while, we started having <em>self</em> methods on every module that exported some monad in which process logic could be evalulated, and this would return the full type of the process (complete with <em>cont</em>, <em>stop</em>, <em>state</em>, etc). There were a lot of <em>self</em> functions being exported and imported and in 99.99% of all cases they were immediately followed by a call to <em>getProcess</em> using the <em>HasProcess</em> typeclass implementation for that system.</p>
<pre><code class="language-haskell">(me :: <span class="hljs-type">Process</span> <span class="hljs-type">MyMsg</span>) &lt;- getProcess &lt;$&gt; <span class="hljs-type">GenServer</span>.self</code></pre>
<p>What does <em>self</em> mean then? The correct answer is as written above, but the correct answer isn&#39;t always the nicest answer - it was very rare that we would need anything from <em>self</em> other than the current <em>Process msg</em> and we were running into issues in modules that had code for more than one of these contexts in them, whose self are we using anyway?</p>
<p>The answer was to be pragmatic and create a typeclass for &#39;<em>any m</em>&#39; that allowed that &#39;<em>m</em>&#39; to export a <em>Process msg</em></p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">HasSelf</span> (<span class="hljs-title">m</span> :: <span class="hljs-type">Type</span> -&gt; <span class="hljs-type">Type</span>) msg | m -&gt; msg <span class="hljs-keyword">where</span></span>
  self :: m (<span class="hljs-type">Process</span> msg)</code></pre>
<p>For the case of anything running inside a <em>ProcessM</em>, this isn&#39;t any more complicated than calling Raw.self to get the current pid and wrapping it up with the relevant newtypes</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> selfProcessM :: <span class="hljs-type">HasSelf</span> (<span class="hljs-type">ProcessM</span> <span class="hljs-title">a</span>) a <span class="hljs-keyword">where</span></span>
  self :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">ProcessM</span> a (<span class="hljs-type">Process</span> a)
  self = <span class="hljs-type">ProcessM</span> $ <span class="hljs-type">Process</span> &lt;$&gt; <span class="hljs-type">Raw</span>.self</code></pre>
<p>Similar implementations then exist for Pinto/Stetson contexts, allowing code to simply call <em>Process.self</em> from practically anywhere to get a typed <em>Process msg</em> valid for the current context.</p>
<pre><code class="language-haskell"><span class="hljs-type">SomeApi</span>.callMe &lt;&lt;&lt; self</code></pre>
<p>All typed, all safe, nobody sent messages they can&#39;t handle - living the dream.</p>
<hr>
<h1 id="subscriptions">Subscriptions</h1>
<p>Two blog posts in a week? Unheard of - following on from last week&#39;s blockbuster smash hit epic &quot;<a href="/">Purerl Updates - Processes and Self</a>&quot;, today we have an entry describing our current thoughts on subscriptions in a Purerl world.</p>
<p>A standard procedure in Erlang, is to invoke an API that then proceeds to send messages back to the invoking process.</p>
<pre><code class="language-erlang">some_api:subscribe()</code></pre>
<p>More often or not, an overload will be provided allowing a Pid to be passed in, in case you didn&#39;t want it sending to <em>self</em>.</p>
<pre><code class="language-erlang">some_api:subscribe(Pid)</code></pre>
<p>We could write a function that looks like this in Purescript (using the typeclasses explored in the previous blog entry).</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> SomeApi <span class="hljs-keyword">where</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">HelloWorld</span> | <span class="hljs-type">Goodbye</span></span>

<span class="hljs-title">subscribe</span> :: <span class="hljs-keyword">forall</span> process. 
  <span class="hljs-type">HasProcess</span> <span class="hljs-type">Msg</span> process =&gt; 
  process -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">subscribe</span> = ...
</code></pre>
<p>In this, we are saying &quot;Given a process that accepts <em>Msg</em>, then the subscription will send <em>msg</em> to you.</p>
<pre><code class="language-haskell"><span class="hljs-title">workerLoop</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">SomeApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">workerLoop</span> = <span class="hljs-keyword">do</span>
  msg &lt;- receive
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span> 
    <span class="hljs-type">HelloWorld</span> -&gt; ...
    <span class="hljs-type">Goodbye</span> -&gt; ...

<span class="hljs-title">main</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> 
  process &lt;- spawnLink workerLoop
  <span class="hljs-type">SomeApi</span>.subscribe process</code></pre>
<p>This isn&#39;t great, typically we don&#39;t write processes this way - processes usually not only want to subscribe to messages from external sources, but also send themselves messages, typically they&#39;ll achieve that by lifting messages into a process specific data type.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ProcessMsg</span> </span>
  = <span class="hljs-type">ApiMsg</span> <span class="hljs-type">SomeApi</span>.<span class="hljs-type">Msg</span>
  | <span class="hljs-type">Tick</span>

<span class="hljs-title">workerLoop</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">ProcessMsg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">workerLoop</span> = ...
</code></pre>
<p>Calling <em>SomeApi.subscribe</em> with this process will result in a compiler error because SomeApi.Msg is the wrong type.</p>
<h2 id="emitters">Emitters</h2>
<p>The pattern we&#39;ve been using up until now to side-step this is for subscription calls to take in a blank cheque in the form of <em>msg -&gt; Effect Unit</em>, allowing the caller to decide what to do with messages on that subscription.</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> SomeApi <span class="hljs-keyword">where</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">HelloWorld</span> | <span class="hljs-type">Goodbye</span></span>

<span class="hljs-title">subscribe</span> :: (<span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>) -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">subscribe</span> = ...
</code></pre>
<p>Subscription could then look like this</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ProcessMsg</span> </span>
  = <span class="hljs-type">ApiMsg</span> <span class="hljs-type">SomeApi</span>.<span class="hljs-type">Msg</span>
  | <span class="hljs-type">Tick</span>

<span class="hljs-title">main</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> 
  process &lt;- spawnLink workerLoop
  <span class="hljs-type">SomeApi</span>.subscribe $ send process &lt;&lt;&lt; <span class="hljs-type">ApiMsg</span></code></pre>
<p>More commonly the use of some form of <em>self</em> would be used inside the process itself, as it makes little sense for one process to subscribe on behalf of another.</p>
<pre><code class="language-haskell"><span class="hljs-title">workerLoop</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">SomeApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">workerLoop</span> = <span class="hljs-keyword">do</span>
  msg &lt;- receive
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span> 
    <span class="hljs-type">HelloWorld</span> -&gt; ...
    <span class="hljs-type">Goodbye</span> -&gt; ...

<span class="hljs-title">startWorker</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">SomeApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">startWorker</span> = <span class="hljs-keyword">do</span>
  me &lt;- self
  liftEffect $ <span class="hljs-type">SomeApi</span>.subscribe $ send me &lt;&lt;&lt; <span class="hljs-type">ApiMsg</span>
  workerLoop

<span class="hljs-title">main</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> 
  _ &lt;- spawnLink workerLoop
</code></pre>
<p>This <em>works</em> and is elegant - and indeed for about two years this has been The Way. Our codebase is/was littered with <em>send me &lt;&lt;&lt; Msg</em>, but in hindsight this isn&#39;t great.</p>
<p>Why not? The problem with <em>Effect Unit</em> is that it can do anything. <em>ANYTHING</em>. The problem with passing an <em>Effect Unit</em> is that it can do that &quot;anything&quot; within the context of a completely different process. This can cause problems.</p>
<p><em>Errors</em>: What happens if the Effect Unit causes an exception? Who crashes? The remote process? Who does that affect? Anybody else who is currently subscribed? How do they find out? Are they in the right supervision tree for this not to be a problem? Can we just swallow the exception? How does the caller find out that it crashed? Oh dear.</p>
<p><em>Interference</em>: What if this is in a message loop doing other things? What if the <em>Effect Unit</em> takes up precious time? What happens to the backlog? What happens to anything awaiting a message with a timeout? </p>
<p>While the reality is that while nearly all our callbacks are implemented as <em>send me &lt;&lt;&lt; Msg</em>, as our codebases grow and we do more and more of these things, somebody is eventually going to cause problems with the above and we&#39;ll be looking at hilarious (and needless) debug sessions as a result. If not us - then somebody else using Purerl (and our numbers <em>are</em> growing...).</p>
<h2 id="hasself-to-the-rescue">HasSelf to the rescue</h2>
<p>HasSelf was added fairly recently and makes it possible to write code that operates inside any monad provided it has an implementation of &#39;self&#39;.</p>
<pre><code class="language-haskell"><span class="hljs-title">saferSubscribe</span> ::
  <span class="hljs-keyword">forall</span> m msg.
  <span class="hljs-type">MonadEffect</span> m =&gt;
  <span class="hljs-type">HasSelf</span> m msg =&gt;
  (<span class="hljs-type">Msg</span> -&gt; msg) -&gt; m <span class="hljs-type">Unit</span>
<span class="hljs-title">saferSubscribe</span> f = <span class="hljs-keyword">do</span>
  me :: (<span class="hljs-type">Process</span> msg) &lt;- self
  liftEffect $ subscribe $ send me &lt;&lt;&lt; f
  pure unit</code></pre>
<p>Adding onto that, we need to assert that we can evaluate effects in this monad (MonadEffect m =&gt;) in order to actually issue the subscription and suddenly our call to this becomes</p>
<pre><code class="language-haskell"><span class="hljs-title">workerLoop</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">SomeApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">workerLoop</span> = <span class="hljs-keyword">do</span>
  msg &lt;- receive
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span> 
    <span class="hljs-type">HelloWorld</span> -&gt; ...
    <span class="hljs-type">Goodbye</span> -&gt; ...

<span class="hljs-title">startWorker</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">SomeApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">startWorker</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-type">SomeApi</span>.saferSubscribe <span class="hljs-type">ApiMsg</span>
  workerLoop

<span class="hljs-title">main</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span> 
  _ &lt;- spawnLink workerLoop
</code></pre>
<p>Note: The liftEffect is gone, as is the call to &#39;self&#39;, the API looks a <em>lot</em> more like the original Erlang and is safer while we&#39;re at it. </p>
<p>Because it&#39;s no longer a blank cheque, we should probably provide a second method (just like in Erlang) that takes a process to send messages to instead of simply relying on &#39;self&#39;.</p>
<pre><code class="language-haskell"><span class="hljs-title">saferSubscribeTo</span> ::
  <span class="hljs-keyword">forall</span> msg.
  <span class="hljs-type">Process</span> msg -&gt; (<span class="hljs-type">Msg</span> -&gt; msg) -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">saferSubscribeTo</span> p f = <span class="hljs-keyword">do</span> subscribe $ send p &lt;&lt;&lt; f</code></pre>
<p>This is how most of our subscriptions now look across Pinto/our own code/etc. It&#39;s safer for everybody concerned and fits well with the ethos of &#39;trying to look like the Erlang APIs most of this stuff is built on top of&#39;.</p>
<h1 id="untagged-unions--erlang-messages">Untagged Unions + Erlang Messages</h1>
<p>Yes, another blog post about Purerl, following on from</p>
<ul>
<li><a href="/">Purerl Updates - Processes and Self</a></li>
<li><a href="/">Purerl Updates - Subscriptions</a></li>
</ul>
<p>We are now here to talk about untagged unions and how they can be used when dealing with legacy messages being sent to our process and why we might want to do something differently at all.</p>
<p>Consider a dependency to a legacy Erlang library that has a subscribe call that sends us messages</p>
<pre><code class="language-erlang">legacy_api:subscribe(),

<span class="hljs-keyword">receive</span> 
  { data, Bin } -&gt; ..
  { err, Reason } -&gt; ..
  eof -&gt; ..
</code></pre>
<p>It isn&#39;t possible to subcribe to this in Purescript without doing <em>something</em> to unpack those Erlang types. We could have</p>
<pre><code class="language-haskell"><span class="hljs-title">workerLoop</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">Foreign</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">workerLoop</span> = <span class="hljs-keyword">do</span>
  msg &lt;- receive
  <span class="hljs-keyword">case</span> (<span class="hljs-type">LegacyApi</span>.unpack msg) <span class="hljs-keyword">of</span> 
    <span class="hljs-type">Err</span> err -&gt; ...
    <span class="hljs-type">Data</span> bin -&gt; ...
    <span class="hljs-type">Fin</span> -&gt; ...

<span class="hljs-title">startWorker</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">Foreign</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">startWorker</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-type">LegacyApi</span>.subscribe
  workerLoop
</code></pre>
<p>Simply leaving it to the caller to know that the Foreign needs running through the API again in order to decipher it.</p>
<p>We could also use the MessageRouter in Pinto to spin up another process that knows how to do this for us so this translation is already done once we&#39;re in user code</p>
<pre><code class="language-haskell"><span class="hljs-keyword">import</span> Pinto.MessageRouter <span class="hljs-keyword">as</span> MR

<span class="hljs-title">workerLoop</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">LegacyApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">workerLoop</span> = <span class="hljs-keyword">do</span>
  msg &lt;- receive
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span> 
    <span class="hljs-type">Err</span> err -&gt; ...
    <span class="hljs-type">Data</span> bin -&gt; ...
    <span class="hljs-type">Fin</span> -&gt; ...

<span class="hljs-title">startWorker</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">LegacyApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">startWorker</span> = <span class="hljs-keyword">do</span>
  me &lt;- self
  <span class="hljs-type">MR</span>.startRouter <span class="hljs-type">LegacyApi</span>.subscribe <span class="hljs-type">LegacyApi</span>.unsubscribe (self self &lt;&lt;&lt; <span class="hljs-type">LegacyApi</span>.unpack)
  workerLoop</code></pre>
<p>This is a viable solution for <em>most</em> scenarios because it is easy to understand, reasonably lightweight, allows us to accept more than one kind of message, etc. It incur the &quot;cost&quot; of spinning up another process, and it does incur the cost of doubling the number of messages being sent for a single interaction.</p>
<p>Usually this isn&#39;t a problem (or more - if doubling the messages or processes is going to cause you issues, then it&#39;s possible that the codebase already has issues anyway!). </p>
<p>Having said all of that, for FFI around existing Erlang where there are there are numerous variants, writing mapping code in Erlang could be rather error prone (and passing in constructors from Purescript gets tiresome after half a dozen) - it starts to make sense to instead try to describe the data types &quot;in place&quot; in Purescript using something formal.</p>
<p>For this, there is the package <a href="https://github.com/id3as/purescript-erl-untagged-union">purescript-untagged-union</a>.</p>
<p>Now, two of these values are directly representable in Purescript because of the way in which types are represented in Erlang under the hood.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">LegacyMsg</span> </span>
  = <span class="hljs-type">Err</span> <span class="hljs-type">Binary</span>
  | <span class="hljs-type">Data</span> <span class="hljs-type">Binary</span></code></pre>
<p>We can let the untagged unions library know that underlying data maps onto this with an instance of RuntimeType that describes it</p>
<pre><code class="language-haskell">instance legacyMsg_runtimeType ::
  RuntimeType
    LegacyMsg
    (RTOption (RTTuple2 (RTLiteralAtom &quot;err&quot;) RTBinary)
               RTTuple2 (RTLiteralAtom &quot;data&quot; RTBinary))</code></pre>
<p>Come to think of it, that &#39;err&#39; is horrible, we&#39;re in Purescript and there is no reason to have such an ugly constructor - how about renaming it during mapping?</p>
<pre><code class="language-haskell">data LegacyMsg 
  = Error Binary
  | Data Binary

instance legacyMsg_runtimeType ::
  RuntimeType
    LegacyMsg
    (RTOption (RTTuple2 (RTLiteralAtomConvert &quot;err&quot; &quot;error&quot;) RTBinary)
               RTTuple2 (RTLiteralAtom &quot;data&quot; RTBinary))</code></pre>
<p>We still have that atom all by itself however, the atom &#39;fin&#39; isn&#39;t representable as a Purescript type, it is only an Atom but we&#39;d like still like to be able to receive it! </p>
<p>Well, we can build a type that represents our incoming messages, including that atom.</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">Union</span> |$| <span class="hljs-type">AtomSymbol</span>.<span class="hljs-type">Atom</span> &quot;fin&quot; |+| <span class="hljs-type">LegacyMsg</span> |+| <span class="hljs-type">Nil</span></span></code></pre>
<p>And then all that is left is to use this in a process that can receive these messages</p>
<pre><code class="language-haskell"><span class="hljs-title">workerLoop</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">LegacyApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">workerLoop</span> = <span class="hljs-keyword">do</span>
  msg &lt;- receive
  ( case_ 
      # on (\(m&#x27; :: <span class="hljs-type">LegacyMsg</span>) -&gt;
          <span class="hljs-keyword">case</span> m&#x27; <span class="hljs-keyword">of</span> 
            <span class="hljs-type">Err</span> err -&gt; ...
            <span class="hljs-type">Data</span> bin -&gt; ...
        )
      # on (\(_ :: <span class="hljs-type">AtomSymbol</span>.<span class="hljs-type">Atom</span> <span class="hljs-string">&quot;fin&quot;</span>) -&gt;
            ...
        )
  ) msg

<span class="hljs-title">startWorker</span> :: <span class="hljs-type">ProcessM</span> <span class="hljs-type">LegacyApi</span>.<span class="hljs-type">Msg</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">startWorker</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-type">LegacyApi</span>.subscribe 
  workerLoop</code></pre>
<p>This needs to be exhaustive or we will get a compile error which is super cool. </p>
<p>All of this works without an additional process or a fumbly mapping layer. It&#39;s not perfect and relies on actually getting the type description correct but this at least presents a way of doing it without writing error-prone Erlang, which can be useful when dealing with APIs that have a whole array of random structures.</p>
]]></description><link>http://codeofrob.com/entries/purerl---three-years-on.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl---three-years-on.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 06 Apr 2021 09:30:00 GMT</pubDate></item><item><title><![CDATA[Write Your Erlang Gen Servers in Visual Basic]]></title><description><![CDATA[<p>TLDR: <a href="https://github.com/robashton/erlang.net">Erlang.NET Released on Github</a></p>
<p>I&#39;ve been working in Erlang now for nearly a decade and for the last year or two we have been investigating what it would take to start writing a <em>lot</em> more of that Erlang in Purescript instead because in theory working in a sensibly typed language means fewer bugs means fewer support calls means more time spent working on features which can be sold and therefore this is good for profit margins.</p>
<p>Well let me tell you - it blows, we have lost weeks trying to write typeclasses around row types to confirm that &#39;this chunk of binary is good to go into this piece of code that just wants a chunk of binary&#39; and months pontificating over whether an attribute should be declared at the type-level or merely at runtime and whilst progress has been made, it has been a slow and painful exercise.</p>
<p><em>There has to be a better way</em></p>
<p>I worked with one of my colleagues in a previous job many years ago - it was an honest living. We wrote VB.NET together in the heyday of .NETs 1 and 2 and by golly we were very productive indeed. It has types but it also has freedom, It has generics but it also reads really cleanly because so much of its syntax is just <em>words</em> - in other words it is almost the perfect language for writing expressive code. Since departing the world of dotnet however I have noticed its younger brother, C#, appearing in environments like Unity and other game engines as a scripting utility and that got me thinking - what if we could use host .NET in a similar way and use C# as a <em>real</em> language and build real software with it instead? (Leaving us to use VB.NET at our leisure whilst appealing to the masses that prefer C#). </p>
<p><em>Catching up with dotnet</em></p>
<p>It has been a while since I touched base with dotnet, probably again about a decade. I largely quit because the default tooling was very mouse heavy and my wrists were starting to get sore (true story), not to mention most enterprise shops using the technology being <a href="/entries/why-you-cant-be-a-good-.net-developer.html">heavy with the derp</a>. (Some) things have apparently changed since then, tooling-wise everything seems to revolve around the <em>dotnet</em> CLI and with the language-server happenings being commonplace across most platforms, the support for writing .NET languages in Vim is not half bad out of the gate. Huzzah.</p>
<p>.NET Core 5.0.0 seemed the obvious candidate seeing as that seems to be a unification point for all the complicated versioning stories that Microsoft is so fond of creating. Version <em>5.0.0</em>, not just one zero - but two, that&#39;s how you know that software is ready for use!</p>
<p><em>The solution</em></p>
<p>We have a lot of legacy Erlang so if we&#39;re to start writing dotnet code to replace it we&#39;ll first need to find a way to interoperate - the <em>obvious</em> solution is to launch the dotnet code inside the existing Erlang Application side by side so they can talk to each other.</p>
<p>If we write the following app in dotnet (spin up a gen server and return the pid)</p>
<pre><code class="language-csharp">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyEnterpriseGradeApp</span> : <span class="hljs-title">IApp</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">return</span> GenServer.StartLink(() =&gt; <span class="hljs-keyword">new</span> MyCoolGenServer() );
    }
  }</code></pre>
<p>We can embed it in a standard Erlang Gen Supervisor like so:</p>
<pre><code class="language-erlang">
  init([]) -&gt;
    {ok, { #{ strategy =&gt; one_for_one }, 
           #{ start =&gt; { dotnet_shim
                       , start_link
                       , [ <span class="hljs-string">&quot;priv/acme.dll&quot;</span>, <span class="hljs-string">&quot;Acme.MyEnterpriseGradeApp&quot;</span> ]
                       }
            , id =&gt; acme_app
            , type =&gt; worker
            }
       ]}}.
</code></pre>
<p>And this <em>just works</em> - Those of you who know both Erlang and dotnet at this point will hopefully be picking your jaw back off the floor - what on earth is going on here?</p>
<p><em>The simplest example</em></p>
<p>At its heart, an <em>IApp</em> is simply a class that has a Start method that&#39;ll return <em>something</em> back up to Erlang, these can be launched manually from Erlang to execute arbitrary code - for example, here is an app written in dotnet that returns a fixed string to us...</p>
<pre><code class="language-csharp">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloApp</span> : <span class="hljs-title">IApp</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Joe&quot;</span>;
    }
  }
</code></pre>
<p>Can be executed from Erlang like so</p>
<pre><code class="language-erlang">  { ok, Result } = dotnet:run_app_from_assembly(<span class="hljs-string">&quot;priv/acme.dll&quot;</span>, <span class="hljs-string">&quot;Acme.HelloApp&quot;</span>),
  ?LOG(Result). <span class="hljs-comment">%% Hello Joe</span></code></pre>
<p>You will notice that the result from dotnet was automatically wrapped in an <em>{ok, Result}</em> tuple, as most Erlang APIs will expect that, if our dotnet code throws an exception then this will be automatically returned back as an <em>{ error, Reason }</em> instead - this seemed to be the cleanest way of expressing error conditions (and a special Exception (<em>TermException</em>) class is provided for explicitly providing that Reason to the Erlang host.</p>
<p><em>Passing values in</em></p>
<p>A generic implementation of <em>IApp</em> exists, <em>IApp<TArgs></em>, for which an input can be requested by the <em>Start</em> method, for example adding two numbers together</p>
<pre><code class="language-csharp">  public class AddApp : IApp&lt;Tuple&lt;Int,Int&gt;&gt; {
    public Object Start((int x, int y)) {
      return x + y;
    }
  }
</code></pre>
<pre><code class="language-erlang">  { ok, Result } = dotnet:run_app_from_assembly(<span class="hljs-string">&quot;priv/acme.dll&quot;</span>, <span class="hljs-string">&quot;Acme.AddApp&quot;</span>, { <span class="hljs-number">5</span>, <span class="hljs-number">5</span> }),
  ?LOG(Result). <span class="hljs-comment">%% 10</span></code></pre>
<p>The observant reader will notice that we&#39;re using a dotnet <em>Tuple&lt;Int, Int&gt;</em> here and passing in an erlang tuple <em>{ integer(), integer }</em> and it just maps across automatically, how does this work? Ah well, go read the source code to find out or wait for the blog posts that I&#39;ll be writing on that subject, for now just accept that you can stick pretty much anything in your type signature and the equivalent Erlang types will get converted across. How about using a record instead of the tuple for example?</p>
<pre><code class="language-csharp">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">AddArgs</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> X, <span class="hljs-built_in">int</span> Y</span>)</span>;

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AddApp</span> : <span class="hljs-title">IApp</span>&lt;<span class="hljs-title">AddArgs</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params">AddArgs args</span>)</span> {
      <span class="hljs-keyword">return</span> args.X + args.Y;
    }
  }
</code></pre>
<pre><code class="language-erlang">  { ok, Result } = dotnet:run_app_from_assembly(<span class="hljs-string">&quot;priv/acme.dll&quot;</span>, <span class="hljs-string">&quot;Acme.HelloApp&quot;</span>, #{ x =&gt; <span class="hljs-number">5</span>, y =&gt; <span class="hljs-number">5</span> }),
  ?LOG(Result). <span class="hljs-comment">%% 10</span></code></pre>
<p>Not a problem. The observant reader will notice that not only is the casing automatically adjusted (Erlang is typically <em>snake_case</em>, and dotnet is typically <em>PascalCase</em>) but return type of Start is just a plain ol&#39; object, and the same thing applies there, return anything you like and it&#39;ll get converted into something that Erlang will understand. Records on records? Not a problem.</p>
<pre><code class="language-csharp">
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">ComplexReturnValue</span> {
    <span class="hljs-keyword">public</span> AnotherComplexValue Why { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> String Rye { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">AnotherComplexValue</span> (<span class="hljs-params"> <span class="hljs-built_in">string</span> Because </span>)</span>;

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ComplexApp</span> : <span class="hljs-title">IApp</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ComplexReturnValue {
        Why = <span class="hljs-keyword">new</span> () { 
          Because = <span class="hljs-string">&quot;We can&quot;</span>
        },
        Y = <span class="hljs-number">1337</span>,
        Rye = <span class="hljs-string">&quot;Rittenhouse&quot;</span>
      };
    }
  }</code></pre>
<pre><code class="language-erlang">  { ok, #{ why := #{ because := Reason }
         , y := Number
         , rye := Whisky
  }} = dotnet:run_app_from_assembly(<span class="hljs-string">&quot;priv/acme.dll&quot;</span>, <span class="hljs-string">&quot;Acme.ComplexApp&quot;</span>),

  <span class="hljs-comment">%% Why: &quot;We can&quot;, y: 1337, rye: &quot;Rittenhouse&quot;</span>
  ?LOG(<span class="hljs-string">&quot;Why: ~p, y: ~p, rye: ~p ~n&quot;</span>, [Reason, Number, Whisky ]). 
</code></pre>
<p><em>Back to that Dotnet GenServer then</em></p>
<p>We&#39;ve established that we can invoke arbitary dotnet code from Erlang, which is already probably one of the most useful things I&#39;ve created this year - the Erlang eco system is almost non-existent and being able to access all of that open source technology in Nuget is going to save us a lot of future development time. Going back to the start of this blog post our very first example was one of spinning up an actual genserver in dotnet - that is to say, code that is going to execute in its own Erlang process and in turn be able to execute its own arbitrary logic outside of the single function call that kicked that off.</p>
<p>That example again:</p>
<pre><code class="language-csharp">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyEnterpriseGradeApp</span> : <span class="hljs-title">IApp</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">return</span> GenServer.StartLink(() =&gt; <span class="hljs-keyword">new</span> MyCoolGenServer() );
    }
  }</code></pre>
<p>A standard gen server in Erlang would look something like this</p>
<pre><code class="language-erlang"><span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(Arg1, Arg2)</span> -&gt;</span>
  <span class="hljs-comment">%% Executed in host process</span>
  gen_server:start_link({local, ?MODULE}, [Arg1, Arg2]).

<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([Arg1, Arg2])</span> -&gt;</span>
  <span class="hljs-comment">%% Executed in new gen process</span>
  #state { one = Arg1, two = Arg2 }</code></pre>
<p>In the dotnet above, initial StartLink call takes place in the host process, and the callback is what is invoked in the init call and is expected to return &#39;some state&#39;. At its simplest, that state could just be an empty object:</p>
<pre><code class="language-csharp">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCoolGenServer</span> {}</code></pre>
<p>In Erlang, if you want to invoke some code in the process that kicked off these shenanigans, you would invoke that code via a gen_server method (call/cast) or send a message via the pid using the bang (<em>!</em>) operator, and so long as the relevant callback was implemented that would result in something happening.</p>
<pre><code class="language-erlang"><span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">()</span> -&gt;</span>
  gen_server:start_link({local, ?MODULE}, []).

<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([])</span> -&gt;</span>
  #state{}

handle_info(Msg, State) -&gt;
  ?LOG(Msg),
  {noreply, State}.</code></pre>
<p>Used as thus</p>
<pre><code class="language-erlang">  { ok, Pid } = my_cool_genserver:start_link(),

  <span class="hljs-comment">%% Hello Robert</span>
  Pid ! <span class="hljs-string">&quot;Hello Robert&quot;</span>.
</code></pre>
<p>The same thing works in dotnet (woah), we just need to implement an interface on the object that gets returned in that init call</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCoolGenServer</span> : <span class="hljs-title">IHandleInfo</span>&lt;<span class="hljs-title">String</span>&gt; {
  <span class="hljs-function"><span class="hljs-keyword">public</span> HandleInfoResult <span class="hljs-title">HandleInfo</span>(<span class="hljs-params">HandleInfoContext ctx, String msg</span>)</span> {
    Console.WriteLine(msg);
    <span class="hljs-keyword">return</span> ctx.NoReply();
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyEnterpriseGradeApp</span> : <span class="hljs-title">IApp</span> {
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> { 
    <span class="hljs-keyword">return</span> GenServer.StartLink(() =&gt; <span class="hljs-keyword">new</span> MyCoolGenServer());
  }
}
</code></pre>
<pre><code class="language-erlang">  { ok, Pid } = dotnet_shim:start_link(<span class="hljs-string">&quot;priv/acme.dll&quot;</span>, <span class="hljs-string">&quot;Acme.MyEnterpriseGradeApp&quot;</span> ),

  <span class="hljs-comment">%% Hello Robert</span>
  Pid ! <span class="hljs-string">&quot;Hello Robert&quot;</span>.
</code></pre>
<p>Yes, this just works - arbitrary messages sent from Erlang to a process started (and running!) in dotnet arrive and get translated accordingly. How about doing something with state then?</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AdditionServer</span> : <span class="hljs-title">IHandleCall</span>&lt;<span class="hljs-title">int</span>&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> total = <span class="hljs-number">0</span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HandleCall</span>(<span class="hljs-params">HandleCallContext ctx, <span class="hljs-built_in">int</span> msg</span>)</span> {
    <span class="hljs-keyword">this</span>.total += msg;
    <span class="hljs-keyword">return</span> ctx.Reply(total);
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AdditionApp</span> : <span class="hljs-title">IApp</span> {
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> { 
    <span class="hljs-keyword">return</span> GenServer.StartLink(() =&gt; <span class="hljs-keyword">new</span> AdditionServer());
  }
}</code></pre>
<pre><code class="language-erlang">  { ok, Pid } = dotnet_shim:start_link(<span class="hljs-string">&quot;priv/acme.dll&quot;</span>, <span class="hljs-string">&quot;Acme.AdditionApp&quot;</span> ),

  <span class="hljs-comment">%% 1</span>
  ?LOG(gen_server:call(Pid, <span class="hljs-number">1</span>)),
  <span class="hljs-comment">%% 5</span>
  ?LOG(gen_server:call(Pid, <span class="hljs-number">4</span>)),
  <span class="hljs-comment">%% 11</span>
  ?LOG(gen_server:call(Pid, <span class="hljs-number">6</span>)),
</code></pre>
<p>In Erlang we&#39;d have a state record that needs returning as part of the handle_info callback, but that is because Erlang doesn&#39;t have mutation. Dotnet is somewhat fuller featured in this regard and we can just store our state on a member variable and forgo the extra steps required to dance around immutable structures.</p>
<p><em>Pattern Matching in Dotnet</em></p>
<p>Now you&#39;ll notice that our IHandleInfo/IHandleCall interfaces are generic and take the input shape expected, but it&#39;s really common in Erlang for a handle_info call to take a multitude of shapes and perform pattern matching based on those shapes to perform the correct block of logic.</p>
<p>Consider this code written in Erlang</p>
<pre><code class="language-erlang">
handle_info({tell_me, Pid}, State = #state { value = Value }) -&gt; 
  Pid ! Value,
  {noreply, State};
handle_info({op, {add, X}}), State = #state { value = Value }) -&gt; 
  {noreply, State#state { value = Value + X }};
handle_info({op, {mul, X}}), State = #state { value = Value }) -&gt; 
  {noreply, State#state { value = Value * X }}.
</code></pre>
<p>This code either receives a <em>{ atom(), pid() }</em>, or <em>{ atom(), { atom(), integer() }}</em>, we don&#39;t have union types in dotnet so can&#39;t map this across cleanly - or <em>can we</em>. C# has some semblance of pattern matching these days as any good scripting language should - what if we just request &#39;Object&#39; as our message type instead?</p>
<pre><code class="language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCoolGenServer</span> : <span class="hljs-title">IHandleInfo</span>&lt;<span class="hljs-title">Object</span>&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">0</span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> HandleInfoResult <span class="hljs-title">HandleInfo</span>(<span class="hljs-params">HandleInfoContext ctx, Object msg</span>)</span> {
    <span class="hljs-keyword">switch</span>(msg) {
      <span class="hljs-keyword">case</span> Tuple&lt;Atom, Pid&gt; t <span class="hljs-keyword">when</span> t.Item1 == <span class="hljs-string">&quot;tell_me&quot;</span>:
        Erlang.Send(t.Item2, <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> Tuple&lt;Atom, Tuple&lt;Atom, Int&gt;&gt; <span class="hljs-keyword">when</span> t.Item1 == <span class="hljs-string">&quot;op&quot;</span> 
                                         &amp;&amp; t.Item2.Item1 == <span class="hljs-string">&quot;add&quot;</span>:
        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> += t.Item2.Item2;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> Tuple&lt;Atom, Tuple&lt;Atom, Int&gt;&gt; <span class="hljs-keyword">when</span> t.Item1 == <span class="hljs-string">&quot;op&quot;</span> 
                                         &amp;&amp; t.Item2.Item1 == <span class="hljs-string">&quot;mul&quot;</span>:
        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> *= t.Item2.Item2;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-literal">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TermException(<span class="hljs-string">&quot;Unsupported message received&quot;</span>);
    }
    <span class="hljs-keyword">return</span> ctx.NoReply();
  }
}</code></pre>
<p>Okay it&#39;s not the nicest example in the world but it <em>works</em>. <em>Atom</em> and <em>Pid</em> by the way are C# types that wrap the <em>concept</em> of an Atom (just a string really) and an instance of a <em>Pid</em> respectively. An Erlang static class exists for doing things like sending data to an arbitrary pid and that&#39;s what is invoked in that above code. </p>
<p>Now that&#39;s interesting, <em>Erlang.Send</em>? That smells a lot like we&#39;re calling Erlang from dotnet and you know why? It&#39;s because we&#39;re calling Erlang from dotnet.</p>
<p><em>Using Dynamic to invoke arbitrary Erlang code from Dotnet</em></p>
<p>There is absolutely no point in writing gen servers in dotnet if we then go and use the dotnet File or Sockets API (or perform any other IO for that matter). One of the more glorious aspects of writing Erlang is that when you&#39;re opening handles to various IO, you&#39;re actually spinning up processes that are linked to an owner and a pile of excellent behaviour is there by default to ensure that if the host crashes that the supervision tree will handle that, restart appropriate children and those handles will get <em>closed cleanly</em>. This is <em>baked right into OTP</em> and is one of the reasons why implementions of actor models in platforms such as Java/Scala (Akka) are missing 100% of the shots they&#39;re taking. (This also goes double for implementing these patterns using <a href="http://codeofrob.com/entries/the-ashton-disinterest-curve---clojure.html">core.async in Clojure</a> but I digress)</p>
<p>It makes sense therefore to just allow the execution of arbitrary Erlang code from dotnet and therefore open access to these APIs.</p>
<p>Consider <em><a href="https://erlang.org/doc/man/file.html#write_file-2">file:write_file</a></em> for example</p>
<pre><code class="language-csharp">  result = Erlang.Modules.File.WriteFile(&quot;foo.txt&quot;, Encoding.ASCII.GetBytes(&quot;please write me to that file));
  switch(result) {
    case Atom a when a == &quot;ok&quot;: 
      return;
    default: 
      throw new TermException&quot;That didn&#x27;t work&quot;);
  }</code></pre>
<p>Works out of the box. How about <em><a href="https://erlang.org/doc/man/file.html#open-2">file:open</a></em>, <em><a href="https://erlang.org/doc/man/file.html#write-2">file:write</a></em> and <em><a href="https://erlang.org/doc/man/file.html#close-1">file:close</a></em>?</p>
<p>Like most of the Erlang APIs, file:open effectively returns a pid which is linked to the parent process. This also <em>just works</em> in Erlang.NET.</p>
<pre><code class="language-csharp">
  <span class="hljs-comment">// Open the file handle and stash the pid for future use</span>
  Tuple &lt;Atom, Pid&gt; success = (Tuple&lt;Atom,Pid&gt;)Erlang.Modules.File.Open(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-keyword">new</span> Atom(<span class="hljs-string">&quot;write&quot;</span>) } );
  <span class="hljs-keyword">this</span>.pid = success.Item2;

  <span class="hljs-comment">// And then do some of this</span>
  Erlang.Modules.File.Write(<span class="hljs-keyword">this</span>.pid, data);
  Erlang.Modules.File.Write(<span class="hljs-keyword">this</span>.pid, data);
  Erlang.Modules.File.Write(<span class="hljs-keyword">this</span>.pid, data);

  <span class="hljs-comment">// And at some point</span>
  Erlang.Modules.File.Close(<span class="hljs-keyword">this</span>.pid);
  <span class="hljs-keyword">this</span>.pid = ErlNifPid.Zero;

</code></pre>
<p>In a similar vein, that also means that APIs that involve messages being sent back to the parent process work as well - this can either be implemented in the IHandleInfo as above, or we can spin up an arbitrary process in dotnet to handle those specific messages. Doing this and wrapping this functionality in a dotnet class is a far more pleasant way of hiding the low level dynamic call taking place and exporting a nicer API to the dotnet client.</p>
<pre><code class="language-csharp">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GenUdp</span> {

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pid <span class="hljs-title">Open</span>(<span class="hljs-params">Tuple&lt;Int, Int, Int, Int&gt; ip, <span class="hljs-built_in">int</span> port</span>)</span> {
     Pid parent = Erlang.Self();
     <span class="hljs-keyword">return</span> Process.Spawn((Process ctx) =&gt; {
      Tuple&lt;Atom, Pid&gt; success = (Tuple&lt;Atom, Pid&gt;)Erlang.Modules.GenUdp.Open(port, 
      <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { Tuple.Create(<span class="hljs-keyword">new</span> Atom(<span class="hljs-string">&quot;ip&quot;</span>), ip)
                   , Tuple.Create(<span class="hljs-keyword">new</span> Atom(<span class="hljs-string">&quot;active&quot;</span>), <span class="hljs-literal">true</span>)
                   }
      });
      <span class="hljs-keyword">return</span> ReceiveLoop(parent, process);
    });
  }


  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ProcessResult <span class="hljs-title">ReceiveLoop</span>(<span class="hljs-params">Pid parent, Process process</span>)</span> {
    process.Receive((Process process, Object msg) =&gt; {
      <span class="hljs-keyword">switch</span>(msg) {
        <span class="hljs-keyword">case</span> Tuple&lt;Atom, Pid, Tuple&lt;Int,Int,Int,Int&gt;, Int, Byte[]&gt; data: 
          Erlang.send(parent, data.Item5);
          <span class="hljs-keyword">return</span> ReceiveLoop(parent, process);
        <span class="hljs-literal">default</span>:
          <span class="hljs-keyword">return</span> process.Finish(<span class="hljs-keyword">new</span> Atom(<span class="hljs-string">&quot;ok&quot;</span>));
      }
    })
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>(<span class="hljs-params">Pid pid</span>)</span> {
    Erlang.Send(pid, <span class="hljs-keyword">new</span> Atom(<span class="hljs-string">&quot;stop&quot;</span>));
  }</code></pre>
<p>And this would allow us to write a gen server which connects to a udp socket and writes everything it receives to disk. (Assuming we&#39;ve wrapped file:open/etc the same way as we just did with UDP)</p>
<pre><code class="language-csharp">
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UdpToFileServer</span> : <span class="hljs-title">IHandleInfo</span>&lt;<span class="hljs-title">Byte</span>[]&gt;, <span class="hljs-title">IHandleTerminate</span> {
    <span class="hljs-keyword">private</span> Pid udp;
    <span class="hljs-keyword">private</span> Pid file;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UdpToFileServer</span>(<span class="hljs-params">String filename, Tuple&lt;Int,Int,Int,Int&gt; ip, <span class="hljs-built_in">int</span> port</span>)</span> {
      <span class="hljs-keyword">this</span>.udp = GenUdp.Open(Tuple.Create(ip, port));
      <span class="hljs-keyword">this</span>.file = ErlangFile.Open(filename, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-keyword">new</span> Atom(<span class="hljs-string">&quot;write&quot;</span>) } );
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> HandleInfoResult <span class="hljs-title">HandleInfo</span>(<span class="hljs-params">HandleInfoContext ctx, Byte[] bin</span>)</span> {
      ErlangFile.Write(<span class="hljs-keyword">this</span>.file, bin);
    }

    <span class="hljs-comment">// Not necessary, but be kind</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Terminate</span>(<span class="hljs-params"></span>)</span> {
      GenUdp.Stop(udp);
      ErlangFile.Close(file);
    }
  }
</code></pre>
<p><em>Building more of the application in dotnet itself</em></p>
<p>So far we&#39;ve demonstrated how you can invoke arbitary code written in dotnet from Erlang, spin up processes written in dotnet (either as standalone processes or as gen servers), and invoke arbitrary Erlang code from dotnet as well as all the magic type back and forth nonsense we&#39;ve managed to pack into this library.</p>
<p>What if we want to build more complex functionality in dotnet? It&#39;s one thing spinning up a single process which then spins up ad-hoc processes itself, but to build a proper reliable application in dotnet what we need is the ability to define supervision trees!</p>
<p>In Erlang, typically the application will spin up a top level supervision tree - which is effectively a list of ids, and then modules/args to invoke for those ids in order to get a process. If one of these processes crash then depending on how that supervision tree is configured, either the whole tree will be restarted, or just the child that crashed (and then repeated crashes might then cause the supervisor itself to restart). Some of these children can themselves be supervisors and thus with a little careful reasoning about how your application needs to interact, a tree can be built that maximises robustness whilst minimising any potential downtime.</p>
<p>In dotnet... Well we can just do all of this in a single file - here is a supervision tree from one of the tests written in the Erlang.NET project itself.</p>
<pre><code class="language-csharp">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleSupApp</span> : <span class="hljs-title">IApp</span>
    {
      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> Supervisor.StartLink(<span class="hljs-string">&quot;primary-sup&quot;</span>, 
                  () =&gt; <span class="hljs-keyword">new</span> SupervisorConfig(
                    SupervisionStrategy.OneForAll,
                    <span class="hljs-keyword">new</span> SupervisorChild [] { 
                       <span class="hljs-keyword">new</span> SupervisorWorker(<span class="hljs-string">&quot;c1&quot;</span>, () =&gt; GenServer.StartLink(<span class="hljs-string">&quot;genserver-one&quot;</span>, () =&gt; <span class="hljs-keyword">new</span> WorkerGenServer1()))
                     , <span class="hljs-keyword">new</span> SupervisorWorker(<span class="hljs-string">&quot;c2&quot;</span>, () =&gt; GenServer.StartLink(<span class="hljs-string">&quot;genserver-two&quot;</span>, () =&gt; <span class="hljs-keyword">new</span> WorkerGenServer1()))
                     , <span class="hljs-keyword">new</span> SupervisorWorker(<span class="hljs-string">&quot;c3&quot;</span>, () =&gt; GenServer.StartLink(<span class="hljs-string">&quot;genserver-three&quot;</span>, () =&gt; <span class="hljs-keyword">new</span> WorkerGenServer1()))
                     , <span class="hljs-keyword">new</span> Supervisor(<span class="hljs-string">&quot;s1&quot;</span>, () =&gt; 
                         Supervisor.StartLink(<span class="hljs-string">&quot;secondary-sup&quot;</span>, 
                         () =&gt; <span class="hljs-keyword">new</span> SupervisorConfig(SupervisionStrategy.OneForOne, 
                           <span class="hljs-keyword">new</span> [] { <span class="hljs-keyword">new</span> SupervisorWorker(<span class="hljs-string">&quot;sc1&quot;</span>, () =&gt; GenServer.StartLink(<span class="hljs-string">&quot;nested-one&quot;</span>, () =&gt; <span class="hljs-keyword">new</span> WorkerGenServer1()))
                                 ,  <span class="hljs-keyword">new</span> SupervisorWorker(<span class="hljs-string">&quot;sc2&quot;</span>, () =&gt; GenServer.StartLink(<span class="hljs-string">&quot;nested-two&quot;</span>, () =&gt; <span class="hljs-keyword">new</span> WorkerGenServer1()))
                                 ,  <span class="hljs-keyword">new</span> SupervisorWorker(<span class="hljs-string">&quot;sc3&quot;</span>, () =&gt; GenServer.StartLink(<span class="hljs-string">&quot;nested-three&quot;</span>, () =&gt; <span class="hljs-keyword">new</span> WorkerGenServer1()))
                                 })))
                     }));
      }
    }</code></pre>
<p>The resultant tree is along the lines of:</p>
<ul>
<li>PrimarySup<ul>
<li>c1 : WorkerGenServer1 (called genserver-one)</li>
<li>c2 : WorkerGenServer1 (called genserver-two)</li>
<li>c3 : WorkerGenServer1 (called genserver-three)</li>
<li>s1 : Supervisor (called secondary-sup)<ul>
<li>sc1 : WorkerGenServer1 (called nested-one)</li>
<li>sc2 : WorkerGenServer1 (called nested-two)</li>
<li>sc3 : WorkerGenServer1 (called nested-three)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>And then we have the following behaviours</p>
<ul>
<li>Invoking <em>sys:terminate(Pid, &#39;arse&#39;)</em> on c1,c2,c3 or even s1 will result in every single process in the tree being restarted</li>
<li>Invoking <em>sys:terminate(Pid, &#39;arse&#39;)</em> on sc1, sc2, sc3 will only result in that single process being restarted</li>
</ul>
<p>By restarted, we mean that callback above (the stubby lambda ()=&gt;) being invoked once again. Args can be captured and passed in here if required, it&#39;s just closures all the way down.</p>
<p><em>Conclusion</em> </p>
<p>Now while all the examples in this blog entry are written in C# (as that appears to be the prevailing language in that ecosystem for the moment, yes I know there are F# developers too <em>waves at all five of them</em>), all of this results in our original aim which was to write our gen servers in Visual Basic .NET.</p>
<pre><code class="language-vb">    <span class="hljs-keyword">Public</span> <span class="hljs-keyword">Class</span> MyGenServerVB
        <span class="hljs-keyword">Inherits</span> IHandleInfo(<span class="hljs-keyword">Of</span> Msg)
        <span class="hljs-keyword">Public</span> <span class="hljs-keyword">Sub</span> <span class="hljs-built_in">New</span>()
        <span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span>
        <span class="hljs-keyword">Public</span> <span class="hljs-keyword">Function</span> HandleInfo(<span class="hljs-keyword">ByVal</span> ctx <span class="hljs-keyword">As</span> HandleInfoContext, <span class="hljs-keyword">ByVal</span> msg <span class="hljs-keyword">As</span> Msg) <span class="hljs-keyword">As</span> HandleInfoResult
          <span class="hljs-keyword">If</span> msg.Item1 = <span class="hljs-string">&quot;hello bob&quot;</span> <span class="hljs-keyword">Then</span>
            Erlang.Send(msg.Item2, <span class="hljs-string">&quot;hello joe&quot;</span>)
          <span class="hljs-keyword">Else</span>
            Erlang.Send(msg.Item2, <span class="hljs-string">&quot;weeee&quot;</span>)
          <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
          <span class="hljs-keyword">Return</span> ctx.NoReply()
        <span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span>
    <span class="hljs-keyword">End</span> <span class="hljs-keyword">Class</span></code></pre>
<p>That&#39;s all it took, I&#39;ll be following this blog entry up with how any of this works at all - so subscribe to the RSS (lol) if you want to read that, that&#39;ll be all the technical stuff that you don&#39;t know you needed to know in order to appreciate the &#39;it just works&#39; nature of this integration if that&#39;s all you wanted.</p>
<p>Take a look over at the Github for the actual <a href="https://github.com/robashton/erlang.net/wiki/Getting-Started">Getting Started</a> notes, there will no doubt be tweaks required but it should be enough for us to make some progress at least.</p>
<p>Also no guarantees it works on Windows, pull requests are open.</p>
]]></description><link>http://codeofrob.com/entries/write-your-erlang-gen-servers-in-visual-basic.html</link><guid isPermaLink="true">http://codeofrob.com/entries/write-your-erlang-gen-servers-in-visual-basic.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 01 Apr 2021 09:30:00 GMT</pubDate></item><item><title><![CDATA[Integrating C# with Legacy Elixir Projects]]></title><description><![CDATA[<p>Hot on the heels of my last post about <a href="/entries/write-your-erlang-gen-servers-in-visual-basic.html">integrating Dotnet with Erlang</a>, I was asked by a friend &quot;Hey that looks really cool, we&#39;re stuck with Elixir at work currently - is there a migration path for us?</p>
<p>Well I&#39;m glad you asked, <a href="https://github.com/robashton/erlang.net">Erlang.NET</a> does indeed work with Elixir and to prove it, I&#39;ve <a href="https://github.com/robashton/elixir.net">built a skeleton application</a> over on Github.</p>
<h1 id="what-does-it-look-like">What does it look like?</h1>
<p>Well, first of all let me say that I&#39;ve never worked with Elixir before, I don&#39;t generally like to get my hands dirty with legacy techologies, and I was never a huge fan of Ruby, so the idea of writing my Erlang with Ruby syntax never appealed either, but for science...</p>
<p>Let&#39;s say I&#39;ve got an application in Elixir</p>
<pre><code class="language-elixir">    { ok, result } = add_these_numbers(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)
    IO.puts <span class="hljs-string">&quot;What a result: <span class="hljs-subst">#{result}</span>&quot;</span></code></pre>
<p>And I&#39;m not satisfied with the way in which Elixirs adds these numbers together, but I do have some C# that does this much better?</p>
<p>Well, first off we add the Erlang.NET dependency to our mix.exs</p>
<pre><code class="language-elixir">  <span class="hljs-function"><span class="hljs-keyword">defp</span> <span class="hljs-title">deps</span></span> <span class="hljs-keyword">do</span>
    [
      {<span class="hljs-symbol">:dotnet</span>, <span class="hljs-symbol">git:</span> <span class="hljs-string">&quot;https://github.com/robashton/erlang.net.git&quot;</span>, <span class="hljs-symbol">branch:</span> <span class="hljs-string">&quot;master&quot;</span>}
    ]</code></pre>
<p>And make sure that the dotnet application is going to start along with our own</p>
<pre><code class="language-elixir">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">application</span></span> <span class="hljs-keyword">do</span>
      [
        <span class="hljs-symbol">extra_applications:</span> [<span class="hljs-symbol">:logger</span>, <span class="hljs-symbol">:dotnet</span>],
        <span class="hljs-symbol">mod:</span> {Eg, []},
      ]
  <span class="hljs-keyword">end</span></code></pre>
<p>Rather than use Nuget and get Yet Another Package Manager on my machine, I chose to use Mix for this project to get my dependencies and just write some MSBuild because it&#39;s a really powerful way of defining builds in Dotnet and can do pretty much anything we ask of it. I created a dotnet project in the &#39;cs&#39; directory of my Alixer project that looks like this.</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Project</span> <span class="hljs-attr">Sdk</span>=<span class="hljs-string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">TargetFramework</span>&gt;</span>net5.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFramework</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">EnableDynamicLoading</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">EnableDynamicLoading</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CopyLocalLockFileAssemblies</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">CopyLocalLockFileAssemblies</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ProjectReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;../deps/dotnet/cslib/Erlang.csproj&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">&quot;../deps/dotnet/priv/liberldotnet.so&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">CopyToOutputDirectory</span>&gt;</span>PreserveNewest<span class="hljs-tag">&lt;/<span class="hljs-name">CopyToOutputDirectory</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">Project</span>&gt;</span></code></pre>
<p>This means I need to configure the Erlang dotnet application to use the assemblies from the built location, no worries</p>
<pre><code class="language-elixir"><span class="hljs-keyword">import</span> Config

config <span class="hljs-symbol">:dotnet</span>,
  <span class="hljs-symbol">runtime_config:</span> to_charlist(<span class="hljs-string">&quot;cs/bin/Debug/net5.0/Eg.runtimeconfig.json&quot;</span>),
  <span class="hljs-symbol">runtime_dll:</span> to_charlist(<span class="hljs-string">&quot;cs/bin/Debug/net5.0/Erlang.dll&quot;</span>)</code></pre>
<p>Whew, Elixering sure is <em>hard work</em> I can see why you&#39;d want to move away from it! Almost there though.</p>
<p>Anyway, this means I can use my far better function in dotnet by writing a class</p>
<pre><code class="language-csharp">    public class App : IApp&lt;Tuple&lt;int, int&gt;&gt;
    {
      public Object Start(Tuple&lt;int, int&gt; t) {
        return t.Item1 + t.Item2;
      }
    }</code></pre>
<p>And call this from Elixir like so</p>
<pre><code class="language-elixir">    { <span class="hljs-symbol">:ok</span>, result } = <span class="hljs-symbol">:dotnet</span>.run_app_from_assembly(to_charlist(<span class="hljs-string">&quot;cs/bin/Debug/net5.0/Eg.dll&quot;</span>), to_charlist(<span class="hljs-string">&quot;Eg.App&quot;</span>), { <span class="hljs-number">5</span>, <span class="hljs-number">3</span> })
    IO.puts <span class="hljs-string">&quot;What a result: <span class="hljs-subst">#{result}</span>&quot;</span></code></pre>
<p>Far better than the original, although for some reason Elixir likes to use byte arrays for its strings when dotnet wants char lists so we have to do some conversion to get from the legacy elixir.</p>
<p>This of course allows us to then use gen servers written in dotnet, and over time we can move away from alikser altogether.</p>
<pre><code class="language-elixir"> <span class="hljs-symbol">:dotnet</span>.run_app_from_assembly(to_charlist(<span class="hljs-string">&quot;cs/bin/Debug/net5.0/Eg.dll&quot;</span>), to_charlist(<span class="hljs-string">&quot;Eg.Gen&quot;</span>), %{ <span class="hljs-symbol">:foo</span> =&gt; <span class="hljs-number">1</span>, <span class="hljs-symbol">:bar</span> =&gt; <span class="hljs-number">2</span> })</code></pre>
<pre><code class="language-csharp">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">GenArgs</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Foo { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Bar { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGen</span> : <span class="hljs-title">IHandleCall</span>&lt;<span class="hljs-title">Atom</span>&gt; { 
      GenArgs args;

      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyGen</span>(<span class="hljs-params">GenArgs args</span>)</span> {
        <span class="hljs-keyword">this</span>.args = args;
      }

      <span class="hljs-function"><span class="hljs-keyword">public</span> HandleCallResult <span class="hljs-title">HandleCall</span>(<span class="hljs-params">HandleCallContext ctx, Atom picker</span>)</span> {
        <span class="hljs-keyword">switch</span>(picker) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;foo&quot;</span>: 
            <span class="hljs-keyword">return</span> ctx.Reply(<span class="hljs-keyword">this</span>.args.Foo);
          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bar&quot;</span>: 
            <span class="hljs-keyword">return</span> ctx.Reply(<span class="hljs-keyword">this</span>.args.Bar);
          <span class="hljs-literal">default</span>:
            <span class="hljs-keyword">return</span> ctx.Reply(<span class="hljs-keyword">new</span> Atom(<span class="hljs-string">&quot;nope&quot;</span>));
        }
      }
    }


    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Gen</span> : <span class="hljs-title">IApp</span>&lt;<span class="hljs-title">GenArgs</span>&gt;
    {
      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">Start</span>(<span class="hljs-params">GenArgs args</span>)</span> {
        <span class="hljs-keyword">return</span> GenServer.StartLink(() =&gt; <span class="hljs-keyword">new</span> MyGen(args));
      }
    }</code></pre>
<p>I hope this answers the question and helps with people struggling to move away from their legacy elixir projects, always happy to help.</p>
]]></description><link>http://codeofrob.com/entries/integrating-c-with-legacy-elixir-projects.html</link><guid isPermaLink="true">http://codeofrob.com/entries/integrating-c-with-legacy-elixir-projects.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 01 Apr 2021 09:30:00 GMT</pubDate></item><item><title><![CDATA[Encoding h264 with Nvidia]]></title><description><![CDATA[<p>This blog entry is part of my &quot;<a href="/entries/blogging-the-mundane.html">blog about mundane stuff</a>&quot; series.</p>
<p>I covered my <a href="/entries/decoding-h264-with-nvidia.html">decoding</a> test before having a look at <a href="/entries/cuda-context-management-with-nvenc.html">context management</a>, so now it&#39;s time to look at re-encoding the h264 and demonstrating a round trip through the nvidia hardware.</p>
<h1 id="what-we-have-already">What we have already</h1>
<p>We had this workflow for testing</p>
<pre><code>
  #workflow {
    generator = #read_from_ts { name = source, filename  = &lt;&lt;<span class="hljs-string">&quot;foo.ts&quot;</span>&gt;&gt; },
    processors = [
      #nvidia_decoder { name = decode, <span class="hljs-keyword">from</span> = { source, ?video_frames_with_stream_id(<span class="hljs-number">256</span>) } },
      #x264_encoder { name = encode, <span class="hljs-keyword">from</span> = decode },
      #ts_writer { name = write, <span class="hljs-keyword">from</span> = encode, filename  = &lt;&lt;<span class="hljs-string">&quot;out.ts&quot;</span>&gt;&gt; }
    ]
  }

</code></pre><p>and what I want is</p>
<pre><code>  #workflow {
    generator = #read_from_ts { name = source, filename  = &lt;&lt;<span class="hljs-string">&quot;foo.ts&quot;</span>&gt;&gt; },
    processors = [
      #nvidia_decoder { name = decode, <span class="hljs-keyword">from</span> = { source, ?video_frames_with_stream_id(<span class="hljs-number">256</span>) } },
      #nvidia_encoder { name = encode, <span class="hljs-keyword">from</span> = decode },
      #ts_writer { name = write, <span class="hljs-keyword">from</span> = encode, filename  = &lt;&lt;<span class="hljs-string">&quot;out.ts&quot;</span>&gt;&gt; }
    ]
  }
</code></pre><p>In the decode entry we had a series of pointers to surfaces that we&#39;d pulled out of the decoder along with the corresponding timestamps, these are in NV12 planar format and byte-aligned (and I&#39;m storing all that information alongside the pointer to that surface in a struct so now we just need to see what the API looks like to turn this surface into h264 once again...)</p>
<p>This looks something like this (It actually looks nothing like this as most of this info is stored in a linked list tied to a central pool which contains the shared information), but this is at least representative of what we have.</p>
<pre><code>
  <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">nvidia_allocated_surface</span>  {</span>
    <span class="hljs-keyword">uint8_t</span>* data;
    <span class="hljs-keyword">int</span> bpp;
    <span class="hljs-keyword">int</span> byte_width;
    <span class="hljs-keyword">int</span> byte_height;
    <span class="hljs-keyword">size_t</span> pitch;
  } nvidia_allocated_surface;
</code></pre><p>This surface is allocated <em>on the GPU</em> via CUDA, and the GPU is where we want to do our encode so hopefully we can pretty much use this data directly.</p>
<h1 id="the-api">The API</h1>
<p>The encode API looks nothing like the decode API in that it&#39;s sat in its own header file (which is again expected to be included as part of the repo, but the library we&#39;re going to be loading is <em>definitely</em>  expected to exist on the runtime as part of the driver install.</p>
<ul>
<li><em>Include/nvEncodeAPI.h</em> contains all definitions/enums/functions/etc</li>
</ul>
<p>and somewhere on the host OS installed as part of the driver package (for me, /run/opengl-driver/lib/)</p>
<ul>
<li><em>libnvidia-encode.so</em></li>
</ul>
<h1 id="creating-the-api">Creating the API</h1>
<p>The functions that we end up using are loaded as a struct of function pointers and we actually only link a single function directly from that library to get hold of that struct. As a consequence of this, every struct being passed into a function in this API tends to be versioned indepedendently, such is life.</p>
<pre><code class="language-c">
  <span class="hljs-keyword">uint32_t</span> version = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">uint32_t</span> currentVersion = (NVENCAPI_MAJOR_VERSION &lt;&lt; <span class="hljs-number">4</span>) | NVENCAPI_MINOR_VERSION;
  NV_ENCODE_API_FUNCTION_LIST nvenc = {NV_ENCODE_API_FUNCTION_LIST_VER};

  NvEncodeAPIGetMaxSupportedVersion(&amp;version);
  <span class="hljs-keyword">if</span> (currentVersion &gt; version)
  {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// or whatever</span>
  }

  NvEncodeAPICreateInstance(&amp;nvenc);

  <span class="hljs-comment">// use the functions on nvenc</span>
</code></pre>
<p>This doesn&#39;t do anything other than a <em>dlopen</em> of the library exporting the functions and copy the pointers to those functions onto the nvenc struct so they can be called. Invoke it once, cache the results somewhere and then we can get to the business of talking to the GPU.</p>
<h1 id="creating-an-encoder">Creating an encoder</h1>
<p>Unlike the decode stack, the encoder doesn&#39;t seem to be built <em>directly</em> on top of CUDA, it having the capability of instantiating on top of OpenGL/DirectX/Cuda as options (and then utilise surfaces from those systems). Because we&#39;re using the decoder (and planning on using CUDA to run upscaling algorithms and such), it makes sense to use CUDA for the encoder too.</p>
<p>Because of this, we&#39;ll want to use our already-created CUDA context and pass this into the open session call.</p>
<pre><code>
  NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS <span class="hljs-attr">encodeSessionExParams</span> = { NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER };
  encodeSessionExParams.<span class="hljs-attr">device</span> = ctx;
  encodeSessionExParams.<span class="hljs-attr">deviceType</span> = NV_ENC_DEVICE_TYPE_CUDA;
  encodeSessionExParams.<span class="hljs-attr">apiVersion</span> = NVENCAPI_VERSION;
  void* <span class="hljs-attr">encoder</span> = NULL;

  nvenc.nvEncOpenEncodeSessionEx(&amp;encodeSessionExParams, &amp;encoder);
</code></pre><p>Now, this doesn&#39;t do very much other than give us an encode session that isn&#39;t initialise - and to initialise it we need to tell it what form our desired output needs to take. It is entirely possible to spend a day or two wondering why this call gives you back &#39;NV_ENC_ERR_INVALID_PARAM&#39; if it&#39;s not set up correctly (and reading the sample code doesn&#39;t help because the configuration of the encoder happens across multiple files because of the way that the samples are written), the below seems to be the the minimum required..</p>
<p>In the Real World (tm) we have an input surface with a known width/height from the decoder, here we&#39;ll hard code it along with the frame rate (I know my source is 25fps). In the Real World a load of these args will be passed in from Erlang, not C.</p>
<pre><code class="language-c">
  NV_ENC_INITIALIZE_PARAMS initializeParams = { NV_ENC_INITIALIZE_PARAMS_VER };
  NV_ENC_CONFIG encodeConfig = { NV_ENC_CONFIG_VER };
  NV_ENC_PRESET_CONFIG presetConfig = { NV_ENC_PRESET_CONFIG_VER, { NV_ENC_CONFIG_VER } };

  initializeParams.encodeConfig = &amp;encodeConfig;

  <span class="hljs-comment">// The essentials</span>
  initializeParams-&gt;encodeGUID = NV_ENC_CODEC_H264_GUID;
  initializeParams-&gt;presetGUID = NV_ENC_PRESET_P4_GUID;

  <span class="hljs-comment">// These need to line up with the input surface dimensions</span>
  initializeParams-&gt;encodeWidth = <span class="hljs-number">576</span>;
  initializeParams-&gt;encodeHeight = <span class="hljs-number">720</span>;

  <span class="hljs-comment">// Ditto these</span>
  initializeParams-&gt;frameRateNum = <span class="hljs-number">25</span>;
  initializeParams-&gt;frameRateDen = <span class="hljs-number">1</span>;

  <span class="hljs-comment">// I seemed to need these as well</span>
  initializeParams.enablePTD = <span class="hljs-number">1</span>;
  initializeParams.encodeConfig-&gt;frameIntervalP = <span class="hljs-number">3</span>;
  initializeParams.encodeConfig-&gt;gopLength = <span class="hljs-number">50</span>;
  initializeParams.tuningInfo = NV_ENC_TUNING_INFO_HIGH_QUALITY;

</code></pre>
<p>Once this initialize params basics is set up, we can ask the encoder to populate the actual details for us based on the preset and codec specified in the &#39;essentials&#39;</p>
<pre><code class="language-c">
  nvenc.nvEncGetEncodePresetConfigEx(encode_session-&gt;encoder, initializeParams.encodeGUID, initializeParams.presetGUID, tuningInfo, &amp;presetConfig);
  <span class="hljs-built_in">memcpy</span>(initializeParams.encodeConfig, &amp;presetConfig.presetCfg, <span class="hljs-keyword">sizeof</span>(NV_ENC_CONFIG));
</code></pre>
<p>I&#39;m not entirely sure why we don&#39;t just invoke nvEncGetEncoderPresetConfigEx on the struct already contained on the initializeParams, but the samples all end up doing this and the above code is precarious enough already (honestly, the number of ways this can go wrong with a single error is infuriating!). So we stick with the samples way of doing stuff!</p>
<p>I also needed to then go and set up the IDR frequency to match our requested gop length (the samples do this too) and not doing this resulted in NV_ENC_ERR_INVALID_PARAM so..</p>
<pre><code class="language-c">
    initializeParams.encodeConfig-&gt;encodeCodecConfig.h264Config.idrPeriod = initializeParams.encodeConfig-&gt;gopLength;
</code></pre>
<p>With all of the above done correctly, a call to the init fn will return a success and if not I&#39;m really sorry you&#39;re on your own because I&#39;ve served my time already.</p>
]]></description><link>http://codeofrob.com/entries/encoding-h264-with-nvidia.html</link><guid isPermaLink="true">http://codeofrob.com/entries/encoding-h264-with-nvidia.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 19 Nov 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[CUDA Context Management with NvEnc]]></title><description><![CDATA[<p>This blog entry is part of my &quot;<a href="/entries/blogging-the-mundane.html">blog about mundane stuff</a>&quot; series.</p>
<p>In the <a href="/entries/decoding-h264-with-nvidia.html">previous blog entry</a> I touched on context management in CUDA being a set of choices with conflicting information from documentation to popular code samples and such.</p>
<h1 id="what-is-the-problem">What is the &quot;problem&quot;?</h1>
<p>Most operations with CUDA expect there to be a CUDA context bound to the current thread. All operations against that CUDA context are serialized (unless those operations are bound to a specific stream, in which case they are serialized against that stream). That&#39;s it, that&#39;s the whole goal of &quot;context&quot; in CUDA, and we have more than one way of realising this in the API].</p>
<h1 id="the-api">The API</h1>
<p>I suspect this API has been subject to a bit of churn since CUDA was first realised and this would go some way to expaining the various ways of dealing with the context, starting off with the method that the samples tend to use..</p>
<pre><code>  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span> On startup
  <span class="hljs-regexp">//</span>

  cuCtxCreate(&amp;ctx, flags, dev);

  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span> Repeat below until finished
  <span class="hljs-regexp">//</span>

  cuCtxPushCurrent(ctx);

  <span class="hljs-regexp">//</span> TODO: some operation 

  cuCtxPopCurrent(NULL);

  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span>  When finished
  <span class="hljs-regexp">//</span>

  cuCtxDestroy(ctx);

</code></pre><p>If we look at the API documentation for <a href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__CTX.html#group__CUDA__CTX_1g65dc0012348bc84810e2103a40d8e2cf">cuCtxCreate</a>, the very firist sentence we see is &quot;In most cases it is recommended to use cuDevicePrimaryCtxRetain.&quot;</p>
<p>So immediately on looking up the documentation for the API that the code samples use, we are told to use something else. Now - the way I understand this, is that you can create contexts within a section of your code and use <em>Push</em> and <em>Pop</em> when using that context, and then code being invoked whilst this context is valid can do the same and you can end up with a stack of contexts that works happily together. Some searching around this reveals that there are performance penalties or even limitations over the number of active contexts in an application at the same time (operations are serialized anyway) and what we <em>can</em> do is simply get hold of the primary context with</p>
<pre><code>  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span> On startup
  <span class="hljs-regexp">//</span>


  cuDevicePrimaryCtxRetain(&amp;ctx, dev);

  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span> Repeat below until finished
  <span class="hljs-regexp">//</span>

  cuCtxSetCurrent(&amp;ctx);

  <span class="hljs-regexp">//</span> TODO: some operation

  cuCtxSetCurrent(NULL);

  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span>  When finished
  <span class="hljs-regexp">//</span>

  cuDevicePrimaryCtxRelease(ctx);

</code></pre><p>Now some more disparate info found in the recesses of Google/Stackoverflow/Nvidia forums</p>
<ul>
<li>Originally contexts weren&#39;t bindable to multiple threads at the same time</li>
<li>Decode sessions cannot share contexts across threads by default</li>
<li>Contexts take up a chunk of ram, buffers are not sharable across contexts</li>
<li>A primary context is analogous to the device itself</li>
<li>A failure on the primary context is going to cascade  into all users of that context</li>
<li>contexts can be defined as &#39;floating&#39; if they&#39;re not bound to a thread by default</li>
<li>most operations against a context are async, and not complete until you call &#39;synchronise&#39;</li>
</ul>
<p>It turns out that the nvidia decode/encode API provides another mechanism on top of contexts - the <em>lock</em>, which actually means we can share the same context across multiple decode sessions without too much issue. These are the choices I made with the above information given the needs of our encode/decode work:</p>
<ul>
<li>We will be running multiple encode/decode <em>processes</em> that should be completely isolated, this implies that context <em>needs</em> creating per process.</li>
<li>We can share the context throughout that process so long as we use locks</li>
<li>Locks perform the same job as Push/Set/Pop, but with a mutex involved to make sure all work is serialized across threads</li>
</ul>
<pre><code>  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// On startup</span>
  <span class="hljs-comment">//</span>


  cu<span class="hljs-constructor">CtxCreate(&amp;<span class="hljs-params">ctx</span>, <span class="hljs-params">flags</span>, <span class="hljs-params">dev</span>)</span>;
  cuvid<span class="hljs-constructor">CtxLockCreate(&amp;<span class="hljs-params">lock</span>, <span class="hljs-params">ctx</span>)</span>;


  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Repeat below until finished</span>
  <span class="hljs-comment">//</span>

  cuvid<span class="hljs-constructor">CtxLock(<span class="hljs-params">lock</span>, 0)</span>;

  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> some operation</span>

  cuvid<span class="hljs-constructor">CtxUnlock(<span class="hljs-params">lock</span>, 0)</span>;

  <span class="hljs-comment">//</span>
  <span class="hljs-comment">//  When finished</span>
  <span class="hljs-comment">//</span>

  cuvid<span class="hljs-constructor">CtxLockDestroy(<span class="hljs-params">lock</span>)</span>;
  cu<span class="hljs-constructor">CtxDestroy(<span class="hljs-params">ctx</span>)</span>;

</code></pre><p>In my tests (spinning up multiple processes/tests), this seemed to be the route to getting a lowish resource usage, a good throughput and most importantly a lack of errors. If more throughput is required, then the concept of &#39;streams&#39; can be utilised against this same context for further parallelisation (that seems to be a case of creating streams per ... well... stream of work and just passing that reference around as a synchronisation point into the various API calls).</p>
<p>Because the cuvidCtxLock is a cuvid concept and not a CUDA concept, we we can pass a pointer to this lock into the decoder instantiated in the last blog entry so it will automatically use that lock when performing operations against the bound context and play nicely with our code.</p>
<p>We can replace every instance of Push and Pop in that blog entry with Lock and Unlock, and add the lock to the decoder creation params to take advantage of this</p>
<pre><code>  decode_create_info.vidLock = session-&gt;lock;
  cuvid<span class="hljs-constructor">CtxLock(<span class="hljs-params">session</span>-&gt;<span class="hljs-params">lock</span>, 0)</span>;
  cr = cuvid<span class="hljs-constructor">CreateDecoder(&amp;<span class="hljs-params">session</span>-&gt;<span class="hljs-params">decoder</span>, &amp;<span class="hljs-params">decode_create_info</span>)</span>;
  cuvid<span class="hljs-constructor">CtxUnlock(<span class="hljs-params">session</span>-&gt;<span class="hljs-params">lock</span>, 0)</span>;
</code></pre><p>I couldn&#39;t work out if we actually wanted to use Lock/Unlock around decoder creation, but it didn&#39;t hurt so in it went.</p>
<p>I <em>think</em> that this is how these APIs should be used, I give no claims to actual correctness - the documentation is vague and contradictory in places with samples/such but I have stress tested this and I&#39;ve also demonstrated the failure cases to myself (multiple threads, no locks) to hilarity so it&#39;s probably close enough to be right.</p>
<p>Note: The transform/encode side of the API doesn&#39;t provide config to use this locking mechanism and that feels a little bit like the left hand not knowing what the right hand is doing, but hey ho - use what we can, when we can.</p>
]]></description><link>http://codeofrob.com/entries/cuda-context-management-with-nvenc.html</link><guid isPermaLink="true">http://codeofrob.com/entries/cuda-context-management-with-nvenc.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 17 Nov 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Decoding h264 with Nvidia]]></title><description><![CDATA[<p>This blog entry is part of my &quot;<a href="/entries/blogging-the-mundane.html">blog about mundane stuff</a>&quot; series.</p>
<p>The scene is set and I&#39;ve <a href="/entries/exploring-the-nvidia-code-samples-and-docs.html">set my laptop up to do Nvidia work</a>,so now to look at the decode process in isolation.</p>
<p>The first task for me will be to attempt to decode one of my &#39;known good&#39; h264 sources. Now - my sources are nearly all transport streams with audio (often multiple) and such, so I&#39;ll need to parse those files, pull the streams out of them, filter the video stream from a single pid and send the h264 frame data into the API for decode. This is quite a lot of work and there is no way of testing whether the results are good short of either dumping them to disk and telling ffmpeg what it&#39;s looking at (raw frames), or piping that data into an encoder in code and writing out a fresh transport stream with the round-tripped h264.</p>
<p>I&#39;ll take that second option because I already have all the code required to do this in Erlang in our proprietary workflow engine - a simplified example of the code I&#39;ll write to test my decoder appears below. (Working inside of a mature codebase has its advantages)</p>
<pre><code class="language-erlang">
  #workflow {
    generator = #read_from_ts { name = source, filename  = &lt;&lt;<span class="hljs-string">&quot;foo.ts&quot;</span>&gt;&gt; },
    processors = [
      #nvidia_decoder { name = decode, from = { source, ?video_frames_with_stream_id(<span class="hljs-number">256</span>) } },
      #x264_encoder { name = encode, from = decode },
      #ts_writer { name = write, from = encode, filename  = &lt;&lt;<span class="hljs-string">&quot;out.ts&quot;</span>&gt;&gt; }
    ]
  }
</code></pre>
<p>Now to get to this point, the &#39;best&#39; way to achieve this is to try to mirror the underlying API as best as possible in Erlang and write as direct a NIF as possible under this. We can assume that&#39;s what I&#39;m then using in the Erlang, that allows me to write a test Erlang file and simply calls one or two of the methods with minimum config and build that up as I go. So we&#39;ll say that that&#39;s what I&#39;m doing with an <em>nvidia_test.erl</em> calling into an <em>nvidia_api.erl</em> which my <em>nvidia_decoder.erl</em> will eventually leverage.</p>
<p>We can therefore jump straight into the C and write some functions that we can assume are being called from Erlang with the appropriate arguments.</p>
<h1 id="the-api">The API</h1>
<p>The Decode API is contained in a couple of header files in the SDK tarfile</p>
<ul>
<li><em>Interface/cuviddec.h</em> all the enums and functions</li>
<li><em>Interface/nvcuvid.h</em>  some  high level helpers (includes the above)</li>
</ul>
<p>A pre-built library for this exists in</p>
<ul>
<li><em>Lib/[os]/[arch]/libnvcuvid.so</em></li>
</ul>
<p>but on my OS this library is shipped with nvidia-x11 and that&#39;s the package I am loading it from at runtime, but it is also shipped with the opengl-drivers package. Googling around this I can see confusion over whether this is supposed to be vendored or not (why would we need to have X libs installed in order to run a decode process for example).</p>
<p>I suspect that we&#39;d just vendor this in production rather than install packages we don&#39;t need.</p>
<h1 id="parsing-the-h264">Parsing the h264</h1>
<p>Each frame has a blob of &#39;data&#39;, which is essentially a sequence of NAL units, some of which are metadata describing the video content and some of which are the data itself. We can parse this ourselves in Erlang and pass just the data into the decoder, or we can just pass the whole lot into Nvidia&#39;s parser and use the callbacks provided by that parser to then feed a decoder.</p>
<p>We do actually have code lying around for parsing h264, which is why we even have the concept of a &#39;frame&#39; at all in the above code, but by far the easiest way to use the Nvidia decoder to use that parser as it then ends up providing the exact structures required <em>for</em> that decoder.</p>
<p>Creating a parser is quite easy, we populate a CUVIDPARSERPARAMS with appropriate config and init the darned thing - this is all host code for execution on the CPU and is not remotely specific to nvidia and doesn&#39;t require any hardware setup. In my code, the parser parameters are passed in from Erlang, but hard coded below. <em>decode_session</em> is a pointer to a struct containing both the parser and a pile of information also passed in by the Erlang.</p>
<pre><code class="language-c">
  CUVIDPARSERPARAMS videoParserParameters = {}
  videoParserParameters.CodecType = cudaVideoCodec_H264;
  videoParserParameters.ulMaxNumDecodeSurfaces = <span class="hljs-number">1</span>;
  videoParserParameters.ulClockRate = <span class="hljs-number">90000</span>;
  videoParserParameters.ulMaxDisplayDelay = <span class="hljs-number">0</span>;
  videoParserParameters.pUserData = decode_session;

  videoParserParameters.pfnSequenceCallback = decode_session_handle_video_sequence;
  videoParserParameters.pfnDecodePicture = decode_session_handle_picture_decode;
  videoParserParameters.pfnDisplayPicture = decode_session_handle_picture_display;


 cuvidCreateVideoParser(&amp;decode_session-&gt;parser, &amp;videoParserParameters);
</code></pre>
<p>There are three callbacks on this struct, which are very much designed to work around the decode itself. </p>
<ul>
<li><em>pfnSequenceCallback</em>: Stream information, create the decoder if you want / Stream has changed and decoder needs reconfiguring</li>
<li><em>pfnDecodePicture</em>: Here is data and information about that data, stick it into the decoder</li>
<li><em>pfnDisplayPicture</em>: You should pulling a frame out of the decoder here cos it&#39;s ready</li>
</ul>
<p>If the reader is unfamiliar with video streams, the reason we have two callbacks for decode/display is that frames in the incoming h264 stream are not necessarily in display order because you can have references to previous/future frames in encoded h264 data. It&#39;s not simply &#39;one in, one out&#39;.</p>
<p>The form of the data going in therefore is &#39;packets&#39; with timestamps which we can use for correlation coming back out again, calling the code from Erlang (but removing all the NIF mess) looks like this, simply throwing data at the parser and letting it do its job.</p>
<pre><code class="language-c">
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode_frame</span><span class="hljs-params">(decode_session* session, <span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int64_t</span> timestamp)</span>
</span>{
  CUVIDSOURCEDATAPACKET packet = { <span class="hljs-number">0</span> };
  packet.payload = data;
  packet.payload_size = size;
  packet.flags = CUVID_PKT_TIMESTAMP;
  packet.timestamp = timestamp;

  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) {
    packet.flags |= CUVID_PKT_ENDOFSTREAM;
  }

  cuCtxPushCurrent(session-&gt;ctx);
  cr = cuvidParseVideoData(session-&gt;parser, &amp;packet);
  cuCtxPopCurrent(session-&gt;ctx);

}

</code></pre>
<p>My first test effectively boiled down to calling this parser with a couple of frames with empty callbacks and printfs just to make sure that things were initialising as expected and the callbacks were being invoked.</p>
<pre><code class="language-c">
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CUDAAPI <span class="hljs-title">decode_session_handle_video_sequence</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *obj, CUVIDEOFORMAT* pVideoFormat)</span>
  </span>{
    TRACE(<span class="hljs-string">&quot;handle_video_sequence  \r\n&quot;</span>);
  }
</code></pre>
<p>Each of these callbacks present us with a <em>void\</em> obj<em>, which is the *pUserData</em> passed into the parser parameters on creation, we&#39;re using a struct here containing the parser and parameters, and it makes sense to stash the decoder in this struct too.</p>
<h1 id="initialising-the-hardware">Initialising the hardware</h1>
<p>We can&#39;t create a decoder until we&#39;ve parsed some h264, but the decoder API is built directly on top of some CUDA constructs and those constructs will need creating up front if we are to create that decoder. </p>
<p>All CUDA operations revolve around having a CUDA context created around the device we want to use for the CUDA operations, ignoring the return results (not something I&#39;m doing in the real code), a basic setup looks thus. (I&#39;ve also stripped the Erlang comms from these implementations, as messaging code and binary reference counting is outside the scope of this blog entry).</p>
<pre><code class="language-c">
 CUdevice cuDevice = <span class="hljs-number">0</span>;
 CUcontext ctx = <span class="hljs-number">0</span>;


 cuInit(<span class="hljs-number">0</span>);
 cuDeviceGet(&amp;cuDevice, <span class="hljs-number">0</span>);
 cuCtxCreate(&amp;ctx, <span class="hljs-number">0</span>, cuDevice);
</code></pre>
<p>Now, for all operations involving CUDA, this context will need binding to the current thread (except where in cases where various Nvidia APIs helpfully do this for us) and there are multiple ways of managing that context, the documentation tells us to do it one way whilst saying that another way is the default and the samples go on to do it in a whole other manner. I&#39;ll actually try and cover this in the next entry because it might save somebody some time in the future (or somebody might e-mail me to tell me I&#39;ve completely missed the point, that&#39;d be quite nice).</p>
<p>We stash this context on the struct being used in the parser above so I can then use it in calls later, but that&#39;s the extent of the setup we can do until we&#39;ve parsed some of the stream.</p>
<h1 id="creating-the-decoder">Creating the decoder</h1>
<p>In the callback for <em>pfnSequenceCallback</em>, we get told about the video format in the struct <em>CUVIDEOFORMAT</em>, and get passed our struct as a <em>void\</em> <em>, so the first thing to do here is grab that struct because it has some config on it, and then create a *CUVIDDECODECREATEINFO</em> and populate it from both the config and the information about the video given to us by the parser.</p>
<pre><code class="language-c">  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CUDAAPI <span class="hljs-title">decode_session_handle_video_sequence</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *obj, CUVIDEOFORMAT* pVideoFormat)</span> </span>{
    CUresult cr;
    decode_session *session = (decode_session *) obj;
    CUVIDDECODECREATEINFO decode_create_info = { <span class="hljs-number">0</span> };

    decode_create_info.ulWidth = pVideoFormat-&gt;coded_width;
    decode_create_info.ulHeight = pVideoFormat-&gt;coded_height;
    decode_create_info.CodecType = pVideoFormat-&gt;codec;
    decode_create_info.ChromaFormat = pVideoFormat-&gt;chroma_format;
    decode_create_info.bitDepthMinus8 = pVideoFormat-&gt;bit_depth_luma_minus8;
    decode_create_info.ulTargetWidth = pVideoFormat-&gt;coded_width;
    decode_create_info.ulTargetHeight = pVideoFormat-&gt;coded_height;
    decode_create_info.ulNumDecodeSurfaces = pVideoFormat-&gt;min_num_decode_surfaces;
    decode_create_info.ulNumOutputSurfaces = <span class="hljs-number">2</span>;
    decode_create_info.ulIntraDecodeOnly = <span class="hljs-number">0</span>;
    decode_create_info.Reserved1 = <span class="hljs-number">0</span>;
    decode_create_info.ulCreationFlags = cudaVideoCreate_PreferCUVID;

    decode_create_info.ulMaxWidth = session-&gt;max_width;
    decode_create_info.ulMaxHeight = session-&gt;max_height;
    decode_create_info.OutputFormat = session-&gt;output_format;
    decode_create_info.DeinterlaceMode = session-&gt;deinterlace_mode;
  }
</code></pre>
<p>Creating the decoder itself is just a case of binding the CUDA context to the current thread and invoking the relevant API.</p>
<pre><code class="language-c">
  cuCtxPushCurrent(session-&gt;ctx);
  cr = cuvidCreateDecoder(&amp;session-&gt;decoder, &amp;decode_create_info);
  cuCtxPopCurrent(<span class="hljs-literal">NULL</span>);
</code></pre>
<p>The callback expects a return value of *&lt; 0* if there is a failure, or  <em>min_num_decode_surfaces</em> if there is a success, so...</p>
<pre><code class="language-c">
  <span class="hljs-keyword">if</span> ( CUDA_SUCCESS == cr ) {
    <span class="hljs-keyword">return</span> pVideoFormat-&gt;min_num_decode_surfaces;
  } <span class="hljs-keyword">else</span>  {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }
</code></pre>
<p>Bit of a faff, but fairly linear at least, with these steps completed we&#39;ll start receiving parsed frame data into <em>pfnDecodePicture</em> which we can feed directly into the decoder.</p>
<pre><code class="language-c">
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CUDAAPI <span class="hljs-title">decode_session_handle_picture_decode</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* obj, CUVIDPICPARAMS* pPicParams)</span>
  </span>{
    decode_session *session = (decode_session *) obj;
    CUresult cr;

    cuCtxPushCurrent(session-&gt;ctx);
    cr = cuvidDecodePicture(session-&gt;decoder, pPicParams);
    cuCtxPopCurrent(<span class="hljs-literal">NULL</span>);

    <span class="hljs-keyword">if</span> ( CUDA_SUCCESS == cr ) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
}
</code></pre>
<p><em>pPicParams</em> contains the data as well as information about this frame (such as whether it&#39;s an iframe or not) and conveniently the parser gives the exact data that the decoder expects in order to do its job. With this, we&#39;ll start getting invocations of <em>pfnDisplayPicture</em> with raw frame data which we can send back into our application for further processing. This is actually a bit more complicated, as up until now the memory management has been taken care of us by the APIs we are using.</p>
<p>The parser is accepting our host memory buffers, and then creating buffers in host memory for its own data which are being copied into device memory by the decoder, and in order to get the data out we&#39;ll need to copy it out of these decoder managed buffers into either host or device memory.</p>
<p>Copying data out of device memory into host memory is expensive because of limited bandwidth and proximity but is necessary at <em>some</em> point if we are to output that data to anywhere useful. It is however not always desirable to immediately do this if we are then to do an encode or transform on the GPU, we probably want to create buffers on the device itself and perform a copy from the decoder-managed buffers onto our own managed buffers.</p>
<p>Our code will assume that we want the memory copied into more device memory and we&#39;ll incur another copy if we want to subsequently copy it out onto the host; this is for convenience as in the real world we&#39;ll almost certainly be doing further operations on the GPU and only moving data to the host for testing (as in the above workflow) or for very specific operations (such as some sort of fingerprinting or overlay scenario).</p>
<p>So, the first thing we need to do here is call cuvidMapVideoFrame, which will block until the frame specified by <em>picture_index</em> has been decoded and is ready for copying out. MapVideoFrame <em>effectively</em> locks that decoder-owned buffer and readies it for use in further calls (copying it into something we own). Once  we&#39;ve called Map, we check the decode status to make sure that the data is worth copying out in the first place. I&#39;ve left us a <em>...</em> as a placeholder for the next steps.</p>
<pre><code class="language-c">
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CUDAAPI <span class="hljs-title">decode_session_handle_picture_display</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* obj, CUVIDPARSERDISPINFO* pDispInfo)</span>
</span>{
  decode_session *session = (decode_session *) obj;
  CUresult cr = <span class="hljs-number">0</span>;
  CUdeviceptr srcFrame = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> srcPitch = <span class="hljs-number">0</span>;
  CUVIDGETDECODESTATUS status = {<span class="hljs-number">0</span>};

  CUVIDPROCPARAMS vpp = {<span class="hljs-number">0</span>};
  vpp.progressive_frame = pDispInfo-&gt;progressive_frame;
  vpp.second_field = pDispInfo-&gt;repeat_first_field + <span class="hljs-number">1</span>;
  vpp.top_field_first = pDispInfo-&gt;top_field_first;
  vpp.unpaired_field = pDispInfo-&gt;repeat_first_field &lt; <span class="hljs-number">0</span>;

  cuCtxPushCurrent(session-&gt;ctx);

  <span class="hljs-keyword">if</span>((cr = cuvidMapVideoFrame(session-&gt;decoder, pDispInfo-&gt;picture_index, &amp;srcFrame, &amp;srcPitch, &amp;vpp)) != CUDA_SUCCESS) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  cr = cuvidGetDecodeStatus(session-&gt;decoder, pDispInfo-&gt;picture_index, &amp;status);

  <span class="hljs-keyword">if</span> (cr == CUDA_SUCCESS &amp;&amp; (status.decodeStatus == cuvidDecodeStatus_Error || status.decodeStatus == cuvidDecodeStatus_Error_Concealed))
  {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// ... </span>

  cuCtxPopCurrent(<span class="hljs-literal">NULL</span>);

</code></pre>
<p>And now we&#39;re at the meat of it, we&#39;ve locked the decoded frame and need somewhere to put it. In the real world we operate a pool of surfaces which can be passed into Erlang and reference counted before being returned to the pool when Erlang has finished using that surface. In this example we&#39;ll just create a surface on demand and assume that somebody will destroy it (or re-use it) at some point - obviously creation is expensive so it is best not to be doing this on demand in reality.</p>
<p>We have to calculate the sizes for this surface based on the <em>CUVIDEOFORMAT</em> that we received in the pfnSequenceCallback, <em>bpp</em> will change depending on the bit depth of the source, but the only output format the decoder actually supports is NV12 so I&#39;ve hard coded byte height to (Chroma = 1 * height) + (Luma  = 0.5 * height), as those are the planes  that we&#39;ll expect in this format. If you don&#39;t know about planar formats then go and <a href="https://wiki.videolan.org/YUV">read about them</a> if you&#39;re writing this code haha, you&#39;ll need to understand it.</p>
<pre><code class="language-c">
  <span class="hljs-keyword">void</span>* dstFrame;
  <span class="hljs-keyword">int</span> dstPitch;
  <span class="hljs-keyword">int</span> bpp = pVideoFormat-&gt;bit_depth_luma_minus8 &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;
  <span class="hljs-keyword">int</span> frame_width = pVideoFormat-&gt;display_area.right - pVideoFormat-&gt;display_area.left;
  <span class="hljs-keyword">int</span> byte_width = frame_width * bpp;
  <span class="hljs-keyword">int</span> byte_height = (pVideoFormat-&gt;display_area.right - pVideoFormat-&gt;display_area.left) * <span class="hljs-number">1.5</span>;

  cuMemAllocPitch((CUdeviceptr *)&amp;dstFrame, &amp;dstPitch, frameWidth  * bpp, byte_height, <span class="hljs-number">16</span>);
</code></pre>
<p>We allocate pitched memory (also known as byte-aligned where the pitch is the stride..), essentially we want our buffer to be a be a nice round number, usually a power of 2 because  it makes for efficient read/writes. The pitch is output into &#39;dstPitch&#39; which we&#39;ll need to use later on when using this buffer because maths.</p>
<p>Assuming we have a buffer created as above, we can copy from our mapped video frame into our new device memory with</p>
<pre><code class="language-c">
  CUDA_MEMCPY2D m = { <span class="hljs-number">0</span> };
  CUresult cr;

  m.srcMemoryType = CU_MEMORYTYPE_DEVICE;
  m.srcDevice = (CUdeviceptr)srcFrame;
  m.srcPitch = srcPitch;
  m.dstMemoryType = CU_MEMORYTYPE_DEVICE;
  m.dstDevice = (CUdeviceptr)dstFrame;
  m.dstPitch = dstPitch;
  m.WidthInBytes = byte_width;
  m.Height = byte_height;

  cuMemcpy2D(&amp;m);
</code></pre>
<p>If we wanted this in host memory, we&#39;d do a straight up malloc of (byte_width * byte_height) with a pitch of byte_width, and copy it out this way</p>
<pre><code>
  CUDA_MEMCPY2D <span class="hljs-attr">m</span> = { <span class="hljs-number">0</span> };
  CUresult cr;

  m.<span class="hljs-attr">srcMemoryType</span> = CU_MEMORYTYPE_DEVICE;
  m.<span class="hljs-attr">srcDevice</span> = (CUdeviceptr)srcFrame;
  m.<span class="hljs-attr">srcPitch</span> = srcPitch;
  m.<span class="hljs-attr">dstMemoryType</span> = CU_MEMORYTYPE_HOST;
  m.<span class="hljs-attr">dstHost</span> = (CUdeviceptr)dstFrame;
  m.<span class="hljs-attr">dstPitch</span> = byte_width;
  m.<span class="hljs-attr">WidthInBytes</span> = byte_width;
  m.<span class="hljs-attr">Height</span> = byte_height;

  cuMemcpy2D(&amp;m);
</code></pre><p>That data can then be fired into libx264 along with <em>pDispInfo-&gt;timestamp</em>, encoded and viewed with pleasure. I guess the next post I should  probably talk about CUDA context management before I get to the job of encoding or transforming this data and  maybe it&#39;s worth talking a little about how I&#39;m managing reference counted surfaces between Erlang and C as well as that&#39;s a whole world of fun after this.</p>
<p>Mundane, but hopefully useful to me or somebody else in the future.</p>
]]></description><link>http://codeofrob.com/entries/decoding-h264-with-nvidia.html</link><guid isPermaLink="true">http://codeofrob.com/entries/decoding-h264-with-nvidia.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 12 Nov 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Exploring the NVIDIA code samples and docs]]></title><description><![CDATA[<p>This blog entry is part of my &quot;<a href="/entries/blogging-the-mundane.html">blog about mundane stuff</a>&quot; series.</p>
<h1 id="the-sdk">The SDK</h1>
<p>There seems to be a single tar file available for the NVEnc/Dec stuff containing the headers, sample code and some PDFs that are semi-useful for learning how all this stuff ties together, so I unpacked that locally to the project I was working in and set up paths so I could include the header files from it. </p>
<p>Step one in learning a new SDK or whatever is usually to</p>
<ul>
<li>A) RTFM</li>
<li>B) Look at the samples</li>
<li>C) Look at how others do it</li>
</ul>
<p>For <em>A</em> we have some PDFs lying about with 101 instructions on how to tie stuff together (not sufficient by itself), in theory there are some full SDK references available (found via Google for older versions but not for latest, must only be for the the upper class developers signed into some portal or another that I don&#39;t have access to - or I&#39;m terrible at Google), and we have the various header files with reasonably well documented functions lying about.</p>
<p>They do provide some good &#39;you will need to do these things in order to get a context with which to do...&#39;, but they&#39;re best read alongside the sample code to get some understanding of why it does what it does.</p>
<p>For <em>B</em> there is a full suite of samples, doing anything we pretty much might want to do with the SDK - but sadly (as is unfortunately common with SDKs such as this) rather than write samples directly against the APIs as would be convenient for the learner, they&#39;ve built a whole abstraction in C++ and then used <em>that</em> for all the samples because it&#39;s  convenient for the author - that&#39;s <em>obviously</em> easier to learn from than just some sample code that does the bare minimum in a linear fashion - <em>rolleyes</em>.</p>
<p>For <em>C</em> we look towards <a href="https://github.com/FFmpeg/FFmpeg/">ffmpeg</a>, (<a href="https://github.com/FFmpeg/FFmpeg/blob/master/libavcodec/nvenc.c">nvenc</a>/<a href="https://github.com/FFmpeg/FFmpeg/blob/master/libavcodec/nvdec.c">nvdec</a>) because that <em>works</em> but acknowledge that usually when they implement various pipelines/codecs that they&#39;re often not done in the most efficient manner because it&#39;s a big pluggable abstract system and that&#39;s not the stated goal or necessarily even compatible with their architecture.</p>
<p>Irregardless of the quality of the samples (That&#39;s a real word as of 2020, sorry I don&#39;t make the rules), they are where I found the most value for learning how the NV stuff works, even if it meant tracing through step by step and pulling the relevant function calls and the order they&#39;re invoked in into my own test code.</p>
<p>From any perspective, it&#39;s pretty obvious from looking at the header files/pdfs that encode and decode are very much their own things done in their own way with their own enums and own flags and own API design, it makes sense from a hardware perspective that these are dedicated processes but that it bubbles up to the API itself so dramatically is amusing - I imagine this is the result of separate teams working largely in isolation and <a href="https://en.wikipedia.org/wiki/Conway%27s_law">Conway&#39;s Law</a> holding steady...</p>
<h1 id="building-the-samples">Building the samples</h1>
<p>This was a bit of a dance for me, having the wrong versions of GCC about for the purposes of building the rest of our stack initially, but essentially I found out where the right versions of GCC had ended up from my shell.nix and manually told cmake about them..</p>
<pre><code>
mkdir build &amp;&amp; cd build

cmake -DCMAKE_LIBRARY_PATH=/run/opengl-driver/lib/ -DCMAKE_C_COMPILER=/nix/store/l2abq8hpgdjc4x7dwdps7zqcnxmjmjp4-gcc-<span class="hljs-keyword">wrapper</span><span class="hljs-number">-8.3</span><span class="hljs-number">.0</span>/bin/gcc -DCMAKE_CXX_COMPILER=/nix/store/l2abq8hpgdjc4x7dwdps7zqcnxmjmjp4-gcc-<span class="hljs-keyword">wrapper</span><span class="hljs-number">-8.3</span><span class="hljs-number">.0</span>/bin/g++ ..
make
make install
</code></pre><p>Not ideal but hey ho, this gave me a pile of binaries in my &#39;build&#39; directory which I can invoke to find out what my hardware is capable of (in the case of decode)</p>
<pre><code>~/nvidia/Samples/build]$ ./AppDec -h

Options:
-i             Input file path
-o             Output file path
-outplanar     Convert output to planar format
-gpu           Ordinal of GPU to use
-crop l,t,r,b  Crop rectangle in left,top,right,bottom (ignored for case 0)
-resize WxH    Resize to dimension W times H (ignored for case 0)

Decoder Capability

GPU in use: GeForce GTX 1050
Codec  JPEG   BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 32768 </span> MaxHeight <span class="hljs-number"> 16384 </span> MaxMBCount <span class="hljs-number"> 67108864 </span> MinWidth <span class="hljs-number"> 64 </span>  MinHeight <span class="hljs-number"> 64 </span>  SurfaceFormat  NV12
Codec  MPEG1  BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 4080 </span>  MaxHeight <span class="hljs-number"> 4080 </span>  MaxMBCount <span class="hljs-number"> 65280 </span>    MinWidth <span class="hljs-number"> 48 </span>  MinHeight <span class="hljs-number"> 16 </span>  SurfaceFormat  NV12
Codec  MPEG2  BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 4080 </span>  MaxHeight <span class="hljs-number"> 4080 </span>  MaxMBCount <span class="hljs-number"> 65280 </span>    MinWidth <span class="hljs-number"> 48 </span>  MinHeight <span class="hljs-number"> 16 </span>  SurfaceFormat  NV12
Codec  MPEG4  BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 2032 </span>  MaxHeight <span class="hljs-number"> 2032 </span>  MaxMBCount <span class="hljs-number"> 8192 </span>     MinWidth <span class="hljs-number"> 48 </span>  MinHeight <span class="hljs-number"> 16 </span>  SurfaceFormat  NV12
Codec  H264   BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 4096 </span>  MaxHeight <span class="hljs-number"> 4096 </span>  MaxMBCount <span class="hljs-number"> 65536 </span>    MinWidth <span class="hljs-number"> 48 </span>  MinHeight <span class="hljs-number"> 16 </span>  SurfaceFormat  NV12
Codec  HEVC   BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 8192 </span>  MaxHeight <span class="hljs-number"> 8192 </span>  MaxMBCount <span class="hljs-number"> 262144 </span>   MinWidth <span class="hljs-number"> 144 </span> MinHeight <span class="hljs-number"> 144 </span> SurfaceFormat  NV12
Codec  HEVC   BitDepth <span class="hljs-number"> 10 </span> ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 8192 </span>  MaxHeight <span class="hljs-number"> 8192 </span>  MaxMBCount <span class="hljs-number"> 262144 </span>   MinWidth <span class="hljs-number"> 144 </span> MinHeight <span class="hljs-number"> 144 </span> SurfaceFormat  NV12 P016
Codec  HEVC   BitDepth <span class="hljs-number"> 12 </span> ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 8192 </span>  MaxHeight <span class="hljs-number"> 8192 </span>  MaxMBCount <span class="hljs-number"> 262144 </span>   MinWidth <span class="hljs-number"> 144 </span> MinHeight <span class="hljs-number"> 144 </span> SurfaceFormat  NV12 P016
Codec  HEVC   BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:4:4  Supported <span class="hljs-number"> 0 </span> MaxWidth <span class="hljs-number"> 0 </span>     MaxHeight <span class="hljs-number"> 0 </span>     MaxMBCount <span class="hljs-number"> 0 </span>        MinWidth <span class="hljs-number"> 0 </span>   MinHeight <span class="hljs-number"> 0 </span>   SurfaceFormat  N/A
Codec  HEVC   BitDepth <span class="hljs-number"> 10 </span> ChromaFormat  4:4:4  Supported <span class="hljs-number"> 0 </span> MaxWidth <span class="hljs-number"> 0 </span>     MaxHeight <span class="hljs-number"> 0 </span>     MaxMBCount <span class="hljs-number"> 0 </span>        MinWidth <span class="hljs-number"> 0 </span>   MinHeight <span class="hljs-number"> 0 </span>   SurfaceFormat  N/A
Codec  HEVC   BitDepth <span class="hljs-number"> 12 </span> ChromaFormat  4:4:4  Supported <span class="hljs-number"> 0 </span> MaxWidth <span class="hljs-number"> 0 </span>     MaxHeight <span class="hljs-number"> 0 </span>     MaxMBCount <span class="hljs-number"> 0 </span>        MinWidth <span class="hljs-number"> 0 </span>   MinHeight <span class="hljs-number"> 0 </span>   SurfaceFormat  N/A
Codec  VC1    BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 2032 </span>  MaxHeight <span class="hljs-number"> 2032 </span>  MaxMBCount <span class="hljs-number"> 8192 </span>     MinWidth <span class="hljs-number"> 48 </span>  MinHeight <span class="hljs-number"> 16 </span>  SurfaceFormat  NV12
Codec  VP8    BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 0 </span> MaxWidth <span class="hljs-number"> 0 </span>     MaxHeight <span class="hljs-number"> 0 </span>     MaxMBCount <span class="hljs-number"> 0 </span>        MinWidth <span class="hljs-number"> 0 </span>   MinHeight <span class="hljs-number"> 0 </span>   SurfaceFormat  N/A
Codec  VP9    BitDepth <span class="hljs-number"> 8 </span>  ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 8192 </span>  MaxHeight <span class="hljs-number"> 8192 </span>  MaxMBCount <span class="hljs-number"> 262144 </span>   MinWidth <span class="hljs-number"> 128 </span> MinHeight <span class="hljs-number"> 128 </span> SurfaceFormat  NV12
Codec  VP9    BitDepth <span class="hljs-number"> 10 </span> ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 8192 </span>  MaxHeight <span class="hljs-number"> 8192 </span>  MaxMBCount <span class="hljs-number"> 262144 </span>   MinWidth <span class="hljs-number"> 128 </span> MinHeight <span class="hljs-number"> 128 </span> SurfaceFormat  NV12 P016
Codec  VP9    BitDepth <span class="hljs-number"> 12 </span> ChromaFormat  4:2:0  Supported <span class="hljs-number"> 1 </span> MaxWidth <span class="hljs-number"> 8192 </span>  MaxHeight <span class="hljs-number"> 8192 </span>  MaxMBCount <span class="hljs-number"> 262144 </span>   MinWidth <span class="hljs-number"> 128 </span> MinHeight <span class="hljs-number"> 128 </span> SurfaceFormat  NV12 P016
</code></pre><p>Honestly it&#39;s kinda impressive how much my nearly three year old laptop is capable of, dedicated hardware decode of 4k HEVC? Sure thing... </p>
<h1 id="the-sample-code-then">The sample code then</h1>
<p>The sample code is essentially boils down to a pile of projects under &#39;AppEncode&#39;, &#39;AppDecode&#39;, and &#39;AppTranscode&#39; directories - in theory demonstrating in isolation how to do those tasks, I say in theory because all of the examples are effectively a main(int argc, char** arg) that parse the command line and then spin up the shared code in the NvDecoder/NvEncoder directories.</p>
<p>That&#39;s super annoying, as it means the useful code is sat inside two C++ classes plus a pile of inheritance to change the behaviour at times and if you want to work out what one of these &#39;isolated&#39; examples are actually doing you have to traipse up and down a pile of abstracted mess to work out how the API is actually being invoked. This is a masterclass in how <em>not</em> to write useful example code for an SDK in case anybody is still unclear as to how I feel about this.</p>
<p>The useful code for decoding exists in a single class, <em>NvDecoder</em>, with most of the interesting code taking place in <em>Decode</em> and <em>GetFrame</em>. There is a lot of work happening under the covers which will need looking at in a following blog post, but what is interesting here is that Nvidia provide the means not only to decode the video bitstream, but also to parse the codec around that bitstream. That&#39;s kinda cool because this isn&#39;t a small feat - it&#39;s quite common for video decoder APIs to only deal with the bitstream which makes the cost of entry quite high unless you&#39;ve already got all of that code lying about. Of course if you&#39;re already parsing the nals and such in your pipeline you can skip that aspect of the Nvidia API (this being what is recommended) but because their parser is built to work with their decoder that&#39;s clearly what I&#39;m going to start with.</p>
<p>The useful code for encoding exists in a single class, <em>NvEncoder</em>, but with various overrides in things like <em>NvEncoderCuda</em>, <em>NvEncoderD3D11</em>, etc. So that&#39;s a pain in the arse, not to mention the heap of boolean decisions around #IFDEFs, if(m_bSomeFlag) making it difficult to work out what one of the isolated examples is doing.  It is safe to say that understanding the encoding process is going to be frustrating.</p>
<h1 id="next-steps">Next steps</h1>
<p>Honestly getting this far was a faff in itself, some of it was harder because of my Nixos setup and some of it was easier (Side by side GCC installations and such are never that much fun), and my driver set up whilst easy on paper took me a few attempts to get correct because of my previous efforts in entirely disabling the GPU...</p>
<p>Having the samples building and working though, we can be confident that if I write the right code in the next steps that the rest of it will work...</p>
]]></description><link>http://codeofrob.com/entries/exploring-the-nvidia-code-samples-and-docs.html</link><guid isPermaLink="true">http://codeofrob.com/entries/exploring-the-nvidia-code-samples-and-docs.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 10 Nov 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Getting started with NVEnc]]></title><description><![CDATA[<p>This blog entry is part of my &quot;<a href="/entries/blogging-the-mundane.html">blog about mundane stuff</a>&quot; series.</p>
<p>Mundane blog posts here we go! I recently got asked about adding NVIDIA capability to our stack and that is a process I went through and completed with only moderate frustration. I don&#39;t tend to write very much C in my day to day job (This is by design, nobody wants me writing C and I don&#39;t want to be writing C) but here we are writing C because that&#39;s the easiest way to integrate native stuff with Erlang and I&#39;m not about to go and learn Rust just to play with an SDK that we may not end up using in production. I will go and learn Rust in 2021 though, Rust is where our native stuff is heading but I digress - thisis the life of a developer working in this sort of environment - putting off learning new things until it becomes strictly necessary or we&#39;d  never get any bloody work done.</p>
<p>We&#39;ll ignore the Erlang bit for the most part, because I could probably write several blog posts on my experience of writing NIFs (badly) alone, and we&#39;ll just take a quick overview of how the NVIDIA stuff fits together because coming to this task entirely from scratch with no knowledge of how the various bits fit together made set up that little bit more interesting.</p>
<h1 id="my-os">My OS</h1>
<p>I run Nixos, my entire system including drivers, software packages, configuration and such exist on Github in a <a href="https://github.com/robashton/nixos-install">repository</a> and it makes set up on new hardware or re-paving from scratch on existing hardware a very simply task of cloning a repo and running it against that hardware.</p>
<p>The hardest thing about the setup of this laptop with the Nvidia chip on it was disabling the GPU in the first place entirely so to squeeze as much battery life out of it as possible whilst sitting in bars at conferences and such and writing code until somebody wants to chat to me. (I actually paved this laptop whilst sat at a conference in Lithuania, that seems a different world now..). There is a perfectly good integrated Intel GPU (that also does hardware accelerated encodes/decodes too!) that I&#39;ve been using for the lifetime of his hardware (and we use this stuff in production so it makes sense to use it locally).</p>
<p>The first thing I needed to do was update the kernel to latest and survey what the state of Nvidia drivers/etc is in this world having not looked at it for a couple of years. The answer is &#39;in a state of flux&#39; (<em>when isn&#39;t it?</em>), but it looks like we&#39;ve finally got sensible offloading of the GPU built in and in theory we can run an X session off-screen for doing rendering and such on that GPU without draining the battery just because I was silly enough to open vim inside a terminal emulator. </p>
<p>The support for the encode/decode functionality is built into these drivers in the form of dynamically loaded libraries and they need to be set up properly before anything will work. On Windows this probably just means running an EXE, on MacOS it probably means dragging an icon onto another icon and on Nixos I need configure the drivers with the information of where to find the hardware and how I want it to operate.</p>
<p>I had been lying to ACPI to get my touchpad working with Nvidia disabled, but now comes the time to tell the truth once more..</p>
<pre><code>    <span class="hljs-attr">boot.kernelParams</span> = [ <span class="hljs-string">&quot;acpi_osi=Linux&quot;</span> ]<span class="hljs-comment">;</span></code></pre><p>Hey NVIDIA, this is where my hardware is (located using lspci)</p>
<pre><code>  <span class="hljs-attr">hardware.nvidia.prime.nvidiaBusId</span> = <span class="hljs-string">&quot;PCI:1:0:0&quot;</span><span class="hljs-comment">;</span>
  <span class="hljs-attr">hardware.nvidia.prime.intelBusId</span> = <span class="hljs-string">&quot;PCI:0:2:0&quot;</span><span class="hljs-comment">;</span></code></pre><p>And I want the official drivers pls, blacklist nouveau - don&#39;t even think about it pal.</p>
<pre><code>  <span class="hljs-attr">hardware.nvidia.modesetting.enable</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
  <span class="hljs-attr">hardware.nvidia.prime.offload.enable</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
  <span class="hljs-attr">hardware.nvidia.nvidiaPersistenced</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>

  <span class="hljs-attr">services.xserver.videoDrivers</span> = [ <span class="hljs-string">&quot;nvidia&quot;</span> ]<span class="hljs-comment">;</span>
  <span class="hljs-attr">boot.kernelModules</span> = [ <span class="hljs-string">&quot;nvidia-uvm&quot;</span> <span class="hljs-string">&quot;nvidia-drm&quot;</span> ]<span class="hljs-comment">;</span>
  <span class="hljs-attr">boot.blacklistedKernelModules</span> = [ <span class="hljs-string">&quot;nouveau&quot;</span> ]<span class="hljs-comment">;</span></code></pre><p>And also the X11 packages for this stuff</p>
<pre><code>  environment.systemPackages = with pkgs<span class="hljs-comment">; [</span>
    linuxPackages.nvidia_x11
  ]<span class="hljs-comment">;</span></code></pre><p>And may as well get the opengl stuff set up while we&#39;re here, although it&#39;s not strictly useful for the encodes it&#39;s good for testing the hardware itself.</p>
<pre><code>  hardware.<span class="hljs-attr">opengl</span> = {
    <span class="hljs-attr">enable</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-attr">driSupport</span> = <span class="hljs-literal">true</span>;
  }</code></pre><p>I also follow the official guidance in setting up a quick bash script to run things with the Nvidia GPU instead of the default Intel one.</p>
<p>Having a Nixos setup is quite nice, a quick rebuild and I have a new boot option to start up with all of this enabled (and the old option is still there in case I got anything wrong, which I definitely did in my first few passes here).</p>
<p>Anyway, this gives me a few things..</p>
<ul>
<li><em>glxgears</em>:  Woo, spinny gears on my laptop powered by Intel</li>
<li><em>nvidia-offload glxgears</em>: Woo, spinny gears powered by Nvidia</li>
<li><em>/run/opengl-driver/lib/libnvidia-encode.so</em>: Library for doing encode stuff</li>
<li><em>/run/opengl-driver/lib/dri/nvidia_drv_video.so</em>: The actual video driver</li>
</ul>
<p>Happy this is all setup, I need to look next at the tools required to write code that uses these things...</p>
<h1 id="the-project-stuff">The project stuff</h1>
<p>I don&#39;t tend to install SDKs or even development tools and such in my global environment, it nearly always ends up being the case that I need a different version of something for one project or another and because I&#39;m on Nixos I just use Nix shells for the individual projects and their development requirements <a href="https://purerl-cookbook.readthedocs.io/en/latest/devenv/nix.html">(Something I have written a bit about)</a></p>
<p>It turns out I just need to add these packages to my environment and I&#39;m good to go, I already have nvidia_x11, but I &#39;add&#39; it again here so I can use it to generate some environment variables later on in the shell.nix so everything lines up.</p>
<pre><code>
  <span class="hljs-attribute">cudatoolkit</span>
  <span class="hljs-attribute">nvidia</span>-video-sdk
  <span class="hljs-attribute">linuxPackages</span>.nvidia_x<span class="hljs-number">11</span>
</code></pre><p>As a bonus, I also go and add these because it&#39;ll make the code samples build and run properly (and as code samples typically seem to be the main entrance to SDKs like this that&#39;s a helpful thing.</p>
<pre><code><span class="hljs-code">    cmake
    pkgconfig
    gcc8
    ffmpeg-full
</span></code></pre><p>As a further bonus, I go and add <em>gdb</em> to this list because I literally don&#39;t have any development tools on my host OS and I&#39;m bound to cause a few SIGSEGVs over the next couple of weeks that need debugging.</p>
<p>The cuda toolkit doesn&#39;t (at time of writing) work with the modern version of GCC on my OS so I needed to explicitly pull GCC8 and set that in the environment so that when I&#39;m building code with our standard makefiles we&#39;ll do the right thing.</p>
<pre><code>  shellHook = <span class="hljs-string">&#x27;&#x27;</span>
    <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CUDA_PATH</span>=<span class="hljs-variable">${pkgs.cudatoolkit}</span>
    <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LD_LIBRARY_PATH</span>=<span class="hljs-variable">${pkgs.linuxPackages.nvidia_x11}</span>/lib
    <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">EXTRA_LDFLAGS</span>=<span class="hljs-string">&quot;-L/lib -L<span class="hljs-variable">${pkgs.linuxPackages.nvidia_x11}</span>/lib&quot;</span>
    <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">EXTRA_CCFLAGS</span>=<span class="hljs-string">&quot;-I/usr/include&quot;</span>
    <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CC</span>=<span class="hljs-variable">${pkgs.gcc8}</span>/bin/gcc
    <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CXX</span>=<span class="hljs-variable">${pkgs.gcc8}</span>/bin/g++
  <span class="hljs-string">&#x27;&#x27;</span>;</code></pre><p>Anyway, that&#39;s my setup - seeing as I&#39;ve made it to 1000 words already I&#39;ll leave the next post of &quot;exploring the samples, SDK surface area, documentation, etc&quot; to the next one. mundane <em>and</em> wordy, everybody&#39;s favourite.</p>
]]></description><link>http://codeofrob.com/entries/getting-started-with-nvenc.html</link><guid isPermaLink="true">http://codeofrob.com/entries/getting-started-with-nvenc.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 05 Nov 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Blogging the mundane]]></title><description><![CDATA[<p>I was having a chat with a few friends over a glass or two of whisky the other evening (over Google Hangouts or whatever it is called these days) and the subject turned to whether any of us had become lazy about our online output as time had gone on and as we were getting old. (All of us really).</p>
<p><strong>&quot;Why don&#39;t you blog any more?&quot;</strong></p>
<p>My own personal answer is quite simply that I don&#39;t think anybody actually cares about anything I do these days, a vanishingly small number of people want to hear about anything to do with Erlang, an even smaller number of people have any interest in Purescript and the intersection of those two subjects doesn&#39;t do very much to increase the number of people willing to click a link with any of this content behind it. It&#39;s somewhat disheartening to write pages upon pages of documentation that nobody is going to care about until it&#39;s gotten so stale it&#39;s now useless. (See also: <a href="https://purerl-cookbook.readthedocs.io/en/latest/">The Purerl Cookbook</a>).</p>
<p>Conversations with folk at conferences on these subjects doesn&#39;t do much to boost my interest in sharing, you can literally see people glaze over the moment you mention anything that isn&#39;t</p>
<ul>
<li>A) YAML</li>
<li>B) Kubernetes</li>
<li>C) YAML and Kubernetes</li>
</ul>
<p>Outside of that, anything I might do tends to be pretty niche, have a high ramp-up cost (for me) and be quite specific to my day to day job of moving bytes from one place to another with some sort of transform in the way making the whole process a lot slower than it could be (Yes, that&#39;s literally all of our jobs). </p>
<p>Once I have invested days learning about something new (to me) I seldom feel the inclination of trying to write about it - even if I found it a challenge to learn myself in the first place because </p>
<ul>
<li>A) Nobody cares </li>
<li>B) I doubt anything I can write on the subject will help anybody further than existing materials have helped me </li>
</ul>
<p><em>A challenge then</em></p>
<p>Ignoring all of the above, I&#39;ll try to (between now and the end of the year) blog about some of the day to day mundane things &quot;wot I have done&quot;, even if the only person it helps is me in a year&#39;s time when I open code long since untouched and can&#39;t remember how any of it works. In the absence of conferences (these online replacements don&#39;t count because they don&#39;t have beanbags to chat to people on) this will perhaps be half a replacement for that experience (In that I get to talk, but not to listen, unless somebody wants to tweet me something interesting in response).</p>
<p>Have at you - the next blog post(s) will be about NVIDIA GPU based transcoding and such cos I recently wrote a driver for our own proprietary workflows to integrate with the GPU on my laptop and the documentation wasn&#39;t great but the results were pretty nifty indeed.</p>
]]></description><link>http://codeofrob.com/entries/blogging-the-mundane.html</link><guid isPermaLink="true">http://codeofrob.com/entries/blogging-the-mundane.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 03 Nov 2020 09:30:00 GMT</pubDate></item><item><title><![CDATA[Purerl Updates - Message Routing From Legacy Code]]></title><description><![CDATA[<p>We&#39;ve covered the essential upgrades to Pinto and Stetson, so now we&#39;ll cover a quick bonus topic which is one of the concepts thrown into Pinto to help with all of this work.</p>
<h1 id="previous-purerl-posts">Previous Purerl posts</h1>
<ul>
<li><a href="/entries/introducing-pinto-and-stetson---opinionated-purescript-bindings-to-otp-and-cowboy.html">Introduction to Pinto/Stetson - Opinionated Bindings to OTP/Cowboy</a></li>
<li><a href="/entries/the-structure-of-an-end-to-end-purescript-otp-project.html">The structure of an end-to-end purescript OTP project</a></li>
<li><a href="/entries/building-on-top-of-otp-with-purescript-with-pinto.html">Building on top of OTP with Purescript with Pinto</a></li>
<li><a href="/entries/building-a-purescript-web-server-with-stetson-and-pinto.html">Building a Purescript web server with Stetson and Pinto</a></li>
<li><a href="/entries/shared-code-twixt-purescript-server-and-client.html">Shared code twixt Purescript server and client</a></li>
<li><a href="/entries/purescript-interop-with-native-erlang---interacting-with-redis.html">Purescript interop with native Erlang, interaction with Redis</a></li>
</ul>
<h1 id="updates">Updates</h1>
<ul>
<li><a href="/entries/updates-to-pinto+stetson---purerl-in-progress.html">Nix overlays for Purerl/etc</a></li>
<li><a href="/entries/purerl-updates---typed-routes-in-stetson.html">Typed routing for Stetson</a></li>
<li><a href="/entries/purerl-updates---arbitrary-messages-and-handle_info-in-gen-servers.html">Arbitrary messages and handle_info in gen_servers</a></li>
<li><a href="/entries/purerl-updates---arbitrary-messages-and-stetson-handlers.html">Arbitrary messages and Stetson handlers</a></li>
<li><a href="/entries/purerl-updates---monitors-in-stetson-and-pinto.html">Monitors for arbitrary pids from Gen servers + Stetson handlers</a></li>
<li>MessageRouting in Pinto to easily bind to legacy code that sends us messages</li>
</ul>
<h1 id="the-problem">The problem</h1>
<p>A <em>lot</em> of legacy Erlang code (ours included) will have something along the lines of </p>
<pre><code class="language-erlang">
cool_api:do_something().
</code></pre>
<p>That behind the scenes will almost immediately do a call to <em>self()</em> to get the caller pid and then probably spin up some more processes and start sending messages back to us.</p>
<pre><code class="language-erlang">
  do_something() -&gt;
    Self = self(),
    spawn_link(<span class="hljs-keyword">fun</span> Fun() -&gt;
      <span class="hljs-keyword">receive</span>
        _ -&gt;  ok
      <span class="hljs-keyword">after</span> <span class="hljs-number">1000</span> -&gt;
         Self ! hi
         Fun()
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>).
</code></pre>
<p>In this case, we&#39;ve got a native function called do_something() that captures the current pid, spins up a process which will stop if it receives anything and otherwise every second send a message back to the parent (hi).</p>
<p>If we were to write FFI for this, it&#39;d look a lot like this:</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> doSomething :: <span class="hljs-type">Effect</span> <span class="hljs-type">Pid</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> stop :: <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>

</code></pre>
<pre><code class="language-erlang">
<span class="hljs-function"><span class="hljs-title">doSomething</span><span class="hljs-params">()</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
    cool_api:do_something()
  <span class="hljs-keyword">end</span>.

<span class="hljs-function"><span class="hljs-title">stop</span><span class="hljs-params">(Pid)</span> -&gt;</span>
  <span class="hljs-keyword">fun</span>() -&gt;
    Pid ! this_will_stop_you_cos_you_received_something
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>We would immediately start receiving atoms of &#39;hi&#39; to the calling process, which unless we happen to be very specific and careful, won&#39;t know how to receive them, for example in a gen server.</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = {}</span>

<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span> <span class="hljs-type">Atom</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">Local</span> $ atom <span class="hljs-string">&quot;listener&quot;</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> =
  <span class="hljs-type">Gen</span>.buildStartLink serverName init $ <span class="hljs-type">Gen</span>.defaultStartLink { handleInfo = handleInfo }

<span class="hljs-title">init</span> :: <span class="hljs-type">Gen</span>.<span class="hljs-type">Init</span> <span class="hljs-type">State</span> <span class="hljs-type">Atom</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  <span class="hljs-type">Gen</span>.lift <span class="hljs-type">CoolApi</span>.doSomething
  pure $ {}

<span class="hljs-title">handleInfo</span> :: <span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">HandleInfo</span> <span class="hljs-type">State</span> <span class="hljs-type">Atom</span>
<span class="hljs-title">handleInfo</span> msg state = <span class="hljs-keyword">do</span>
  <span class="hljs-comment">-- got an atom, woo</span>
  <span class="hljs-comment">-- not much to do with it</span>
  pure <span class="hljs-type">CastNoReply</span> state
</code></pre>
<p>This will work, it&#39;s a gen server that knows how to receive atoms - but it&#39;s unlikely we&#39;ll want to write a gen server that only receives atoms and nothing else - as soon as we add a timer, monitor or subscribe to anything else we&#39;ll want to change our message type into an ADT so that we can dispatch over the various message types.</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">CoolApiMsg</span> <span class="hljs-type">Atom</span></span>
         | <span class="hljs-type">Tick</span>
</code></pre>
<p>So we&#39;re going to need some way to map this. </p>
<p><em>The old way</em>: We&#39;d register a mapping function with the gen server that would recognise the cool_api messages and convert them into the right type for us, this was janky AF and has been deleted in the latest Pinto</p>
<p><em>the new way</em>: Proxy process that receives the message, translates it and then sends it on to the main process</p>
<p>That proxy process is a burden to create because if we start spawning processes in Erlang, we need to make sure we monitor the parent so we terminate when it does, yada yada yada what a mess. Thankfully this is what <em>MessageRouter</em> in Pinto is for, it neatly wraps up this common pattern safely so we don&#39;t have to.</p>
<h1 id="pintomessagerouter">Pinto.MessageRouter</h1>
<p>The message router exports three functions of interest, one of which invokes a router on top of a process that will always start, and one on top of a process that might fail, the third takes a RouterRef (returned on success) and terminates the router.</p>
<pre><code class="language-haskell">
    startRouter :: <span class="hljs-keyword">forall</span> handle msg. <span class="hljs-type">Effect</span> handle -&gt; (handle -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>) -&gt; (msg -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>) -&gt;  <span class="hljs-type">Effect</span> (<span class="hljs-type">RouterRef</span> handle)

    maybeStartRouter = maybeStartRouterImpl <span class="hljs-type">RouterRef</span>

    stopRouter  :: <span class="hljs-keyword">forall</span> handle. <span class="hljs-type">RouterRef</span> handle -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>
</code></pre>
<p>We&#39;ll focus on the simple case. </p>
<ul>
<li>Given an <em>Effect handle</em> - ie something that returns some reference to whatever is created (in our case a pid)</li>
<li>Given a function that given that handle, terminates the process</li>
<li>Given a callback that takes &#39;whatever is received&#39; and &#39;does something to it&#39; (<em>Effect Unit</em>)</li>
<li>We&#39;ll get an <em>Effect</em> of <em>(RouterRef handle)</em> back (which we can hold onto in order to terminate the whole show by calling stopRouter)</li>
</ul>
<p>Wrapping our legacy API is &quot;simple&quot; now that we&#39;ve already written the FFI for it</p>
<pre><code class="language-haskell">
<span class="hljs-keyword">import</span> Pinto.MessageRouting <span class="hljs-keyword">as</span> MR

<span class="hljs-title">wrappedDoSomething</span> :: <span class="hljs-keyword">forall</span>. (<span class="hljs-type">Atom</span> -&gt; <span class="hljs-type">Effect</span> <span class="hljs-type">Unit</span>) -&gt; <span class="hljs-type">Effect</span> (<span class="hljs-type">MR</span>.<span class="hljs-type">RouterRef</span> <span class="hljs-type">Pid</span>)
<span class="hljs-title">wrappedDoSomething</span> recv = <span class="hljs-type">MR</span>.startRouter <span class="hljs-type">CoolApi</span>.doSomething <span class="hljs-type">CoolApi</span>.stop recv

</code></pre>
<p>With this, we can re-write our gen server with the message lifted into the appropriate type</p>
<pre><code class="language-haskell">
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">State</span> = {}</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Msg</span> = <span class="hljs-type">Tick</span> | <span class="hljs-type">DoSomething</span> <span class="hljs-type">Atom</span></span>

<span class="hljs-title">serverName</span> :: <span class="hljs-type">ServerName</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">serverName</span> = <span class="hljs-type">Local</span> $ atom <span class="hljs-string">&quot;listener&quot;</span>

<span class="hljs-title">startLink</span> :: <span class="hljs-type">Effect</span> <span class="hljs-type">StartLinkResult</span>
<span class="hljs-title">startLink</span> =
  <span class="hljs-type">Gen</span>.buildStartLink serverName init $ <span class="hljs-type">Gen</span>.defaultStartLink { handleInfo = handleInfo }

<span class="hljs-title">init</span> :: <span class="hljs-type">Gen</span>.<span class="hljs-type">Init</span> <span class="hljs-type">State</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">init</span> args = <span class="hljs-keyword">do</span>
  self &lt;- <span class="hljs-type">Gen</span>.self
  <span class="hljs-type">Gen</span>.lift <span class="hljs-type">Wrapper</span>.wrappedDoSomething $ send self &lt;&lt;&lt; <span class="hljs-type">DoSomething</span>
  pure $ {}

<span class="hljs-title">handleInfo</span> :: <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">State</span> -&gt; <span class="hljs-type">Gen</span>.<span class="hljs-type">HandleInfo</span> <span class="hljs-type">State</span> <span class="hljs-type">Atom</span>
<span class="hljs-title">handleInfo</span> msg state = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
    <span class="hljs-type">Tick</span> -&gt; ...
    <span class="hljs-type">DoSomething</span> msg -&gt; ...
</code></pre>
<p>It means an extra process per router, so isn&#39;t something we want to be using if we&#39;re going to be spinning up 1000s of short lived versions of it, but for that sort of thing we&#39;re in specialist territory where we&#39;d be using a look up table or dropping to plain ol&#39; Erlang. (See also <em>Pinto.Timer</em> which just uses the underlying mechanisms to send messages of the right type directly without an intermediary process.</p>
<p>The point is that wrapping up legacy code that sends us arbitrary messages has been turned into a relatively small amount of work as a result of these changes, so long as we supply a start function and a stop function and a callback that knows what to do with the messages we can transform and then send accordingly. This has been used across our codebases with great success (as well as in Pinto itself) and has enabled our gen servers and web handlers to remain clean and receive the right typed messages.</p>
]]></description><link>http://codeofrob.com/entries/purerl-updates---message-routing-from-legacy-code.html</link><guid isPermaLink="true">http://codeofrob.com/entries/purerl-updates---message-routing-from-legacy-code.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 14 Jul 2020 09:30:00 GMT</pubDate></item></channel></rss>