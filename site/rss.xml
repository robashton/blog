<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>NodeJS RSS Module</generator><lastBuildDate>Sat, 16 Feb 2013 10:28:45 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Automatically merging indexes in RavenDB for optimal performance]]></title><description><![CDATA[<p>So, we can mark indexes as idle, we can automatically do this to auto indexes, and we delete auto indexes that aren't being used enough - that paves the way for a pretty useful feature - merging automatic indexes for fun and for profit.</p>

<p>What is that you ask? Well - when we do the following series of queries</p>

<pre><code>session.Query&lt;Pony&gt;()
    .Where(pony =&gt; pony.Name == "Rainbow Dash")
    .FirstOrDefault()
</code></pre>

<p>and</p>

<pre><code>session.Query&lt;Pony&gt;()
        .Where(pony =&gt; pony.Colour == "Pink")
        .ToList()
</code></pre>

<p>We will end up with the following indexes in RavenDB</p>

<p><em>Pony/Name</em></p>

<pre><code>    from pony in ponies
      select new {
        pony.Name
      }
</code></pre>

<p><em>Pony/Colour</em></p>

<pre><code>    from pony in ponies
      select new {
        pony.Colour
      }
</code></pre>

<p>Well, in reality there is no real reason why we'd have two indexes and incur the cost of iterating over documents every time they're added more often than we need.</p>

<p>One of the things that the query optimiser already does, is look for the 'widest' index - that is the index that touches the most fields.</p>

<p>It makes sense therefore, that rather than simply look for the widest index that matches the query, we should look for the most compatible index and create a new one based off of that if it doesn't match completely.</p>

<p>Consider the above, we should end up with two indexes</p>

<pre><code>    from pony in ponies
      select new {
        pony.Name
      }
</code></pre>

<p>and</p>

<pre><code>    from pony in ponies
      select new {
        pony.Name,
        pony.Colour
      }
</code></pre>

<p>Over time, the first index won't be used (as it's not as wide as the second index), and it will wither and die because of idling and auto-removal.</p>

<p>Over time, we'll actually end up with only one index per document type (providing there aren't any reasons why a query isn't compatible with an existing index, such as different indexing or sorting options)</p>

<p>This ensures that over time when using automatically generated queries, that RavenDB keeps itself as lean as possible and using as few resources as possible (and tidy!)</p>

<p>Now that covers what I did on in first couple of days at Hibernating Rhinos, next up I'll talk about what I'm helping do with result transformations.</p>]]></description><link>http://codeofrob.com/entries/automatically-merging-indexes-in-ravendb-for-optimal-performance.html</link><guid isPermaLink="true">http://codeofrob.com/entries/automatically-merging-indexes-in-ravendb-for-optimal-performance.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 15 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Getting rid of temporary indexes in RavenDB]]></title><description><![CDATA[<p>I talked about RavenDB's new ability to promote and demote automatically created indexes <a href="/entries/auto-idling-auto-indexes-in-ravendb.html">yesterday</a>, but what are the implications of this?</p>

<p>I mentioned that the process in RavenDB for managing dynamically created indexes is as thus:</p>

<ul>
<li>Look for appropriate index to use in query</li>
<li>If found, return the most appropriate index</li>
<li>If not found, create an index that will deal with the query</li>
<li>Return that index as a Temporary</li>
<li>If that index is used enough, promote it into an Auto index</li>
<li>If that index is not used enough, delete it</li>
</ul>

<p>Well, we now have a way of marking indexes as idle and therefore not taking up needless resources, we can <em>remove temporary indexes entirely</em>.</p>

<p>That's actually a lot of code we can remove, in fact a pile of code that I wrote over two years ago, that's kinda cool, as it means entire code-path that doesn't need maintaining any more.</p>

<p>Obviously we can still remove auto indexes that were only queried once or twice, but that can take part with the algorithm that marks them as idle, and to make things even better we can add some functionality to the Studio to manage these idle indexes or delete them.</p>

<p>Now, this still isn't as awesome as it could be, but we've laid the ground work for a pretty awesome feature, I'll talk about that tomorrow.</p>]]></description><link>http://codeofrob.com/entries/getting-rid-of-temporary-indexes-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/getting-rid-of-temporary-indexes-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 14 Feb 2013 12:34:00 GMT</pubDate></item><item><title><![CDATA[Auto idling auto indexes in RavenDB]]></title><description><![CDATA[<p><a href="/entries/adding-idle-indexes-to-ravendb.html">Last entry</a> I talked about the addition of a priority flag on indexes to save resources on un-important indexes.</p>

<p>This is great news for those indexes that are created and managed manually (once Raven Studio has the UI for it anyway), but a lot of customers are using auto indexes (a feature I'm proud to say I had a hand in <a href="http://ayende.com/blog/4667/ravens-dynamic-queries">All those years ago</a>).</p>

<p>What does this therefore mean for this type of index? Well, the way RavenDB currently works for those unfamiliar with it, is if you make a query for all the ponies with rainbow in their name like so:</p>

<pre><code>session.Query&lt;Pony&gt;().Where(pony =&gt; pony.Name.Contains("Rainbow"))
</code></pre>

<p>There is a query optimiser which will try to find an appropriate index to use for this query, and if it fails it will create an index for you at the following URL:</p>

<pre><code>/Index/Temp/PonyWithName
</code></pre>

<p>Or something similar (I forget the exact conventions). After a period of time, the index will be deleted unless it is used within a certain threshold of activity.</p>

<p>On top of this, we now have idle indexes - so what does this mean? We can actually do a lot of this automatically now too, if we select the least-used indexes in the system <em>(for example, order all the auto-indexes by the last time they were queried, and if there is a big gap between the last index and the penultimate index, then demote the index automatically)</em></p>

<p>If the index is queried against after this, we can promote it again - happy days, thus the following scenarios:</p>

<ul>
<li>Manual indexes get left alone unless managed in the studio</li>
<li>Auto indexes get made idle if they're not queried very much</li>
<li>Auto indexes get promoted if they're then queried</li>
</ul>

<p>Having the database make these decisions for you keeps away any of the possible complexity of maintaining a well behaving RavenDB implementation.</p>

<p>I left off yesterday by talking about the Forced flag, the idea behind this is you can force an index to keep its current state by using the Studio and not have any of this fancy magic stuff happen  for you. I expect most people won't use it, but it's always good to give customers the ability to assert control.</p>

<p>Now, with this done - the next natural cause of action is obvious really, what would that be...? Stay tuned for my next entry to find out.</p>]]></description><link>http://codeofrob.com/entries/auto-idling-auto-indexes-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/auto-idling-auto-indexes-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 13 Feb 2013 12:34:00 GMT</pubDate></item></channel></rss>