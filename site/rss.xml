<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>NodeJS RSS Module</generator><lastBuildDate>Mon, 29 Apr 2013 05:10:22 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Pushing data into streams in the EventStore]]></title><description><![CDATA[<p>I'm <a href="/entries/playing-with-the-eventstore.html">playing with the EventStore</a> and I need to push some data into it in the form of streams.</p>

<p>What does this look like? Well I'm using NodeJS, and naturally that means using JSON and object literals:</p>

<p>So, if I have an event</p>

<pre><code>// An Event
{
  Data: {
    PonyName: "Rainbow Dash",
    TrampStamp: "Rainbow",
    Date: "January 2013"
  },
  EventType: "PonyBorn"
}
</code></pre>

<p>And I want to get this into a stream, well first I want to package it up</p>

<pre><code>// A package with the event in it
{
  CorrelationId: "something-i-know",
  ExpectedVersion: "last-version-i-knew-about",
  Events: [ ev ]
}
</code></pre>

<p>And serialise it</p>

<pre><code>var body = JSON.stringify(package)
</code></pre>

<p>I can POST it to the event store with the following code</p>

<pre><code>var req = http.request({
  host: "127.0.0.1",
  port: 2113,
  path: "/streams/ponies",
  method: "POST",
  headers: {
    "Accept": "application/json",
    "Content-Type": "application/json",
    "Content-Length": body.length
  }
}, function(res) {
  // Handle this
})

req.write(body)
req.end()
</code></pre>

<p>What do we notice about the data?</p>

<ul>
<li>We can supply a correlation id for our own convenience</li>
<li>We supply an expected version so our event can be rejected if things are not as they should be</li>
<li>We can send a collection of events to be committed all as one</li>
<li>EventType can be sent in alongside the event data</li>
</ul>

<p>And what do we notice about the request?</p>

<ul>
<li>We choose which stream to post to as part of the URL</li>
<li>We specify the content types we expect and are sending (because it can accept XML etc)</li>
</ul>

<p>What happens once I've done this?</p>

<p>Well, we'll see that I have a ponies stream</p>

<p><em>/streams</em></p>

<pre><code>{
  title: "ponies",
  uri: "http://127.0.0.1:2113/streams/ponies",
  accepts: [
    {
      type: "text/xml"
    },
    {
      type: "application/atom+xml"
    },
    {
      type: "application/json"
    },
    {
      type: "application/atom+x.json"
    }
  ]
},
</code></pre>

<p>And that if we go to this ponies stream via the URI specified we'll see</p>

<p><em>/streams/ponies</em></p>

<pre><code>[
  {
    title: "ponies #1",
    id: "http://127.0.0.1:2113/streams/ponies/1",
    updated: "2013-03-01T22:30:11.790066Z",
    author: {
      name: "EventStore"
    },
    summary: "Entry #1",
    links: [
      {
        uri: "http://127.0.0.1:2113/streams/ponies/1",
        relation: "edit"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/1?format=text",
        type: "text/plain"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/1?format=json",
        relation: "alternate",
        type: "application/json"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/1?format=xml",
        relation: "alternate",
        type: "text/xml"
      }
    ]
  },
  {
    title: "ponies #0",
    id: "http://127.0.0.1:2113/streams/ponies/0",
    updated: "2013-03-01T22:30:11.79004Z",
    author: {
      name: "EventStore"
    },
    summary: "Entry #0",
    links: [
      {
        uri: "http://127.0.0.1:2113/streams/ponies/0",
        relation: "edit"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/0?format=text",
        type: "text/plain"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/0?format=json",
        relation: "alternate",
        type: "application/json"
      },
      {
        uri: "http://127.0.0.1:2113/streams/ponies/event/0?format=xml",
        relation: "alternate",
        type: "text/xml"
      }
    ]
  }
]
</code></pre>

<p>We have two events, navigating to them we can see that one of them is for the creation of the stream</p>

<p><em>/streams/ponies/event/0?format=json</em></p>

<pre><code>{
  eventStreamId: "ponies",
  eventNumber: 0,
  eventType: "$stream-created-implicit",
  data: "",
  metadata: ""
}
</code></pre>

<p>And the other one is the event we pushed</p>

<p><em>/streams/ponies/event/1?format=json</em></p>

<pre><code>{
  eventStreamId: "ponies",
  eventNumber: 1,
  eventType: "PonyBorn",
  data: {
    PonyName: "Rainbow Dash",
    TrampStamp: "Rainbow",
    Date: "January 2013"
  },
  metadata: ""
}
</code></pre>

<p>Neato, I guess we notice a few things here then</p>

<ul>
<li>The stream doesn't contain the actual events, just links to the events</li>
<li>The stream is pageable, and contains the links to the pages (well, it's AtomPub)</li>
<li>Each event has its own unique uri, because events are immutable these can be cached by any intermdiate proxy</li>
</ul>

<p>And indeed, if we look at the header on a HTTP request for one of these events we'll see</p>

<pre><code>Cache-Control:max-age=31556926
</code></pre>

<p>That's cool, we've discovered that</p>

<ul>
<li>We can throw events into the event store with a default partitioning (the stream name specified)</li>
<li>We can get them back out again by paging through the links in that stream</li>
<li>Events are infinitely cacheable</li>
<li>Everything is AtomPub</li>
<li>Everything is easily navigable</li>
</ul>

<p>Now, if we were building a standard event sourced model we'd be able to page through these streams to build up our snapshots/viewmodels and that's all very neat and tidy and that would be the end of our story.</p>

<p>Next up however, it's more interesting to go and have a look at projections now, and see what questions we can ask of those streams in the event store itself.</p>]]></description><link>http://codeofrob.com/entries/pushing-data-into-streams-in-the-eventstore.html</link><guid isPermaLink="true">http://codeofrob.com/entries/pushing-data-into-streams-in-the-eventstore.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 26 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Playing with the EventStore]]></title><description><![CDATA[<p>I pulled the <a href="http://geteventstore.com/">EventStore</a> out a while ago to play with, with the intention of making a cool Github InfoGraph type thing, it never quite materialised thanks to the rate limits imposed by Github, and then other stuff came up (like I've got a game engine I'm working on and I want to blog about!)</p>

<p>That said, I had some downtime this week in between engagements and decided to bring it up again and blog about some of the things I did with it and some of the questions we're able to ask with the projections feature (which is hitting a point of maturity now which it didn't have before).</p>

<p>Anyway, setting up the EventStore on my Debian install sorta looked like this</p>

<ul>
<li>Do a fresh build of Mono 3.0.5 (it won't work on the 2.10 that ships out of the box)</li>
<li>git clone the event store</li>
<li>checkout the projections branch (not out yet)</li>
<li>xbuild EventStore.sln</li>
<li>Build the v8 stuff</li>
<li>Set up LD<em>LIBRARY</em>PATH so the v8 stuff can be loaded from the .NET exe</li>
</ul>

<p>Coolio, so we'll assume that this is running throughout my little experiment and that I can access it on http://127.0.0.1:2113</p>

<p>Browsing to that URL, we can see a veritable playground of shinies, the most important for me are</p>

<ul>
<li>See All Streams</li>
<li>Projections</li>
</ul>

<p>Popping into the "See all Streams", we can see a big pile of json, what's cool about this is </p>

<ul>
<li>It's a pile of links</li>
<li>The links tell us what types are accepted</li>
<li>I can request this in various types as well (see the ?format=json) in this URL</li>
</ul>

<p>Basically, it's AtomPub, and AtomPub is used across the EventStore for interactions - which means no faffing around with custom formats or any of the crap associated with a lot of proprietary systems.</p>

<p>Anwyay, I haven't currently got any info in my event store so I guess I'll look at that next...</p>]]></description><link>http://codeofrob.com/entries/playing-with-the-eventstore.html</link><guid isPermaLink="true">http://codeofrob.com/entries/playing-with-the-eventstore.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 25 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[OMeta OData ODear - polishing it off]]></title><description><![CDATA[<p>Now I've gotten most of this work done, I left a few pieces of work outstanding and after review, I can make some of the OMeta cleaner and nicer. I also need to be a bit better about interpreting the various primitives in OData.</p>

<p>I've also got a more <a href="https://github.com/Page-/">qualified person</a> to review my OMeta as I go along and give me feedback on my work, so this is where I integrate a lot of that.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
<li><a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic operator support in OData</a></li>
<li><a href="/entries/precedence-grouping,-you-first..-no-you-odata-parser.html">Precedence grouping in OData</a></li>
<li><a href="/entries/parsing-those-pesky-filtering-functions-in-odata.html">Filter query methods in OData</a></li>
<li><a href="/entries/the-final-odata-query-bits,-yes-were-nearly-there.html">The rest of OData</a></li>
</ul>

<h2>OMeta</h2>

<p><strong>Un-needed semantic actions</strong></p>

<p>In a few places in my OMeta I have expressions that look like this:</p>

<pre><code>(
  seq("allpages") -&gt; "allpages"
| seq("none") -&gt; "none"
)
</code></pre>

<p>This is quite wasteful and can be written much more simply as </p>

<pre><code>(
  seq("allpages") 
| seq("none")
)
</code></pre>

<p>This is because by default the last expression will be returned anyway</p>

<p>The same goes for this (ignoring that the Text primitive still needs some work)</p>

<pre><code>Text =
  &lt;    (   ~'\''
      (    '\\' anything
      |    letter
      )
    )*
  &gt;:text
  -&gt; text
</code></pre>

<p>Is much tidier if we get rid of the un-need semantic action because text will be returned anyway, and we can drop that named 'text' variable too.</p>

<pre><code>Text =
  &lt;    (   ~'\''
      (    '\\' anything
      |    letter
      )
    )*
  &gt;
</code></pre>

<p>And</p>

<pre><code>SelectOption =
  seq("$select=")
  (
    "*"                                 -&gt; '*' 
  | listOf(`PropertyPath, ','):properties  -&gt; { properties: properties }
  ):value -&gt; { name: "$select", value: value }
</code></pre>

<p>Is much better off without too</p>

<pre><code>SelectOption =
  seq("$select=")
  (
    "*"
  | listOf(`PropertyPath, ','):properties  -&gt; { properties: properties }
  ):value -&gt; { name: "$select", value: value }
</code></pre>

<p><strong>Stop repeating yourself!</strong></p>

<p>OMeta uses memoisation so this isn't a big deal, but repeating yourself is annoying anyway and we can be far more expressive if we think about commonly matches constructs in our code.</p>

<pre><code>(
  seq(" asc") -&gt; "asc"
| seq(" desc") -&gt; "desc"
)?:order
</code></pre>

<p>Here I'm looking for a sequence of characters with 'space' 'asc' 'space' and this would be far better written as</p>

<pre><code>spaces
(
  seq("asc")
| seq("desc")
| -&gt; 'desc'
):order
</code></pre>

<p>And to boot I've added in the default, which is 'desc' so I don't need that optional '?' anymore.</p>

<p>And how about this little one?</p>

<pre><code>listOf(`PropertyPath, ',')
</code></pre>

<p>I use that in quite a few places in the code, better split it off into its own rule</p>

<pre><code>PropertyPathList = 
  listOf(`PropertyPath, ',')
</code></pre>

<p>And use that around the place instead!</p>

<p><strong>Un-needed brackets</strong></p>

<pre><code>  PathSegment:model 
  (
    '?'
    ( listOf(`QueryOption, '&amp;'):options
    )
  )?
</code></pre>

<p>I do this in a few places, and while it causes no harm, OMeta is hard enough to read to the un-initiated without throwing brackets in all of the place</p>

<pre><code>  PathSegment:model 
  (
    '?'
    listOf(`QueryOption, '&amp;'):options
  )?
</code></pre>

<p>Not rocket science!</p>

<p><strong>Custom matching methods</strong></p>

<p>Admittedly I hacked this together in a rum-bar at 10pm, but I have this floating around in the code for dealing with <a href="/entries/parsing-those-pesky-filtering-functions-in-odata.html">filter methods</a></p>

<pre><code>SingleArgMethodCall :name =
  seq(name) 
  '(' 
  spaces 
  FilterByExpression:one 
  spaces
  ')' -&gt; { args: [ one ], method: name }
,

TwoArgMethodCall :name = 
  seq(name)
  '(' 
  spaces 
  FilterByExpression:one 
  spaces 
  ',' 
  spaces 
  FilterByExpression:two 
  spaces 
  ')' -&gt; { args: [ one, two ], method: name }
, 

ThreeArgMethodCall :name = 
  seq(name)
  '(' 
  spaces 
  FilterByExpression:one 
  spaces 
  ',' 
  spaces 
  FilterByExpression:two 
  spaces 
  ','
  spaces
  FilterByExpression:three 
  spaces 
  ')' -&gt; { args: [ one, two, three ], method: name }
, 
</code></pre>

<p>This is still better than doing the above individually for <em>every single supported method</em>, but it would be nice if we could do</p>

<pre><code>MethodCall(name, arity)
</code></pre>

<p>Instead of having three different expressions in a non-expandable manner</p>

<p>Well, first off - the beginning of this will looke lik</p>

<pre><code>MethodCall :name :arity =
  seq(name)
  '('
    numberOf(`FilterByExpression, arity):args
  ')' -&gt; { args: args, method: name }
,
</code></pre>

<p>Except there is no function called numberOf.</p>

<p>Extending our OMeta parser with custom functions is really easy though.</p>

<pre><code>ODataParser.numberOf = function(rule, count, seperator) {
  var ret = [];
  for(var i = 1; i &lt; count; i++) {
    ret.push(this._apply(rule));
    this._apply("spaces");
    this._applyWithArgs('exactly', seperator)
    this._apply("spaces");
  }
  ret.push(this._apply(rule));
  return ret;
}
</code></pre>

<p>These '_apply' methods are simply what the rules are converted into when the OMeta is transpiled into JS, and we're skipping that bit and patching our parser with the raw JS. Simples!</p>

<h2>OData, ODear</h2>

<p>Well, I skipped a few steps here certainly - especially with regard to the following rules:</p>

<pre><code>Number = &lt;digit+&gt;:d -&gt; parseInt(d, 10),
  Number = &lt;digit+&gt;:d -&gt; parseInt(d, 10),
  Text =
    &lt;    (   ~'\''
        (    '\\' anything
        |    letter
        )
      )*
    &gt;:text
  ,

  QuotedText =
    '\''
    Text:t 
    '\'' -&gt; t
  ,
Text =
  &lt;    (   ~'\''
      (    '\\' anything
      |    letter
      )
    )*
  &gt;:text
,
</code></pre>

<p>and</p>

<pre><code>ResourcePart =
  &lt;    (   letter
    |    '_'
    )+
  &gt;:resourcePart
  -&gt; resourcePart.replace(new RegExp('_', 'g'), ' ')
,

ResourceName =
  &lt;    ResourcePart
    (    '-'
      ResourcePart
    )*
  &gt;
</code></pre>

<p>These are our primitives in the OData space, everything else is built up off of them and I've been a bad person and not done them properly. (If anybody has bothered reading all the way up to here, you probably thought this at the time and maybe even commented about it)</p>

<p><strong>Text and QuotedText</strong></p>

<p>Just what <em>is</em> Text? </p>

<p><em>As part of the query string</em></p>

<pre><code>OperationParam = 
  Text:name '=' Text:value -&gt; { name: name, value: value }
</code></pre>

<p><em>And inside quotes as a string literal</em></p>

<pre><code>QuotedText =
  '\''
  Text:t 
  '\'' -&gt; t
,
</code></pre>

<p><em>What are the rules?</em></p>

<p>Well, if it's part of the query string, let's say it's the name of a parameter, it can be anything at all (except reserved characters from the Uri - these should be encoded). To solve this we need to read the <a href="http://tools.ietf.org/html/rfc3986">RFC</a></p>

<pre><code> reserved    = gen-delims / sub-delims
 gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
 sub-delims  = "!" / "$" / "&amp;" / "'" / "(" / ")"
                         / "*" / "+" / "," / ";" / "="
</code></pre>

<p>We should recognise most of these, although some of these are explicitly allowed in some uri schemes and according to this RFC that's okay. </p>

<p>Still, an implementation of this can look something like:</p>

<pre><code>ReservedUriComponent  =
  GenDelim
| SubDelim
,

GenDelim = 
  ":" | "/" | "?" | "#" | "[" | "]" | "@"
,

SubDelim = 
  "!" | '$' | '*' | "'" | "&amp;" | "(" | ")" | "+" | "," | ";" | "="
,

Text =
  &lt;
    ~ReservedUriComponent*
    anything
  &gt;
,
</code></pre>

<p>What I'll do, is explicitly deny all of these characters except in cases where I explicitly allow them (for example, the dollar symbol is allowed in built-in query params, brackets are allowed in expressions, quotes are allowed to denote string literals, etc)</p>

<p>I can use this rule safely for quoted text as that rule explicitly allows quoted text:</p>

<pre><code>QuotedText =
  '\''
  Text:t 
  '\'' -&gt; t
</code></pre>

<p><strong>Resource paths</strong></p>

<p>Same thing now goes here, and I can say that each part of a resource path is a UriComponent, explicitly disallowing spaces, separated by a '/', so</p>

<pre><code>ResourceName =
  &lt;(    
    ~(ReservedUriComponent | ' ')
    anything
  )+
  &gt;:resourceName
</code></pre>

<p>Much happier about all of this.</p>

<p><strong>Decoding as we go</strong></p>

<p>If somebody does give us some text that looks like this</p>

<pre><code>foo='hello%20world'
</code></pre>

<p>It would be nice if it was decoded for output</p>

<pre><code>Text =
  &lt;
   (~ReservedUriComponent
   anything)*
  &gt;:text -&gt; decodeURIComponent(text)
,
</code></pre>

<p>We can indeed call arbitrary JS methods in our semantic output, good for us.</p>

<p>We'll do the same for resource names too</p>

<pre><code>ResourceName =
  &lt;(    
    ~(ReservedUriComponent | ' ')
    anything
  )+
  &gt;:resourceName -&gt; decodeURIComponent(resourceName)
</code></pre>

<p>I think if I was to go and do some of this again, I'd have been explicit about Uri conformance from the start, but it hasn't caused too much damage so we're okay.</p>

<p><strong>Supporting further primitives</strong></p>

<p>At the moment we can parse integers with</p>

<pre><code>Number = &lt;digit+&gt;:d -&gt; parseInt(d, 10)
</code></pre>

<p>But this is only half the story, we actually need to explicitly support decimals too</p>

<pre><code>Number = Decimal | Integer
,

Decimal = 
  &lt;
    digit+
    '.'
    digit+
  &gt;:d     -&gt; new Number(d)
, 

Integer = &lt;digit+&gt;:d -&gt; parseInt(d, 10)
,
</code></pre>

<p><strong>Semantic output</strong></p>

<p>I'm now much happier that we have our bases covered with the types that we support, and that I'm not doing anything nefarious with OMeta, that leaves me with a final tidy-up task.</p>

<p>In some cases, we're outputting to an array that states 'this is what you have, so now you know how to interpret it', this is quite a standard way of doing things in OMeta and particularly in the expression parsing space.</p>

<p>By outputting to an array in this manner, it becomes very easy to write a further OMeta processing step to convert the output of the OMeta parsing step into another format (compilation).</p>

<p>This is useful for say, generating SQL based on the model that these chaps have defined in SBVR.</p>

<p>Let's look at a tangible example where I've gotten this weird:</p>

<pre><code>SelectOption =
  seq("$select=")
  (
    "*"                                 -&gt; '*' 
  | PropertyPathList:properties  -&gt; { properties: properties }
  ):value -&gt; { name: "$select", value: value }
,
</code></pre>

<p>In one case, our semantic action is to return a string containing a single character *, and other case I return an object literal with a list of properties in it.</p>

<p>I kinda want to go through and sort this out, but without using it in anger (say, for generating SQL), it's hard to say what a useful model will look like.</p>

<p>I've also made some mistakes in that I didn't refactor my tests as I went to eliminate duplication, so they're a bit coupled to the structure of the model.</p>

<p>I've decided that as I only have a day left at the client, that the best thing I can do at this point is raise my hands in the air and point out very publicly that:</p>

<ul>
<li>The tests are brittle <em>because</em> and this is how you'd improve them</li>
<li>The model probably isn't that easy to consume, and will need changing, which will mean the tests need changing, <em>sorry</em></li>
</ul>

<p>With this said and done, I've decided the final bit of work I can do is to run some fuzzy testing against the parser and start trying to make it <em>really</em> complete, as this is a harder problem. (and maybe I can refactor the tests as I do this, so I only leave one problem for them to sort out)</p>

<p><strong>Fuzzy testing</strong></p>

<p>So I found a great tool (or at least something that sounds like a great tool), which <a href="http://www.quut.com/abnfgen/">generates output based on an ABNF</a>, and OData conveniently has an <a href="http://www.odata.org/media/30002/OData%20ABNF.html">ABNF specified for it</a> so let's go!</p>

<p>What I'll do to get started is download and compile the abnfgen package, and run a single test case to make sure that this crazy idea is going to work, then I'll automate it and tell it to dump failed cases to a list so I can re-run them and work out why they've failed.</p>

<p><em>edit</em></p>

<p>Scratch that, the ABNF is incomplete and buggy and crap, what is the actual point, onto making something pretty instead...</p>

<p><strong>Hooking it up to the editor</strong></p>

<p>Because one of the main reasons for using OMeta (other than "it's what they use for most parsing already"), is the support for it in the editor that they use across the organisation.</p>

<p>Hooking it up was a simple matter of grabbing some code already written to run OMeta against a third party editor, and adding support to the parser for this.</p>

<p>To do this, I just have to add a method to my parser like so:</p>

<pre><code>ODataParser._enableTokens = function() {
  OMeta._enableTokens.call(this, ['Text', 'ResourceName', 'Number', 'RecognisedOption', 'FilterAndOperand', 'FilterByOperand', 'FilterRecognisedMathOperand']);
};
</code></pre>

<p>You'll notice if you're observant, that I've added a few more named types here, that's because otherwise I had no way of matching key words and therefore colouring them separately.</p>

<p>Instead of</p>

<pre><code>seq("add")
</code></pre>

<p>I now have</p>

<pre><code>FilterRecognisedMathOperand("add")
,

FilterRecognisedMathOperand :name = 
  seq(name)
</code></pre>

<p>That's about the only type of change I had to make to support the following glory:</p>

<p><img src="/img/parse_output.png" alt="Highlighted output in a text area from OData input" title="Parse output"/></p>

<p>Mission accomplished, now onto my next client...</p>]]></description><link>http://codeofrob.com/entries/ometa-odata-odear---polishing-it-off.html</link><guid isPermaLink="true">http://codeofrob.com/entries/ometa-odata-odear---polishing-it-off.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 23 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[The final OData query bits, yes we're nearly there]]></title><description><![CDATA[<p>So yes, we <strong>are</strong> nearly there, in fact we only have a few query options remaining, which I'll cover entirely here because they're all pretty miniscule.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
<li><a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic operator support in OData</a></li>
<li><a href="/entries/precedence-grouping,-you-first..-no-you-odata-parser.html">Precedence grouping in OData</a></li>
<li><a href="/entries/parsing-those-pesky-filtering-functions-in-odata.html">Filter query methods in OData</a></li>
</ul>

<p><strong>Expand</strong></p>

<p>Expand allows the expansion of a particular property path in OData, like so</p>

<p><em>Expand the path Products/Suppliers</em></p>

<pre><code>/Categories?$expand=Products/Suppliers
</code></pre>

<p><em>Expand the path Suppliers AND expand the path Products</em></p>

<pre><code>/Categories?$expand=Suppliers,Products
</code></pre>

<p>So this is quite easy, $expand expects a list of ResourcePath, separated by a comma.</p>

<p>I'll not show the tests for this, you can assume I have some though, with the appropriate data appearing on the model..</p>

<pre><code>ExpandOption = 
  seq("$expand=")
  listOf(`PropertyPath, ','):properties -&gt; { name: "$expand", value: { properties: properties }}
,
</code></pre>

<p>Doesn't take a genius to work that one out does it :)</p>

<p><strong>Format</strong></p>

<p>This one is a doozy, the docs pretty much say it accepts</p>

<ul>
<li>application/atom+xml</li>
<li>application/xml</li>
<li>application/json</li>
<li>Any other valid IANA content type</li>
</ul>

<p>So what we're saying here is that we'll parse any content type, what I'll do is just parse the general pattern to make sure it doesn't contain garbage and leave it at that.</p>

<pre><code>FormatOption = 
  seq("$format=")
  ContentType:type -&gt; { name: "$format", value: type }
,

ContentType = 
  &lt; letter+
    '/' 
    letter+
    (
      '+' letter+
    )?
  &gt;
</code></pre>

<p>There are probably more rules than that but it's easily improved later</p>

<p><strong>Select</strong></p>

<p>Select tells us what is going to be brought back from a query, this can either be a property path, a collection of property paths or an asterisk.</p>

<p>An asterisk means bring back EVERYTHING. Nothing special.</p>

<pre><code>SelectOption =
  seq("$select=")
  (
    "*"                                 -&gt; '*' 
  | listOf(`PropertyPath, ','):properties  -&gt; { properties: properties }
  ):value -&gt; { name: "$select", value: value }
,
</code></pre>

<p><strong>Highlighting a problem or three</strong></p>

<p>That's pretty much the entire spec sorted out, and we have a few tidy ups on our hand</p>

<ul>
<li>The model we're building isn't meaningful enough</li>
<li>I've done some messy OMeta, it needs tidying</li>
<li>I'm not handling primitive types properly (ResourceNames, ResourceComponents, Numbers etc)</li>
</ul>

<p>I'll sort all these out in the next entry (I imagine that there will have been some comments made about these already in the future... in the past now, I wrote all this a month ago after all) and then we'll be finished and onto something new.</p>]]></description><link>http://codeofrob.com/entries/the-final-odata-query-bits,-yes-were-nearly-there.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-final-odata-query-bits,-yes-were-nearly-there.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 22 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Parsing those pesky filtering functions in OData]]></title><description><![CDATA[<p>The final bit of our $filter feature is the ability to invoke a special function and compare the result of that to the rest of an expression.</p>

<p>Again a reminder of where we are so far:</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
<li><a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic operator support in OData</a></li>
<li><a href="/entries/precedence-grouping,-you-first..-no-you-odata-parser.html">Precedence grouping in OData</a></li>
</ul>

<p><strong>Function calls look like this</strong></p>

<pre><code>/Customers?$filter=substringof('Alfreds', CompanyName) eq true
</code></pre>

<p>In other words, they're a special piece of the expression which can take a list of expressions separated by commas</p>

<p>I could hack this and just allow any function call, or I can explicitly name them all - which I'll do because it'll help with the highlighting in the editor that'll use this parser.</p>

<p>I'll do the first one here, and then go and do the rest in a similar fashion because they're just the same thing over and over again!</p>

<p>Our test for 'substringof'</p>

<pre><code>test("/resource?$filterby=substringof('alfred', Product) eq 'cake'", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'eq'", function() {
     assert.equal(result.options.$filterby[0], "eq")
  })
  it("lhs should be a function call", function() {
     assert.equal(result.options.$filterby[1][0], "call")
  })
  it("lhs should be substringof with correct args", function() {
     assert.equal(result.options.$filterby[1][1].method, 'substringof')
     assert.equal(result.options.$filterby[1][1].args[0], 'alfred')
     assert.equal(result.options.$filterby[1][1].args[1].name, 'Product')
  })
  it("rhs should be cake", function() {
     assert.equal(result.options.$filterby[2], "cake")
  }) 
})
</code></pre>

<p>This kinda thing will do, and getting the method out is a simple  matter of adding the MethodExpression to the values possible in an expression:</p>

<pre><code>FilterByValue = 
  FilterMethodCallExpression
| FilterNegateExpression
| Number
| QuotedText
| PropertyPath
| GroupedPrecedenceExpression
,
</code></pre>

<p>Now, it is tempting to be lazy and just write a  generic method recogniser with variable lists of args, but we're building for highlighting so it would be nice to know what the recognised methods are, and what args they expect, so what I'll do is this</p>

<pre><code>FilterMethodCallExpression = 
  (
    FilterSubstringOf
  | OtherMethod
  | AnotherMethod
  ) -&gt; [ "call", methodcall ]
,
</code></pre>

<p>And write a definition for each method (tedious, but I'll automate a pile of that with VIM macros)</p>

<pre><code>FilterSubstringOf = 
  seq('substringof'):method 
  '(' 
  spaces 
  FilterByExpression:one 
  spaces 
  ',' 
  spaces 
  FilterByExpression:two 
  spaces 
  ')' -&gt; { args: [ one, two ], method: method }
</code></pre>

<p>And they'll all look like that.</p>

<p>With this done, $filter is now fully supported and I can get on with mopping up the final recognised pieces of OData. I'll try and do that all in a single post.</p>]]></description><link>http://codeofrob.com/entries/parsing-those-pesky-filtering-functions-in-odata.html</link><guid isPermaLink="true">http://codeofrob.com/entries/parsing-those-pesky-filtering-functions-in-odata.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 19 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Precedence grouping, you first.. no you (Odata parser)]]></title><description><![CDATA[<p>With expression parsing out of the way, there are just a few complications remaining, </p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
<li><a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic operator support in OData</a></li>
</ul>

<p>I'm still missing a few key parts of this $filter feature, the next one is precedence grouping.</p>

<p><strong>Do all this stuff before you do the other stuff</strong></p>

<p>I don't think this will be too hard to parse given our already built-up knowledge of how to do precedence.</p>

<p>To the test..</p>

<pre><code>test("/some/resource?$filterby=(Price div Price) mul 5 gt 10", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'gt'", function() {
     assert.equal(result.options.$filterby[0], "gt")
  })
  var lexpr = result.options.$filterby[1] 

  it("should be {expr} mul 5", function() {
    assert.equal(lexpr[0], "mul")
    assert.equal(lexpr[2], 5)
  })

  it("should be {Price div Price}", function() {
    assert.equal(lexpr[1][0], "div")
    assert.equal(lexpr[1][1].name, "Price")
    assert.equal(lexpr[1][2].name, "Price" )
  })

  it("rhr should be 10", function() {
     assert.equal(result.options.$filterby[2], 10)
  })
})
</code></pre>

<p>This is actually the same test as in our <a href="/entries/adding-arithmetic-operators-to-our-odata-parser.html">Arithmetic Operators</a> post, only we've surrounded the div expression because we want that to happen all by itself.</p>

<p>Well, Brackets actually have the <em>highest</em> precedence, so they'll need to go at the very end of our parser.</p>

<pre><code>FilterByValue = 
  FilterNegateExpression
| Number
| QuotedText
| PropertyPath
| GroupedPrecedenceExpression
,

GroupedPrecedenceExpression = 
  "(" spaces FilterByExpression:expr spaces ")" -&gt; expr

,
</code></pre>

<p>Yes, it really is that simple. This is what comes of building up the definition of a parse-target out of little building blocks and then making a sequence of them.</p>

<p>If only all programs worked like this.</p>]]></description><link>http://codeofrob.com/entries/precedence-grouping,-you-first..-no-you-odata-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/precedence-grouping,-you-first..-no-you-odata-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 18 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Adding arithmetic operators to our OData parser]]></title><description><![CDATA[<p>I'm finally reaching the point where I can parse most of the OData conventions for Uris, which is nice!</p>

<p>A re-cap of where we are so far.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">'Not' support for OData</a></li>
</ul>

<p>Wowsers, talk about an accidental blog series...</p>

<p><strong>Arithmetic operators</strong></p>

<p>What were they again?</p>

<pre><code>Add        Addition                /Products?$filter=Price add 5 gt 10
Sub        Subtraction             /Products?$filter=Price sub 5 gt 10
Mul        Multiplication          /Products?$filter=Price mul 2 gt 2000
Div        Division                /Products?$filter=Price div 2 gt 4
Mod        Modulo                  /Products?$filter=Price mod 2 eq 0
</code></pre>

<p>Ah yes,</p>

<p>Now, these are all the same, but operator precedence is important so the order in which we want to go through them is:</p>

<ul>
<li>Add/Sub</li>
<li>Mul/Div/Mod</li>
</ul>

<p>This is very similar to how we implemented And/Or although I'll write a few tests to make sure I get it right.</p>

<pre><code>test("/some/resource?$filterby=Price add 5 gt 10", "OData", function(result) {

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'gt'", function() {
     assert.equal(result.options.$filterby[0], "gt")
  })
  it("lhr should be Price add 5", function() {
     var rhs = result.options.$filterby[1] 
     assert.equal(rhs[0], "add")
     assert.equal(rhs[1].name, "Price")
     assert.equal(rhs[2], 5)
  })
  it("rhr should be 10", function() {
     assert.equal(result.options.$filterby[2], 10)
  })
})
</code></pre>

<p>This tells us that our 'add' operator has higher precedence than the comparisons (which makes sense). This'll mean we want to sneak it in somewhere after those comparisons. (Assuming in this scheme that And/Or have a higher precedence than add, and it seems to be that way)</p>

<pre><code>FilterLogicalExpression =
  FilterLogicalExpression:lhs
  FilterByOperand:op
  FilterAddExpression:rhs -&gt; [op, lhs, rhs ]
| FilterAddExpression
,

FilterAddExpression =
  FilterAddExpression:lhs
  FilterAddOperand:op
  FilterByValue:rhs -&gt; [ op, lhs, rhs ]
| FilterByValue
,
FilterAddOperand =
  spaces
  (
    seq("add")
  | seq("sub")
  ):op 
  spaces -&gt; op
,
</code></pre>

<p>Simples, we insert it in the pipeline between "LogicalExpression" and "Checking the value" (Literal values have the highest precedence because they don't require any work)</p>

<p>And because Mul/etc have a higher precedence than Add, this exactly the same</p>

<pre><code>test("/some/resource?$filterby=Price mul 5 gt 10", "OData", function(result) {

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'gt'", function() {
     assert.equal(result.options.$filterby[0], "gt")
  })
  it("lhr should be Price add 5", function() {
     var lhs = result.options.$filterby[1] 
     assert.equal(lhs[0], "mul")
     assert.equal(lhs[1].name, "Price")
     assert.equal(lhs[2], 5)
  })
  it("rhr should be 10", function() {
     assert.equal(result.options.$filterby[2], 10)
  })
})
</code></pre>

<p>Like so</p>

<pre><code>FilterAddExpression =
  FilterAddExpression:lhs
  FilterAddOperand:op
  FilterMulExpression:rhs -&gt; [ op, lhs, rhs ]
| FilterMulExpression
,

FilterMulExpression =
  FilterMulExpression:lhs
  FilterMulOperand:op
  FilterByValue:rhs -&gt; [ op, lhs, rhs ]
| FilterByValue
,
</code></pre>

<p>Now what I actually have to do is define operator precedence for mul/div etc independently. So I can't actually cheat and do</p>

<pre><code>FilterMulOperand =
  spaces
  (
    seq("mul")
  | seq("div")
  | seq("mod")
  ):op 
  spaces -&gt; op
,
</code></pre>

<p>Like I have been doing, or when I write the following test, it will fail.</p>

<pre><code>test("/some/resource?$filterby=Price div Price mul 5 gt 10", "OData", function(result) {
    console.log(JSON.stringify(result))

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'gt'", function() {
     assert.equal(result.options.$filterby[0], "gt")
  })
  var lexpr = result.options.$filterby[1] 

  it("should be Price div {expr}", function() {
    assert.equal(lexpr[0], "div")
    assert.equal(lexpr[1].name, "Price")
  })

  it("should be Price mul 5", function() {
    assert.equal(lexpr[2][0], "mul")
    assert.equal(lexpr[2][1].name, "Price")
    assert.equal(lexpr[2][2], 5)
  })

  it("rhr should be 10", function() {
     assert.equal(result.options.$filterby[2], 10)
  })
})
</code></pre>

<p>What will happen here is we'll get</p>

<pre><code>[
  'gt',
  [
    'mul',
    [
      'div', 'Price', 'Price'
    ],
    5
  ],
  10
]
</code></pre>

<p>When what we clearly want is</p>

<pre><code>[
  'gt',
  [
    'div',
    'Price',
    [
      'mul', 'Price', '5'
    ]
  ],
  10
]
</code></pre>

<p>Or if you like</p>

<pre><code>( (price / price) * 5 ) &gt; 10
</code></pre>

<p>Instead of</p>

<pre><code>( Price / (price * 5)  ) &gt; 10
</code></pre>

<p>Which is a little bit different to say the least!</p>

<p>So, explicit operation order is what we want, and here is how get it:</p>

<p><strong>One massively explicit set of operator precedences...</strong></p>

<pre><code>FilterByOption = 
  seq("$filterby=")
  FilterByExpression:expr -&gt; { name: "$filterby", value: expr }
,

FilterByExpression =
  FilterAndExpression
,
</code></pre>

<p><em>And is the least important in our hierarchy</em></p>

<pre><code>FilterAndExpression =
  FilterAndExpression:lhs
  FilterAndOperand:op
  FilterLogicalExpression:rhs -&gt; [ op, lhs, rhs ]
| FilterLogicalExpression
,
</code></pre>

<p><em>Followed by any logical expression</em></p>

<pre><code>FilterLogicalExpression =
  FilterLogicalExpression:lhs
  FilterByOperand:op
  FilterAddExpression:rhs -&gt; [op, lhs, rhs ]
| FilterAddExpression
,
</code></pre>

<p><em>Then we descend through our mathematical operators in reverse precedence order</em></p>

<pre><code>FilterSubExpression =
  FilterSubExpression:lhs
  spaces seq("sub") spaces
  FilterAddExpression:rhs -&gt; [ "sub", lhs, rhs ]
| FilterAddExpression
,

FilterAddExpression =
  FilterAddExpression:lhs
  spaces seq("add") spaces
  FilterModExpression:rhs -&gt; [ "add", lhs, rhs ]
| FilterModExpression
,

FilterModExpression =
  FilterModExpression:lhs
  spaces seq("mod") spaces
  FilterDivExpression:rhs -&gt; [ "mod", lhs, rhs ]
| FilterDivExpression
,
FilterDivExpression =
  FilterDivExpression:lhs
  spaces seq("div") spaces
  FilterMulExpression:rhs -&gt; [ "div", lhs, rhs ]
| FilterMulExpression
,

FilterMulExpression =
  FilterMulExpression:lhs
  spaces seq("mul") spaces
  FilterByValue:rhs -&gt; [ "mul", lhs, rhs ]
| FilterByValue
,

FilterByValue = 
  FilterNegateExpression
| Number
| QuotedText
| PropertyPath
,

FilterNegateExpression = 
  spaces
  seq("not")
  spaces
  (
    FilterByValue
  | '(' spaces FilterByExpression:expr spaces ')' -&gt; expr
  ):value -&gt;  [ "not", value ]
,
</code></pre>

<p>How cool is that??!!? That's pretty much the whole shebang wrapped up as far as expressing parsing goes, and now I can go trigger mad with nested and/or/sub/mul/etc - with the exception of the precedence operators which I'll add next!</p>]]></description><link>http://codeofrob.com/entries/adding-arithmetic-operators-to-our-odata-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/adding-arithmetic-operators-to-our-odata-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 17 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[These are NOT the results you are looking for - OData parser]]></title><description><![CDATA[<p>A quick re-cap of where we are so far in our OData OMeta Adventure.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
</ul>

<p>Before we get onto some more fuzzy stuff, it would be good to deal with 'not'</p>

<p>Not is an interesting case because it's not really  the same as the rest of the expressions so far</p>

<pre><code>Not  Logical negation  /Products?$filter=not endswith(Description,'milk')
</code></pre>

<p>It can't apply in situations like this however</p>

<pre><code>/Products?$filter=not Product eq 5
</code></pre>

<p>But it can probably apply in situations like this</p>

<pre><code>/Products?$filter=not Published
</code></pre>

<p>This tells us something, which is that not isn't going to be expecting an expression unless it's in braces, otherwise it's going to be looking for a value.</p>

<p>I'm not supporting methods yet, so I'll ignore that requirement for now.</p>

<pre><code>test("/some/resource?$filterby=not Published", "OData", function(result) {

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'not'", function() {
     assert.equal(result.options.$filterby[0], "not")
  })

  it("value should be 'Published'", function() {
    assert.equal(result.options.$filterby[1].name, "Published")
  })
})
</code></pre>

<p>First off, this one</p>

<pre><code>FilterByValue = 
  FilterNegateExpression
|  Number
| QuotedText
| PropertyPath
,

FilterNegateExpression = 
  spaces
  seq("not")
  spaces
  FilterByValue:value       -&gt;  [ "not", value ]
,
</code></pre>

<p>Quite simple, if we get as far as checking for a value, it means we haven't found an expression, so we'll check for "Not" - I guess this is where we'll probably stick methods later too. </p>

<p>A "NegateExpression" is simply a "not" followed by a value, we'll allow double negatives too because there is no harm in this.</p>

<p>Next up, we'll check for braces, and inside braces we'll allow further expressions (recurse recurse recurse)</p>

<pre><code>test("/some/resource?$filterby=not (Price gt 5)", "OData", function(result) {

  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'not'", function() {
     assert.equal(result.options.$filterby[0], "not")
  })
  it("Value should be Price gt 5", function() {
     var rhs = result.options.$filterby[1] 
     assert.equal(rhs[0], "gt")
     assert.equal(rhs[1].name, "Price")
     assert.equal(rhs[2], 5)
  })
})
</code></pre>

<p>Solved by</p>

<pre><code>FilterNegateExpression = 
  spaces
  seq("not")
  spaces
  (
    FilterByValue
  | '(' spaces FilterByExpression:expr spaces ')' -&gt; expr
  ):value -&gt;  [ "not", value ]
,
</code></pre>

<p>Dead easy, now it's time to get our heads stuck into Arithmetic Operators.</p>]]></description><link>http://codeofrob.com/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 16 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Recursive expression parsing in our OData filter parser]]></title><description><![CDATA[<p>A quick re-cap of where we are so far in our OData OMeta Adventure.</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
</ul>

<p><strong>CRIKEY</strong></p>

<p>Never thought I'd be writing this much about OMeta, but I've taken quite the shine to it.</p>

<p>I did basic expressions, but actually expressions can be made up of other expressions so I may as well bite that bullet and get on with it.</p>

<p>Let's look at what we might expect if we use 'and'</p>

<pre><code>test("/some/resource?$filter=Price gt 5 and Price lt 10", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'and'", function() {
     assert.equal(result.options.$filterby[0], "and")
  })

  it("Left hand side should be Price gt 5", function() {
     var lhs = result.options.$filterby[1] 
     assert.equal(lhs[0], "gt")
     assert.equal(lhs[1].name, "Price")
     assert.equal(lhs[2], 5)
  })

  it("Right hand side should be less than 10", function() {
     var rs = result.options.$filterby[2] 
     assert.equal(rhs[0], "lt")
     assert.equal(rhs[1].name, "Price")
     assert.equal(rhs[2], 10)
  })
})
</code></pre>

<p>We have a tree that looks like</p>

<pre><code>[ 'and', 
  [ 'gt', 'Price', 5 ],
  [ 'lt', 'Price', 10]
]
</code></pre>

<p>Our next step can walk this tree and generate SQL or something similar very easily.</p>

<p><strong>How do we generate such a thing?</strong></p>

<p>Well, 'and' is an operator with the lowest precedence (well, the same as 'or'), and therefore we want it to be first in the tree (it makes senseif you think about it!). </p>

<p>The leaves should be the nodes with the highest precedence because we'll get their results first and them go up to the root node.</p>

<p>This suggests we need to cascade through the preferable options until we find something we like:</p>

<p>There is quite a wall here, so let's break it down</p>

<pre><code>  FilterByOption = 
    seq("$filterby=")
    FilterByExpression:expr -&gt; { name: "$filterby", value: expr }
</code></pre>

<p><em>When we find $filterby, then parse the expression</em></p>

<pre><code>  FilterByExpression =
    FilterAndExpression
</code></pre>

<p><em>The first thing we want to find is an 'and' expression</em></p>

<pre><code>  FilterAndExpression =
    FilterAndExpression:lhs
    FilterAndOperand:op
    FilterLogicalExpression:rhs -&gt; [ op, lhs, rhs ]
  | FilterLogicalExpression
</code></pre>

<p><em>try and find more AndExpressions</em></p>

<p><em>Else, let the right hand side be the next preferable thing (a plain old logical expression)</em></p>

<p><em>Else, just try to find a logical expression</em></p>

<pre><code>  FilterLogicalExpression =
    FilterLogicalExpression:lhs
    FilterByOperand:op
    FilterByValue:rhs -&gt; [ op, lhs, rhs ]
  | FilterByValue
</code></pre>

<p><em>Try to find more LogicalExpressions</em></p>

<p><em>Else, let the right hand side be the next preferable thing (a plain old value)</em></p>

<p><em>Else fall back to finding a value</em></p>

<pre><code>  FilterAndOperand =
    spaces
    (
      seq("and")
    | seq("or")
    ):op 
    spaces -&gt; op
</code></pre>

<p><em>And/or have the same precedence</em></p>

<pre><code>  FilterByOperand =
    spaces
    (
      seq("eq")
    | seq("ne")
    | seq("gt")
    | seq("ge")
    | seq("lt")
    | seq("le")
    ):op 
    spaces -&gt; op
</code></pre>

<p><em>These are unchanged</em></p>

<pre><code>  FilterByValue = 
    Number
  | QuotedText
  | PropertyPath
</code></pre>

<p><em>As are these</em></p>]]></description><link>http://codeofrob.com/entries/recursive-expression-parsing-in-our-odata-filter-parser.html</link><guid isPermaLink="true">http://codeofrob.com/entries/recursive-expression-parsing-in-our-odata-filter-parser.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 15 Apr 2013 09:30:00 GMT</pubDate></item><item><title><![CDATA[Our OData parser - looking at filterby]]></title><description><![CDATA[<p>A quick re-cap of where we are so far:</p>

<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
</ul>

<p>Now I need to tackle $filterby, which is bit of a mammoth, as can be seen from the description from the OData Uri conventions</p>

<pre><code>Eq         Equal                   /Suppliers?$filter=Address/City eq 'Redmond'
Ne         Not equal               /Suppliers?$filter=Address/City ne 'London'
Gt         Greater than            /Products?$filter=Price gt 20
Ge         Greater than or equal   /Products?$filter=Price ge 10
Lt         Less than               /Products?$filter=Price lt 20
Le         Less than or equal      /Products?$filter=Price le 100
And        Logical and             /Products?$filter=Price le 200 and Price gt 3.5
Or         Logical or              /Products?$filter=Price le 3.5 or Price gt 200
Not        Logical negation        /Products?$filter=not endswith(Description,'milk')
Add        Addition                /Products?$filter=Price add 5 gt 10
Sub        Subtraction             /Products?$filter=Price sub 5 gt 10
Mul        Multiplication          /Products?$filter=Price mul 2 gt 2000
Div        Division                /Products?$filter=Price div 2 gt 4
Mod        Modulo                  /Products?$filter=Price mod 2 eq 0
( )        Precedence grouping     /Products?$filter=(Price sub 5) gt 10
</code></pre>

<p>And this is before we even have a look at the supported <em>"functions"</em> (we'll leave these until the next entry I think!)</p>

<p>Thankfully this is all pretty much the same deal and boils down to simple recursive expression parsing. </p>

<p><strong>Implementing Eq</strong></p>

<p>I'll not do this for all of them, but you can assume I've just implemented them the same way only with "Ge, etc" substituted for whatever...</p>

<pre><code>test("/some/resource?$filterby=Foo eq 2", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'eq'", function() {
     assert.equal(result.options.$filterby[0], "eq")
  })
  it("lhr should be Foo", function() {
     assert.equal(result.options.$filterby[1].name, "Foo")
  })
  it("rhr should be 2", function() {
     assert.equal(result.options.$filterby[2], 2)
  })
})
</code></pre>

<p>The idea for this stuff is that I want to generate an AST for further processing by say, a SQL generator. The easiest way to do this is to generate arrays for consumption. This can be ran through a further OMeta processing step to generate SQL later on.</p>

<p>I'm not so comfortable with the bit where I address the filterby[1].name, it feels as addressing down a path should be dealt with in the same way as the rest of the AST (perhaps everywhere else I should be generating an array instead of those nested objects).</p>

<p>I actually have some other ideas about how I'd do this so I'll park that as well (as I'm having a conversation and review of this code tomorrow in the office)</p>

<p><strong>The implementation</strong></p>

<pre><code>FilterByOption = 
  seq("$filterby=")
  FilterByExpression:expr -&gt; { name: "$filterby", value: expr }
,
FilterByExpression =
  PropertyPath:lhs
  seq(" eq ")
  Number:rhs           -&gt; [ "eq", lhs, rhs ]
,
</code></pre>

<p>So I'm keeping it simple by making some assumptions that'll get proved wrong in a sec</p>

<ul>
<li>Only accepting number for rhs</li>
<li>Only accepting 'eq as the operand</li>
<li>PropertyPath is probably not the way to go for this in its current incarnation as mentioned above</li>
</ul>

<p><strong>Adding not equals</strong></p>

<pre><code>test("/some/resource?$filterby=Foo ne 2", "OData", function(result) {
  it("A filter should be present", function() {
     assert.notEqual(result.options.$filterby, null)
  })
  it("Filter should be an instance of 'ne'", function() {
     assert.equal(result.options.$filterby[0], "ne")
  })
  it("lhr should be Foo", function() {
     assert.equal(result.options.$filterby[1].name, "Foo")
  })
  it("rhr should be 2", function() {
     assert.equal(result.options.$filterby[2], 2)
  })
})
</code></pre>

<p>Can be dealt with by saying that our Operand is a choice</p>

<pre><code>FilterByOption = 
  seq("$filterby=")
  FilterByExpression:expr -&gt; { name: "$filterby", value: expr }
,

FilterByExpression =
  PropertyPath:lhs
  FilterByOperand:op
  Number:rhs           -&gt; [ op, lhs, rhs ]
,

FilterByOperand =
  seq(" eq ") -&gt; "eq"
| seq(" ne ") -&gt; "ne"
</code></pre>

<p>Can now do the same for </p>

<ul>
<li>Gt</li>
<li>Ge</li>
<li>Lt</li>
<li>Le</li>
</ul>

<p>Like so</p>

<pre><code>FilterByOperand =
  spaces
  (
    seq("eq")
  | seq("ne")
  | seq("gt")
  | seq("ge")
  | seq("lt")
  | seq("le")
  ):op 
  spaces -&gt; op
  ,
</code></pre>

<p>Note that I tidied it up, and allowed any white space either side and got rid of my own strings (the last return result is automatically assigned to 'op'</p>

<p>And I'll parameterise the test to get this covered easily and document my progress</p>

<pre><code>function operandTest(op) {
  test("/some/resource?$filterby=Foo " + op + " 2", "OData", function(result) {
    it("A filter should be present", function() {
       assert.notEqual(result.options.$filterby, null)
    })
    it("Filter should be an instance of '" + op + "'", function() {
       assert.equal(result.options.$filterby[0], op)
    })
    it("lhr should be Foo", function() {
       assert.equal(result.options.$filterby[1].name, "Foo")
    })
    it("rhr should be 2", function() {
       assert.equal(result.options.$filterby[2], 2)
    })
  })
}
operandTest("eq")
operandTest("ne")
operandTest("gt")
operandTest("ge")
operandTest("lt")
operandTest("le")
</code></pre>

<p><strong>Not everything is a number</strong></p>

<p>Now for the next thing, what can we have as that Rhs? Well, let's go with</p>

<ul>
<li>Number (eg 2, 3, 5 )</li>
<li>QuotedText (eg 'foo', 'bar')</li>
</ul>

<p>As that's what I can think of from the docs</p>

<p>Here is a test for the quoted string:</p>

<pre><code>  test("/some/resource?$filterby=Foo eq 'bar'", "OData", function(result) {
    it("A filter should be present", function() {
       assert.notEqual(result.options.$filterby, null)
    })
    it("Filter should be an instance of 'eq'", function() {
       assert.equal(result.options.$filterby[0], op)
    })
    it("lhr should be Foo", function() {
       assert.equal(result.options.$filterby[1].name, "Foo")
    })
    it("rhr should be 2", function() {
       assert.equal(result.options.$filterby[2], 'bar')
    })
  })
</code></pre>

<p>Same deal again, let's make this extendable</p>

<pre><code>FilterByExpression =
  PropertyPath:lhs
  FilterByOperand:op
  FilterByValue:rhs           -&gt; [ op, lhs, rhs ]
,
</code></pre>

<p>With</p>

<pre><code>FilterByValue = 
  Number
| QuotedText
</code></pre>

<p>Where QuotedText looks something like this:</p>

<pre><code>QuotedText =
  '\''
  Text:t 
  '\'' -&gt; t
,
</code></pre>

<p>Imaginative.</p>

<p>Next up we'll have to think about what else we can expect to see in our expressions - thinking about the Arithmetic operators and grouping operators. <em>shudder</em></p>]]></description><link>http://codeofrob.com/entries/our-odata-parser---looking-at-filterby.html</link><guid isPermaLink="true">http://codeofrob.com/entries/our-odata-parser---looking-at-filterby.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 12 Apr 2013 09:30:00 GMT</pubDate></item></channel></rss>