<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>NodeJS RSS Module</generator><lastBuildDate>Sat, 02 Mar 2013 13:41:38 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><item><title><![CDATA[Basic operations with LevelDB]]></title><description><![CDATA[<p>So, in <a href="/entries/investigating-ravendb-on-mono-for-reals.html">trying out LevelDB</a>, I need to work out the basics, and then apply those learnings to whether the functionality exposed is compatible with RavenDB's storage needs.</p>

<p>I spent a few hours in the car on the way to and back from the Dead Sea and this seemed like an ideal time to crack out the g++ and write some C++ on top of LevelDB.</p>

<p>The first thing I did was download <a href="https://code.google.com/p/leveldb/">the source</a> and un-pack it, I also grabbed <a href="http://twitter.com/kellabyte">@kellabytes</a>'s '<a href="https://github.com/kellabyte/Dazzle">Dazzle</a>' source code as an 'RTFM' back-up.</p>

<p>What I really like is that the header files for LevelDB are the best means of documentation, I forgot I liked this about C++, I now remember - all the learnings done ended up being done by just reading the source code, pretty neat.</p>

<p>So, what do we have?</p>

<p><em>Opening a database</em></p>

<pre><code>leveldb::DB* db;
leveldb::DB::Open(options, "play/testdb", &amp;db);
</code></pre>

<p><em>Putting something in</em></p>

<pre><code>status = db-&gt;Put(leveldb::WriteOptions(), "Key", "Hello World");
</code></pre>

<p><em>Getting something out</em></p>

<pre><code>std::string document;
store-&gt;Get(leveldb::ReadOptions(), "key", &amp;document);
</code></pre>

<p><em>Deleting something</em></p>

<pre><code>store-&gt;Delete(leveldb::WriteOptions(), "key");
</code></pre>

<p><em>Squeeeeeeee</em></p>

<p>I love how simple that is, and that each of these is a safe operation, important to note the following at this point:</p>

<ul>
<li>I'm passing in strings to those put/get operations</li>
<li>LevelDB is copying to/from those strings</li>
<li>Because we're using strings, scope determines the release of memory</li>
</ul>

<p>This is elegant, Put actually takes a "Slice" type too, but that's implicitly convertable from a string and therefore this works nicely. </p>

<p>I'll cover Slice on its own as it's an interesting notion if I understand it correctly.</p>

<p>Importantly for RavenDB, we need to be able to write multiple operations in an atomic fashion, LevelDB appears to accommodate for this neatly.</p>

<pre><code> leveldb::WriteBatch batch;
 batch.Delete("key");
 batch.Put("key2", value);
 db-&gt;Write(leveldb::WriteOptions(), &amp;batch);
</code></pre>

<p>LevelDB can actually operate in async or synchronous mode, but because Raven makes gaurantees about writes having happened I can't think we'd be able to use async mode (because there isn't any way to know when these writes are finished to my knowledge).</p>

<p>These guarantees aren't actually enough for RavenDB, and I'll cover the reasons for that in the next entry.</p>]]></description><link>http://codeofrob.com/entries/basic-operations-with-leveldb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/basic-operations-with-leveldb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 01 Mar 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Investigating RavenDB on Mono for reals]]></title><description><![CDATA[<p>I've been down <a href="/entries/ravendb-on-mono.html">this road before</a> with a certain amount of success, and indeed I even did several talks entirely in linux about RavenDB complete with working demos (although some folk might doubt that story).</p>

<p>So what gives then? How come RavenDB doesn't work on Mono out of the box now a couple of years later? Well - the short answer is that it never did. </p>

<p>When I got it working on Mono in the past it was on top of "Munin", a managed storage engine that <a href="http://twitter.com/ayende">@ayende</a> and I hacked up in a hotel lobby in the small hours of the morning that "mostly works" but has never entirely been recommended for production.</p>

<p>That's not to say we haven't got a lot of mileage out of it, as indeed it has been used in pretty much everyone's test suites since its conception and has faithfully done as asked all that time; however, it is clear that for <em>true</em> cross-platform happiness, we could do with a replacement for Esent for platforms that don't support it, and re-inventing the wheel ourselves when so many other people have done work on this for us doesn't make a lot of sense.</p>

<p>The other problem is of course that RavenDB was developed on top of the .NET runtime, using the .NET compiler chain - and support for some of the features used by RavenDB make compilation on mono an hilariously frustrating process of bug fixes and pull requests (which then means it won't work OOB on versions of mono packaged with popular Linux distros). </p>

<p>I'm not going near that with a barge pole, although I'm sure if somebody wants to sit there and get RavenDB simply <em>building</em> on Mono, it'll only take a few hours of workarounds which will be happily accepted as a pull request.</p>

<p>With that, this series of blog posts is <strong>not</strong> going to finish with an entry saying "It now works on Mono", because that's going to take a couple of weeks' work and I haven't got a couple of weeks. However, the breadcrumbs and work completed so far should be good enough for anybody with the spare time and inclination to finish that work and get it working for reals.</p>

<p>So, we've been doing some investigations, and in summary it looks like LevelDB is a good option for our usage patterns - I'm going to spend a couple of entries going over the little spikes I wrote to verify that, and then show the beginnings of the work inside RavenDB itself to kick this off with.</p>

<p>With a proper cross-platform persistence solution, and a few hours tinkering with the build - RavenDB will work on Mono, allow me to help lay some foundations...</p>]]></description><link>http://codeofrob.com/entries/investigating-ravendb-on-mono-for-reals.html</link><guid isPermaLink="true">http://codeofrob.com/entries/investigating-ravendb-on-mono-for-reals.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 28 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Custom query inputs in RavenDB]]></title><description><![CDATA[<p>Back on the list of things "added to RavenDB" <a href="/entries/working-at-hibernating-rhinos.html">during my time at Hibernating Rhinos</a>, ever wished you could pass custom arguments to the transformer when performing a query in RavenDB?</p>

<p>Well, this has been asked for a number of times and since <a href="/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html'">splitting out results-transformers</a> into their own process, it has become much easier to add this functionality.</p>

<p>What does this look like?</p>

<p>Well, say we have a result transformer that takes Ponies and creates unicorns, only our database doesn't know about horns - let's see what we can do here.</p>

<pre><code>public class Unicorn {
  public string Name { get; set; }
  public string Colour { get; set; }
  public string CutieMark { get; set; }
  public int Hornsize { get; set; }
}

public class PoniesIntoUnicorns : AbstractTransformerCreationTask&lt;Pony&gt; {
  public PoniesIntoUnicorns() {
    Transform = ponies =&gt; from pony in ponies
                          select new {
                            pony.Name,
                            pony.Colour,
                            pony.CutieMark,
                            Hornsize = pony.Size * Query["hornscalefactor"]
                          }
  }
}
</code></pre>

<p>Okay, contrived example but this feature isn't for me and my pony database, it's for you and your requirements, and you know it's you I'm talking about because you're looking at the above and going <em>finally, I've been waiting for this</em>.</p>

<p>How do we use the above?</p>

<pre><code>session.Query&lt;Pony&gt;()
       .Where(pony =&gt; pony.Colour === "purple")
       .TransformWith&lt;PoniesIntoUnicorns, Unicorn&gt;()
       .AddQueryInput("hornscalefactor", 0.1)
       .ToArray();
</code></pre>

<p>Pretty simple and effective, glad I could oblige :)</p>

<p>Oh yeah, it works for Load too</p>

<pre><code>var unicorn = session.Load&lt;PoniesIntoUnicorns, Pony&gt;(
              x=&gt; x.AddQueryInput("hornscalefactor", 0.1))
</code></pre>

<p>Not the tidiest API in the world, but I'm sure it will improve as people actually use it.</p>]]></description><link>http://codeofrob.com/entries/custom-query-inputs-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/custom-query-inputs-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 27 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Talking at DevSum 2013]]></title><description><![CDATA[<p>I've been told I need to tell people when I'm doing talks, so consider this my attempt at making this so.</p>

<p>I'll be talking at <a href="http://devsum.se/">Devsum 2013</a> on the 29th/30th of May on the <a href="http://devsum.se/talare/rob-ashton/">pragmatic outside-in testing of ASP.NET MVC applications</a></p>

<p>I went to Devsum last year and had a lot of fun, last year the venue was just down the road from an Irish Pub and that pretty much put the icing on the cake. Let me know if you're going to be there and we can organise a guinness driven get-together.</p>

<p>Hoping to announce a few other talks here soon, I finish travelling and working around the world at the end of May and I'm available.</p>]]></description><link>http://codeofrob.com/entries/talking-at-devsum-2013.html</link><guid isPermaLink="true">http://codeofrob.com/entries/talking-at-devsum-2013.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 26 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[RavenDB - Avoiding ambiguity in result transformers]]></title><description><![CDATA[<p>So, this is a niche case that is quite annoying for people writing transformers as part of a map or a map/reduce index - and now we have the ability to specify transformers separately to the index this problem only gets worse.</p>

<p>What is this problem?</p>

<p>Well, if I make a map that does this:</p>

<pre><code>public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
{
   public Ponies() {
     Map = ponies =&gt;
           from pony in ponies
           select new {
             pony.Name,
             pony.Colour,
             pony.CutieMark
           }

     Store(pony =&gt; pony.CutieMark, FieldStorage.Yes);
     Store(pony =&gt; pony.Name, FieldStorage.Yes);
     Store(pony =&gt; pony.Colour, FieldStorage.Yes);
   }
}
</code></pre>

<p>Available to me <em>without even loading the document</em> after performing a query, is "Name", "Colour", and "CutieMark". Obviously we can store other things in there as well, and so some funky things in the map - but this is the essence of this functionality.</p>

<p>The same thing happens by default when you apply a reduce stage to an index, because you lose the original document entirely because of aggregation.</p>

<p>This can be a bit confusing, as sometimes you want the result from that store data, and sometimes you want the data from the document, and this has been an all-or-nothing thing.</p>

<p>Now we can <a href="/entries/result-transformers---not-just-for-querying.html">Use Load&lt;></a> with a ResultTransformer, this is even more ambiguous.</p>

<p>So, from now on, whenever you access anything in a ResultTransformer, RavenDB will first look in the stored fields for the information, and if not found - will load the document associated with the current result and fetch it from that.</p>

<p>It's a small change, but one which will remove a lot of the confusion around this feature.</p>]]></description><link>http://codeofrob.com/entries/ravendb---avoiding-ambiguity-in-result-transformers.html</link><guid isPermaLink="true">http://codeofrob.com/entries/ravendb---avoiding-ambiguity-in-result-transformers.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 25 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Result transformers - not just for querying]]></title><description><![CDATA[<p>In the <a href="/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html">last entry</a> I demonstrated a new artifact in RavenDB for transforming results from queries into view models with all the information attached you could think of.</p>

<p>Well, the primary use case (in my mind) for this, is the creation of view models for web clients without having to de-normalise data or perform multiple remote calls.</p>

<p>Well, actually - if we're viewing say, a single item by id, it doesn't make a lot of sense to have to do a query to get that single item by id. It doesn't make a lot of sense to have to create an index for this.</p>

<p>In the past, that's the best we could hope for, unless perhaps you used the 'include' functionality to load related documents and then created the view model in the client out of those related documents. This looks something like this:</p>

<pre><code>var order = session.Include("CustomerId")
                        .Load&lt;Order&gt;("orders/1")

var customer = session.Load&lt;Customer&gt;(order.CustomerId)

// Build view model here
</code></pre>

<p>This is okay and everything, but requires a bit of mental leg-work on the part of the client.</p>

<p>What you really want to do is just ask for the view model, sort of like making a single query in SQL to get all the information you want with one go.</p>

<p>Well, how about this?</p>

<pre><code>  var orderViewModel = session.Load&lt;OrderWithCustomerTransform, OrderWithCustomer&gt;("orders/1")
</code></pre>

<p>That's a lot nicer, the code for this is as thus</p>

<pre><code>public class OrderWithCustomer 
{
   public string OrderId { get; set; }
   public string OrderDate { get; set; }
   public string CustomerId { get; set; }
   public stirng CustomerName { get; set; }
}

    public class OrderWithCustomerTransform : AbstractIndexCreationTask&lt;Order&gt;
    {
         public OrderWithCustomerTransform()
         {
                TransformResults = (database, orders) =&gt;
                        from order in orders
                        let customer = database.Load&lt;Pet&gt;(order.CustomerId)
                        select new {
             OrderId = order.Id,
             OrderDate = order.Date,
             CustomerId = customer.Id,
             CustomerName = customer.Name
                        }
         }
    }
</code></pre>

<p>Being able to compose view models on the server as part of the load process by pulling in related documents and only pull out the fields you need is awesome.</p>

<p>Being able to re-use these transforms across different indexes or load operations and get a consistent return shape is even awesomer.</p>

<p>Tomorrow I'll show a really cool edge case around this, and how we got rid of a lot of he confusion around transforms.</p>]]></description><link>http://codeofrob.com/entries/result-transformers---not-just-for-querying.html</link><guid isPermaLink="true">http://codeofrob.com/entries/result-transformers---not-just-for-querying.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 22 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[RavenDB ResultTransformers - a new way of looking at things]]></title><description><![CDATA[<p>So, how do we solve a problem like TransformResults? Easy! We make ResultsTransfomers!</p>

<p><img src="/img/prime.jpg" alt="Optimus Prime" title="" /></p>

<p>Okay, so what's in a name?</p>

<p>Well, rather than attach the function we want to transform the results with to the index like so</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
              from pony in ponies
              select new {
                pony.Name,
                pony.Colour,
                pony.Trampstamp
                            }
                TransformResults = (database, results) =&gt;
                        from result in results
                        let pet = database.Load&lt;Pet&gt;(result.PetId)
                        select new {
                            PonyId = pony.Id
                            Name = pony.Name,
                            PetName = pet.Name,
                            PetSpecies = pet.Species
                        }
         }
    }
</code></pre>

<p>How about defining it separately like this?</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
            from pony in ponies
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp
                            }
         }
    }
</code></pre>

<p>And</p>

<pre><code>public class PonyWithPetViewModel 
    {
        public string PonyId { get; set; }
        public string Name { get; set; }
        public string PetName { get; set; }
        public string PetSpecies { get; set; }
    }


    public class PoniesWithPets : AbstractTransformerCreationTask&lt;Pony&gt;
    {
         public PoniesWithPets()
         {
              TransformResults = ponies =&gt; 
                        from pony in ponies
                        let pet = database.Load&lt;Pet&gt;(pony.PetId)
                        select new {
                            PonyId = pony.Id
                            Name = pony.Name,
                            PetName = pet.Name,
                            PetSpecies = pet.Species
                        }
         }
    }
</code></pre>

<p>Then, to get a list of ponies with pets in that view model format, we can simply supply the transformer want to use as part of the query</p>

<pre><code>    session.Query&lt;Pony&gt;()
                 .Where(pony =&gt; pony.Name == "Pinkie Pie")
                 .TransformWith&lt;PoniesWithPets, PonyWithPetViewModel&gt;
                 .ToList()
</code></pre>

<p>This is much tidier, and allows us to use transformers to elegantly create view models across any index providing the input is sane enough, it also removes some of the complexity around indexes. Look - we didn't even specify an index for this query and yet we were able to use a transformer on it, dynamic index win!</p>

<p>This actually took a couple of days to implement, but I still have four days of work at Hibernating Rhinos so hopefully more coming soon!</p>]]></description><link>http://codeofrob.com/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html</link><guid isPermaLink="true">http://codeofrob.com/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 21 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[The problem with result transformations in RavenDB]]></title><description><![CDATA[<p>I mentioned yesterday that there are some problems with how <a href="/entries/re-thinking-result-transformations-in-ravendb.html">result transformations work in RavenDB</a></p>

<p>In truth, there are no problems, but as <a href="http://twitter.com/ayende">@ayende</a> mentioned himself, feature intersection is causing issues for development in RavenDB.</p>

<p>What is this feature intersection? Well, we have a <em>lot</em> of features around indexes and queries now, and they're all touching and overlapping in all sorts of strange ways - this is hardly surprising, it happens to many well-used software projects with feature requests flying in every day and so many awesome ideas to implement.</p>

<p>The problem that result transformations were initially trying to solve (and I know, I helped implement them in a hotel lobby with Ayende a couple of years ago), were the question of "joins" across documents. Well - this worked well, and had the added bonus of being able to define the exact result shape coming back from RavenDB (pre-forming entire view models in a single query as it were).</p>

<p>That's great, and now we have the ability to do what we did yesterday with yet another feature, load document in map, like so:</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
                Map = from pony in ponies
                            let pet = LoadDocument(pony.id)
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp.
                                PetName = pet.Name.
                                PetSpecies = pet.Species
                            }
         }
    }
</code></pre>

<p>This is kinda cool, although it has implications in complexity when it comes to the indexing and re-indexing of documents that isn't what this blog entry is about.</p>

<p>We've ended up with information in the index which we might want as part of our output, and it's not immediately obvious how we're going to get that out, and this is also doing quite a bit of the work we might want to do with the result transformation phase. (Feature overlap)</p>

<ul>
<li>How about what happens if we have a standard view model that we want to return from a transform, but several different indexes we might query to do that?</li>
<li>What about what happens we want to do a result transform when performing a dynamic query?</li>
<li>And what if we want to use the stored data in index instead of transforming a loaded document?</li>
</ul>

<p>We've actually got a few <em>niggles</em> around these functionalities too, existing as entries in the issue tracker (such as we don't ignore FieldsToFetch when performing a transform), and we've ended up boolean flags to "SkipTransformResults"!!</p>

<p>In essence, it's a bit messy and there is one immediate step we can take to fix this - any takers on what that might be?</p>]]></description><link>http://codeofrob.com/entries/the-problem-with-result-transformations-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-problem-with-result-transformations-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 20 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Re-thinking result transformations in RavenDB]]></title><description><![CDATA[<p>After all the work on indexes, things started getting downright <em>dirty</em> at the Hibernating Rhinos offices as we looked at re-vamping TransformResults in RavenDB.</p>

<p>First, a re-cap on what TransformResults actually is; consider we have a couple of documents that look something like this:</p>

<p><em>A pony</em></p>

<pre><code>    {
        id: "ponies/rainbowdash",
        name: "Rainbow Dash",
        colour: '#9EDBF9',      // I actually looked this up
        trampstamp: 'rainbow-lightning',
        petid: 'pets/tank'
    }
</code></pre>

<p><em>a pet</em></p>

<pre><code>    {
        id: "pets/tank",
        name: "Tank",
        species: "Tortoise",
        colour: '#0F0'          // I didn't look this up
    }
</code></pre>

<p>Let's say we have an index that looks like this</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
            from pony in ponies
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp
                            }
         }
    }
</code></pre>

<p>When querying for a list of blue ponies, we might actually decide we want to know what species their pets are, we have the following options</p>

<ul>
<li>Include them from the client (This brings back a lot of information that we don't need)</li>
<li>Add a results transformer to the index</li>
</ul>

<p>We mostly end up doing the last one and so we do that and it looks like this:</p>

<pre><code>    public class Ponies : AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
            from pony in ponies
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp
                            }
                TransformResults = (database, results) =&gt;
                        from result in results
                        let pet = database.Load&lt;Pet&gt;(result.PetId)
                        select new {
                            PonyId = pony.Id
                            Name = pony.Name,
                            PetName = pet.Name,
                            PetSpecies = pet.Species
                        }
         }
    }
</code></pre>

<p>This gives us the ability to send only the information we want to the client as well as pull in information from other documents, that's pretty neat, but now it's in need of a bit of TLC, as some of its functionality has been <a href="http://ayende.com/blog/160545/feature-intersection-is-killing-me-referenced-document-indexing">superceded by Referenced Documents in Map</a> and it's a bit awkward as it is.</p>

<p>I'll talk more about that tomorrow when I go into some of the issues that we're experiencing with this feature.</p>]]></description><link>http://codeofrob.com/entries/re-thinking-result-transformations-in-ravendb.html</link><guid isPermaLink="true">http://codeofrob.com/entries/re-thinking-result-transformations-in-ravendb.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 19 Feb 2013 09:00:00 GMT</pubDate></item><item><title><![CDATA[Next, we run new RavenDB indexes in memory]]></title><description><![CDATA[<p><a href="/entries/getting-rid-of-temporary-indexes-in-ravendb.html">Other day</a> I wrote about the awesome news that we'd managed to delete an entire code-path from RavenDB as a result of some of the other changes coming in.</p>

<p>Well, it's not quite as simple as that, you see - temporary indexes in RavenDB had a reallly big advantage in that they were run entirely in memory (until they reached a configurable threshold anyway).</p>

<p>That's good, because  indexes and running data through indexes is typically an IO bound process, and if we can keep the indexes in memory while we work on them, the whole proces can be a lot more efficient.</p>

<p>Well, having gotten rid of an entire code path, surely it makes sense to move the code that used to do this to be applicable to all indexes?</p>

<p>Absolutely, so starting from whenever my pull request gets merged, all new indexes in RavenDB will be ran in memory to begin with (meaning you get less stale results much faster - great if you're using the auto-indexes or experimenting with manual indexes on large sets of data).</p>

<p>After the index has caught up with reality, it will be flushed to disk and celebrations will be had, or if the index reaches a configurable memory threshold that will happen too.</p>

<p>This is a small change that makes a big difference, and is possible (in part) because we managed to get rid of having two different types of index and two different code paths.</p>

<p>In the next entry, I'll talk about further optimisations made in this pull request to do with auto indexes.</p>]]></description><link>http://codeofrob.com/entries/next,-we-run-new-ravendb-indexes-in-memory.html</link><guid isPermaLink="true">http://codeofrob.com/entries/next,-we-run-new-ravendb-indexes-in-memory.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 18 Feb 2013 09:00:00 GMT</pubDate></item></channel></rss>