<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Rob Ashton's blog]]></title><description><![CDATA[Software development dumping ground]]></description><link>http://codeofrob.com</link><image><url>http://codeofrob.com/img/cover.jpg</url><title>Rob Ashton&apos;s blog</title><link>http://codeofrob.com</link></image><generator>RSS for Node</generator><lastBuildDate>Fri, 24 Jun 2016 02:54:39 GMT</lastBuildDate><atom:link href="http://feeds.feedburner.com/robashton" rel="self" type="application/rss+xml"/><author><![CDATA[Rob Ashton]]></author><item><title><![CDATA[Why you can't be a good .NET developer]]></title><description><![CDATA[<p>I was on Twitter today and I saw this tweet by <a href="https://twitter.com/ICooper/">Ian Cooper</a></p>
<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/jbogard">@jbogard</a> Agreed, it&#39;s crazy. The self-loathing mystifies me. All web C# use multiple languages (SQL and JS?) <a href="https://twitter.com/Adron">@Adron</a> <a href="https://twitter.com/aliostad">@aliostad</a> <a href="https://twitter.com/randompunter">@randompunter</a></p>&mdash; Ian Cooper (@ICooper) <a href="https://twitter.com/ICooper/status/742758275133890560">June 14, 2016</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>My first reaction was simply to laugh, because the idea of self-loathing .NET developers is a funny one, my second reaction was to say something pithy on Twitter and then I remembered I had a blog which <em>somehow</em> despite my best efforts is still running for some reason &quot;in the cloud&quot; and thought I&#39;d disagree here instead.</p>
<h1 id="it-s-not-self-loathing">It&#39;s not self loathing</h1>
<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/jbogard">@jbogard</a> The worst part of this is the old belief that I have to classify as an X developer and join or leave <a href="https://twitter.com/Adron">@Adron</a> <a href="https://twitter.com/aliostad">@aliostad</a> <a href="https://twitter.com/randompunter">@randompunter</a></p>&mdash; Ian Cooper (@ICooper) <a href="https://twitter.com/ICooper/status/742756504642674688">June 14, 2016</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>There is a reason this mentality exists and it isn&#39;t one of self loathing. The reason why people &quot;leave&quot; .NET is because <em>it is impossible to be a good .NET developer</em>. To work in a development shop with a team is to continually cater for the lowest common denominator of that team and the vast majority of software shops using .NET have a whole lot of lowest common denominator to choose their bad development decisions for.</p>
<p>Tangible examples? I remember well the insistence of one boss that we use TFS because some developers would find it hard to use git. I remember the steadfast committal to ASP.NET web forms because the &quot;new concepts&quot; in ASP.NET MVC were going to take too long for the team to become productive in. There is now this furore over .NET core and the new thing in the tiny 0.001% of people that care are whether they persist in using Windows or switch to more productive environments. Of course <a href="https://twitter.com/aliostad">@aliostad</a> gets it right here and points out that the primary &quot;<em>Important Thing</em>&quot; should be a focus on <a href="http://byterot.blogspot.co.uk/2016/06/after-all-it-might-not-matter-commentary-status-of-dotnet-dotnetcore-csharp-oss-fsharp-dnx.html">functional programming in languages like F#</a> and of course the reason it doesn&#39;t happen is because &quot;it&#39;s too hard for most people in our team&quot;.</p>
<p>It&#39;ll not happen because as long as you&#39;re working on a platform that is primarily used by derpy enterprise shops, you will continually be held back because those derpy enteprise shops are continually be held back by the derpy enterprise developers that work in the derpy enterprise shops.</p>
<p>It isn&#39;t self loathing, it&#39;s self preservation and an eventual realisation that you can&#39;t actually progress so long as you&#39;re being held back by bad decisions made to cater for the slow and the stupid. Self loathing is just an intermediate stage that people go through while they still believe they can make an impact on the environment around them by caring and shouting into the void to enact tiny changes that help nobody.</p>
<p>The easiest way to progress is always to jump ship and leave, that&#39;s why people do it; moving to a community of people who have seen how to be more effective and productive and leaving the old one behind. In my own case it has been to move to a community that barely exists because the team has to be pretty much self reliant and there is no room for lowest common denominators and long meetings over whether you should use semi-colons or not.</p>
<p><em>This</em> is why you can&#39;t be a good .NET developer, sooner or later the frustration sets in and you go and do something better. The average ability and desire for something better just keeps on plummetting whilst Microsoft try to chase the brain drain by casting little nuggets of mediocrity at the people left behind scrabbling in the mud. </p>
]]></description><link>http://codeofrob.com/entries/why-you-cant-be-a-good-.net-developer.html</link><guid isPermaLink="true">http://codeofrob.com/entries/why-you-cant-be-a-good-.net-developer.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 14 Jun 2016 09:30:00 GMT</pubDate></item><item><title><![CDATA[Erlang and Make - Okay together]]></title><description><![CDATA[<p>We don&#39;t tread the same path as most Erlangers, as <a href="/entries/the-ashton-disinterest-curve---erlang.html">mentioned</a> having been through more than a few of the standard build systems in that ecosystem we&#39;ve settled on our own (the original hard work done by somebody else). All on top of a <a href="/entries/erlang---getting-started-with-vir.html">pile of bash</a> that organically came from real world production use of Erlang.</p>
<h1 id="so-why-make-">So why Make?</h1>
<p>Well firstly we already know it; our other language other than Erlang at work is C (okay and (<em>spit</em>) JavaScript, oky three languages - and Bash... etc). Secondly if you look at an Erlang project and compilation of that Erlang project you&#39;ll see that we have a bunch of files that need compiling into another format (mostly independent to each other), let&#39;s have a wee look at that.</p>
<pre><code>src/<span class="variable">%.</span>erl       -&gt;    ebin/<span class="variable">%.</span>beam
src/<span class="variable">%.</span>app.src   -&gt;    ebin/<span class="variable">%.</span>app
src/<span class="variable">%.</span>xrl       -&gt;    ebin/<span class="variable">%.</span>beam
src/<span class="variable">%.</span>yrl       -&gt;    ebin/<span class="variable">%.</span>beam
priv/mibs/<span class="variable">%.</span>bin -&gt;    mins/<span class="variable">%.</span>mib
</code></pre><p>Etc.</p>
<p>If only there was a tool which allowed you to declaratively wildcard a bunch of inputs to a bunch of outputs and use timestamps to determine whether individual files needed re-compiling again. Hmmmmm.</p>
<p>So yeah, this is our fork of <a href="http://github.com/id3as/erl-mk.git">erl-mk</a>, although in a few days this will be renamed to <a href="http://github.com/id3as/id3as.mk">id3as.mk</a> so check which link doesn&#39;t 404 and this will see you right.</p>
<h1 id="conventions">Conventions</h1>
<p>There is a standard structure to an Erlang project, and it looks like this</p>
<pre><code class="lang-bash">    relx.config
    src/%.erl
    src/%.app.src
    release-files/sys.config
    release-files/*.anything.<span class="keyword">else</span>
    include/%.hrl
</code></pre>
<p>We can only get away with using a standard one-size-fits-all Makefile if you conform to some convention and given that there is already a convention to Erlang projects this is the one that we are using. Additionally you can also have</p>
<pre><code class="lang-bash">    apps/&lt;app-name&gt;/&lt;the same as above&gt;
</code></pre>
<p>To have multiple apps in the same project, and</p>
<pre><code class="lang-bash">    deps/&lt;dep-name&gt;/&lt;the same as above&gt;
</code></pre>
<p>To rely on other Erlang projects and their source code - more on that in a little bit.</p>
<h1 id="using-id3as-mk">Using id3as.mk</h1>
<p>To configure and use id3as.mk, we use an entry point Makefile to set up some variables and download id3as.mk - this would usually be called &quot;Makefile&quot; or &quot;makefile&quot; and sit in the top level of the project (vir will generate this if you&#39;re using it).</p>
<pre><code class="lang-cmake">    DEPS_DIR = $(addsuffix /deps, $(realpath .))
    ERL_LIBS = $(DEPS_DIR):$(realpath apps)

    <span class="keyword">export</span> DEPS_DIR
    <span class="keyword">export</span> ERL_LIBS

    <span class="keyword">export</span> ERLCFLAGS = +debug_info +warn_export_vars +warn_shadow_vars +warn_obsolete_guard +'{lager_truncation_size, <span class="number">10240</span>}'
    <span class="keyword">export</span> ERLMIBFLAGS =

    DEPS = lager cowboy gproc jsx

    dep_lager = git://github.com/basho/lager.git <span class="number">2.0</span>.<span class="number">1</span>
    dep_cowboy = git@github.com:extend/cowboy.git master
    dep_gproc = git://github.com/esl/gproc.git <span class="number">0.2</span>.<span class="number">12</span>
    dep_jsx = git://github.com/talentdeficit/jsx.git master

    id3as.mk:
      @wget --no-cache -nv -O $@ 'https://raw.github.com/id3as/id3as.mk/master/id3as.mk' || rm -f $@

    -<span class="keyword">include</span> id3as.mk
</code></pre>
<p>I&#39;m not a huge fan of using this for dependency downloads (I&#39;d prefer a bash script) but it&#39;s just a single operation at the start to download all dependencies to the DEPS_DIR and then build is just standard Make. You&#39;d still need to specify which dependencies you had because the Makefile uses this to build up a dependency tree and only build each dependency once (in the right order).</p>
<p>Anyway, it&#39;s self explanatory - you&#39;ll see that in Erlang we haven&#39;t got a package manager (although some misguided but well meaning folk are trying to change that), and we just download source into a deps folder and build that ourselves. (No, they&#39;re not submodules, <em>ew</em>)</p>
<p>For each dep, id3as.mk checks if there is a Makefile present (in which case it&#39;ll run that), checks if there is a rebar.config present (in which case it&#39;ll run rebar) and falls back to re-executing itself in the dep dir. For all the id3as.mk based dependencies it&#39;ll honour timestamps all the way down. Rebar is a little more dumb and once you&#39;re in the world of rebar it can be a little slow as it insists on recursing over deps multiple times during a single build (boo, hiss).</p>
<p>I&#39;m a big fan of having dep source available - it means if you build up a tags file for your editor you can jump into the source code of even the third party dependencies you&#39;re using and see how they work (what better documentation than the actual code okay just joking devs we should all be writing better documentation).</p>
<h1 id="make-commands">Make commands</h1>
<ul>
<li>&quot;make get-deps&quot; - initial download of deps</li>
<li>&quot;make&quot; - build <em>everything</em></li>
<li>&quot;make apps&quot; - just build the apps</li>
<li>&quot;make clean&quot; - clean up our app</li>
<li>&quot;make clean-all&quot; - ruthlessly gut everything</li>
<li>&quot;make apps/[foo]&quot; - just build the foo app</li>
<li>&quot;make deps&quot; - just build the deps</li>
<li>&quot;make deps/[foo]&quot; - just build that dep (useful if you&#39;re debugging a third party dep)</li>
<li>&quot;make rel&quot; - make a release</li>
</ul>
<p>Neato. Everything is just timestamp checking and then for bonus points</p>
<ul>
<li>make -j <anything from above>   - DO IT IN PARALLEL</li>
</ul>
<p>Seeing as most of these steps and most of the erl/beams are independent of each other a build is much faster if you run it in parallel.</p>
<h1 id="on-package-managers">On package managers</h1>
<p>I often get a few eyebrows raised when I say we don&#39;t need one of these - so the next entry will write about why they&#39;re unnecessary (in any of the incarnations so far) and why we should do without.</p>
]]></description><link>http://codeofrob.com/entries/erlang-and-make---okay-together.html</link><guid isPermaLink="true">http://codeofrob.com/entries/erlang-and-make---okay-together.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 24 Mar 2015 08:30:00 GMT</pubDate></item><item><title><![CDATA[Erlang - Getting started with vir]]></title><description><![CDATA[<p><a href="http://github.com/robashton/vir">Vir</a> is a bunching together of various scripts we had lying around our projects written in a combination of Bash and Erlang to manage the execution/release/etc process for our applications. It does what we need to do and stops about there - I suspect the best way of using Vir is to either use it as it is or fork it for your own organisation rather than trying to make it help everybody.</p>
<p>The easiest way to get started with vir is to clone it to ~/.vir and add this folder to the path, but it&#39;ll work if you just add it to a GH repo and run it locally to so... whatever - do what you want it&#39;s just a bash script.</p>
<p>Anyway, running vir should give us a list of possible commands, for now we&#39;ll just create an empty web application in a folder, so do something like the below..</p>
<pre><code>mkdir awesomeapp
cd awesomeapp
git init
vir init -t web awesome
git commit <span class="keyword">...</span>
</code></pre><p>This creates an application called &quot;<em>awesome</em>&quot; (and builds it) based off the <em>web</em> and gives us a folder structure that looks similar to below:</p>
<p>As mentioned in a previous blog entry, this is at immediate glance a lot to digest, but we can go through it a little at a time and see just what has been created for us.</p>
<p><strong>Config</strong></p>
<pre><code><span class="title">apps</span>/awesome/release-files/sys.config
<span class="title">apps</span>/awesome/src/awesome_config.erl
</code></pre><p>sys.config is a standalone file containing various key-value pairs of config and awesome_config is a wrapper that provides an API to read that file. Not much to see here.</p>
<p><strong>Application startup</strong></p>
<pre><code><span class="title">apps</span>/awesome/src/awesome_app.erl
<span class="title">apps</span>/awesome/src/awesome_sup.erl
</code></pre><p>An application requires something that implements the OTP Behaviour &quot;Application&quot; (<em>awesome_app.erl</em>), and if I want child processes within the structure I&#39;ll need a supervisor to manager them, that&#39;s (<em>awesome_sup.erl</em>).</p>
<p><strong>A web application</strong></p>
<pre><code>apps/awesome/src/<span class="filename">awesome_cowboy.erl
</code></pre><p>This is just a OTP genserver that uses Cowboy (one of our dependencies) to create a simple http listener.</p>
<p><strong>Release artifacts</strong></p>
<pre><code><span class="title">deployment</span>/build_no
<span class="title">deployment</span>/major_ver
<span class="title">deployment</span>/minor_ver
</code></pre><p>This is a cheap way of bumping version for the application during a release cycle.</p>
<p><strong>Dependencies</strong></p>
<pre><code><span class="title">deps</span>/cowboy/
<span class="title">deps</span>/cowlib/
<span class="title">deps</span>/edown/
<span class="title">deps</span>/gen_leader/
<span class="title">deps</span>/goldrush/
<span class="title">deps</span>/gproc/
<span class="title">deps</span>/jsx/
<span class="title">deps</span>/lager/
<span class="title">deps</span>/ranch/
</code></pre><p>Lots of folders containing lots more of the above. They were cloned and brought in because the Makefile contains a list of dependencies.</p>
<p>In reality we&#39;re only explicitly bringing in <em>cowboy</em>, <em>gproc</em>, <em>jsx</em> and <em>lager</em> and the others are further dependencies of these. Because Erlang operates in a single global namespace you can&#39;t do explicit imports ala NodeJS and have multiple versions of things in the application.</p>
<p>It doesn&#39;t matter too much anyway because dependency applications often spin up a fleet of processes on start-up rather than simply operating as library code, so you wouldn&#39;t want more than one version of an application running within a project.</p>
<p><strong>Various Manifests</strong></p>
<pre><code>apps/awesome/relx<span class="variable">.config</span>
apps/awesome/src/awesome<span class="variable">.app</span><span class="variable">.src</span>
</code></pre><p><em>relx.config</em> is a manifest specifying how to do a release with all the appropriate files, and <em>awesome.app.src</em> tells the boot system what state our application needs to be in before it can be started.</p>
<p><strong>A Makefile</strong></p>
<pre><code><span class="attribute">Makefile
</code></pre><p>Yup, we use make.</p>
<h1 id="using-it">Using it</h1>
<p>So how do we use this? Well the bash script we just ran probably did all this already but loosely our general dev cycle will be</p>
<pre><code><span class="title">make</span> -j apps         <span class="comment">#  "make in parallel, the apps only, ignore the deps"</span>
vir run awesome      <span class="comment">#  "vir, run the app please"</span>
</code></pre><p>If we add new dependencies, then we&#39;ll need to run the following command after a build before running</p>
<pre><code>vir boot             # <span class="keyword">Generate</span> bootscripts <span class="keyword">for</span> each application based <span class="keyword">on</span> the manifests
</code></pre><p>So what do we have when it starts up? Well, let&#39;s look at the logs first</p>
<pre><code>Erlang/OTP <span class="number">17</span> [erts-<span class="number">6.1</span>] [source] [<span class="number">64</span>-bit] [smp:<span class="number">4</span>:<span class="number">4</span>] [async-threads:<span class="number">10</span>] [kernel-poll:<span class="constant">false</span>]

<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.978</span> [info] Application lager started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.979</span> [info] Application ranch started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.979</span> [info] Application crypto started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.980</span> [info] Application cowlib started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.988</span> [info] Application cowboy started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.998</span> [info] Application gproc started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
<span class="number">13</span>:<span class="number">08</span>:<span class="number">49.998</span> [info] Application shared started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
Mode dev <span class="keyword">not</span> found
<span class="number">13</span>:<span class="number">08</span>:<span class="number">50.024</span> [info] Application awesome started <span class="function_start"><span class="keyword">on</span> <span class="title">node</span></span> nonode@nohost
Eshell V6<span class="number">.1</span>  (abort <span class="keyword">with</span> ^G)
</code></pre><p>Neato, we see all the applications specified in <em>awesome.app.src</em> started up. (Mode dev isn&#39;t found because we haven&#39;t got one and that&#39;s the default mode)</p>
<p>This is awesome.app.src for reference.</p>
<pre><code><span class="cell">{application, awesome,
 [
  {description, ""}</span>,
  <span class="cell">{vsn, "<span class="number">1.0</span><span class="number">.0</span>"}</span>,
  <span class="cell">{registered, []}</span>,
  <span class="cell">{modules, []}</span>,
  <span class="cell">{included_applications, []}</span>,
  <span class="cell">{applications,
   [
    kernel,
    jsx,
    stdlib,
    lager,
    cowboy,
    gproc,
    shared
   ]}</span>,
  <span class="cell">{mod, { awesome_app, []}</span>},
  <span class="cell">{env, []}</span>
  ]}.
</code></pre><p>See what I mean about dependencies not simply being a pile of code, that list of folders we have in deps contain actual applications that are started up before awesome_app itself.</p>
<p>Is it working?</p>
<pre><code>curl http://localhost:3000/index.html
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>Yup.</p>
<h1 id="next-up">Next up</h1>
<p>I&#39;ll look at our Makefile and how we handle dependencies, and explain a bit more our decisions around that.</p>
]]></description><link>http://codeofrob.com/entries/erlang---getting-started-with-vir.html</link><guid isPermaLink="true">http://codeofrob.com/entries/erlang---getting-started-with-vir.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Thu, 19 Mar 2015 09:30:00 GMT</pubDate></item><item><title><![CDATA[Erlang - How we do it]]></title><description><![CDATA[<p>Having <a href="/entries/the-ashton-disinterest-curve---c.html">established</a> that I <a href="/entries/the-ashton-disinterest-curve---javascript-and-node.html">apparently</a> <a href="/entries/the-ashton-disinterest-curve---clojure.html">hate</a> <a href="/entries/the-ashton-disinterest-curve---erlang.html">everything</a>, let&#39;s get a bit more constructive and go over how at the company I work at, we do Erlang and do Erlang effectively.</p>
<p>Let&#39;s start off with a little history first though to build context for this series... I&#39;ll use &quot;we&quot; a lot, but what I really mean is &quot;me and my current understanding of our way&quot;.</p>
<h1 id="where-we-are">Where we are</h1>
<p>There were a couple of .NET developers, and they had need to build a distributed system and they looked at .NET and went &quot;hell no, let&#39;s do that little bit in Erlang&quot; and then a little bit later &quot;Oh sod it, let&#39;s do everyting in Erlang this is actually great&quot;. Lots of mistakes were made over the next few years and they were learned from as they were made. Eventually a developer called Rob (me) joined the team and most of the important mistakes had already been made and a lot of decisions had been made about how best to be effective at Erlang development.</p>
<p>We&#39;ve been through our own custom build systems/runners, to using <a href="https://github.com/rebar/rebar">Rebar</a>, to using fairly <a href="https://github.com/ninenines/erlang.mk">poorly written</a> Makefiles to using <a href="https://github.com/fenollp/erl-mk">reasonably written</a> Makefiles to just forking the best one and making it <a href="https://github.com/id3as/erl-mk">our own</a>. We&#39;ve been through the &quot;let&#39;s make everything a gen server&quot; to &quot;why do we need gen servers anyway&quot; to &quot;okay, here is the happy medium&quot;. We&#39;ve had bash scripts lying around a bunch of projects for automation purposes that have diverged from each other, converged again and been merged into a &quot;<a href="https://github.com/robashton/vir">single tool to rule them all</a>&quot;. We have sensible ways to build up APIs between gen servers, between running applications and we have a common swiss army knife of a common library that every time I go to write Erlang without for personal stuff I wonder how on earth I ever got on without.</p>
<p>It&#39;s a pretty mature stack and because we own most of it outside of our basic dependencies we&#39;re not subject to the whims of third parties changing their minds about how projects should be written and managed. Leaning on a large platform like Erlang is relaxing because it has been around for a few decades and generally doesn&#39;t undergo massive shifts every year just because some hipster somewhere decides they don&#39;t like <em>that sort</em> of paren or semi-colon.</p>
<p>We&#39;re pretty much against package managers, binary dependencies or other opaque tooling that we can&#39;t understand and simply make our own. We&#39;ve learned the hard way that sometimes the best tools are the ones that we&#39;ve all been using since the dawn of time (Bash and Make) and slowly over time these ideas have converged and become crystalised as a standard set of tools we all understand and are happy with.</p>
<h1 id="a-series-then">A series then</h1>
<p>So we have these bash scripts and makefiles and our standard application structure and while we&#39;ve been using them for years in various forms we&#39;ve never really publicised that they&#39;re actually OSS on Github. We&#39;ve never talked about how to use them to build Erlang applications (new starters? Pair for half a year and you&#39;ll have it all down like second nature anyway).</p>
<p>Now that most of this has stabilised (for now), it&#39;s quite a good time to write a blog series about our workflow, how to bootstrap a new application, how to do builds and releases and best practises around gen servers and processes and APIs and inter-process communication. We&#39;re also heavy Docker users (for now) so I&#39;ll cover our loose workflow around how we use that for development etc.</p>
<p>On board? The next entry will be about bootstrapping an empty application.</p>
]]></description><link>http://codeofrob.com/entries/erlang---how-we-do-it.html</link><guid isPermaLink="true">http://codeofrob.com/entries/erlang---how-we-do-it.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Tue, 17 Mar 2015 09:30:00 GMT</pubDate></item><item><title><![CDATA[The Ashton Disinterest Curve - Erlang]]></title><description><![CDATA[<p>I&#39;ve complained about <a href="/entries/the-ashton-disinterest-curve---c.html">.NET</a> (nothing has changed by the way) and <a href="/entries/the-ashton-disinterest-curve---javascript-and-node.html">JS</a> (or here) and I&#39;ve been pretty nice about <a href="/entries/the-ashton-disinterest-curve---clojure.html">Clojure</a> (or so I thought) and I&#39;ve managed to delay doing anything about Erlang at all because reasons.</p>
<h1 id="erlang-mundane-brilliance">Erlang - mundane brilliance</h1>
<p>I&#39;m not passionate about Erlang; I&#39;ve never been passionate about Erlang and I&#39;ve never hated it either. Perhaps this explains why I&#39;m over a year into working with it professionally and I still don&#39;t feel the need to talk loudly about it one way or another. (That and I have a great team of colleagues, work remotely and build pretty awesome products that are actually being used by people - okay then).</p>
<p>Let&#39;s get something out of the way then, I&#39;m not an Erlang evangelist - I was even asked in a talk the other day what my three sentence elevator pitch for Erlang would be and I haven&#39;t got one. If you want to put in the effort to work in the Erlang ecosystem then the rewards will become apparent fast enough but trying to explain how exactly such an ugly language contributes positively in any way to our product quality/stability in a tidy soundbite just isn&#39;t something I&#39;m interested in doing.</p>
<h1 id="erlang-is-ugly">Erlang is Ugly</h1>
<p>Contrived bit of code I just wrote in the airport:</p>
<pre><code class="lang-erlang">
    -module(greeter).

    -export([hello/2]).

    -record(state, {
        targets :: list(target_config())
      })

    init() -&gt;
      spawn_link(fun chat_loop/0).

    hello(Pid, Str, Names)
      case Names of
        [] -&gt;  ok;
        [ Head | Tail ] -&gt;
          Pid ! { hello, Str, Head },
          hello(Pid, Str, Names)
      end.

    chat_loop(State) -&gt;
      NewState = receive
        { hello, Str, Name } -&gt;
          Target = lookup_name(Name),
          Target:write(Str),
          State,
        { register, Name, Cfg } -&gt;
          register_name(State, Name, Cfg)
        after 1000
          housekeeping(State)
      end,
      chat_loop(NewState).

    register_name(State = #state { targets = Targets }, Name, Cfg) -&gt;
      State#state { targets = [ { Name, Cfg } | Targets ] }.
`
</code></pre>
<p>Or whatever. This is all fairly standard code and certainly there is nothing unusual in here that you&#39;d not expect to see in any old module from around the place. This is probably about 5% of the syntax of Erlang and you can start to see why a lot of people start to pick up Erlang via the medium of &quot;Learn Erlang for Great Good&quot; or something similar and after a week of syntax lessons throw their arms in frustration and exclaim &quot;What on earth is the point?&quot; and either switch to Elixir or something even worse (okay it&#39;s relative) like NodeJs.</p>
<p>No <em>real</em> type system, no polymorphism, hilariously inconsistent APIs for processing lists, queues, dictionaries (even within the list API itself it&#39;s not consistent with the argument orders etc), no real way of doing function composition or guaranteeing purity in functions (which means guard clauses can only use built-ins) and what you really have is a way of writing locally &quot;pure&quot; code across imperative operations on networks and filesystems.</p>
<h1 id="erlang-has-moving-parts">Erlang has moving parts</h1>
<p>How do you do releases? How do you build your application? How do you test it? How do you run it? What do you need for all of this to work? A quick scan of an &quot;empty&quot; project built from scratch just now on my machine contains:</p>
<ul>
<li>Makefile (for building stuff)</li>
<li>Relx (for releasing stuff)</li>
<li>sys.config (for configuring stuff)</li>
<li>relx.config (for configuring the release)</li>
<li>foo_app.src (a manifest for the application)</li>
<li>foo_app.erl (the application entry point)</li>
<li>foo_web.erl (a gen server for spinning up the web process hierarchy)</li>
<li>foo_sup.erl (a supervisor for managing the process hierarchy)</li>
<li>foo_config.erl (a little wrapper for accessing sys.config)</li>
<li>a &#39;deps&#39; folder containing &quot;gproc (process utils), lager (logging), cowboy (web)</li>
</ul>
<p>And a few other bits. This is astonishingly daunting and no amount of &quot;just use rebar&quot; will ever make that easy. I&#39;m generally against scaffolding because it allows awkward design to survive but you almost <em>need</em> to scaffold the basic Erlang application somehow because of all the bits you need to just spin it up. Contrast that to a simple node project with its app.js. node_modules and ... oh wait you can pretty much write something useful from this point and <em>discover as you go</em> while still building something tangible that somebody might want to use.</p>
<p>Oh, and unlike Clojure there is no real REPL (stop saying erl is a REPL or like a REPL because it really is not a REPL and it offers none of the same experiences you&#39;d expect from a REPL and nobody does applications which can be bootstrapped easily via a REPL and there is very little tooling support for talking to this from your editor so really it&#39;s nothing like Clojure omg stop you guys)</p>
<p>At this point the folk in the Erlang community reading this will be thinking &quot;but it&#39;s not quite like that - once you have a workflow it&#39;s all sensible enough&quot; or &quot;You don&#39;t need most of those things for an application really&quot; or &quot;why would you want to do things in a REPL anyway?&quot; or all sorts of self-deluding statements because they&#39;ve been blinded by some of the better things in Erlang and things like working and profitable products for years and that&#39;s sort of okay but in a way also really frustrating because it seems that after a few years of Erlang development Erlangers seem to forget just how awful some of the tools they&#39;re working with actually are.</p>
<h1 id="erlang-s-oss-is-moving-sands">Erlang&#39;s OSS is moving sands</h1>
<p>Every few months we decide we need to make http calls from our applications and we have to do the dance of working out which library is still being maintained or compiles in the current version of Erlang, ibrowse caused us issues until we switched to lhttpc but unicode and R17 really pissed us off and then lhttpc was deprecated so we looked at gun (which uses maps) but actually shotgun is a better wrapper but there is also fusco except that&#39;s not ready yet yes it&#39;s 2015 and we don&#39;t have a consensus on a http client. (Actually Gun is pretty neat and there are reasons to be re-writing http clients with the advent of http2 etc but okay this is a little frustrating and a small example of the ecosystem).</p>
<p>The language itself is still evolving and some libraries just stop working between releases, there aren&#39;t too many active users of most Erlang libs once you get out of the basic world of http and databases and you will find bugs and you&#39;ll have to fix those bugs and you&#39;ll have to invest time in doing that if you want to be effective in this world - so you&#39;ll need to be a competent Erlang developer to build an Erlang application but is that such a bad thing given that 90% of developers working in their chosen language are incompetent and at least we have this as a safeguard to keep that sort of person out? I really don&#39;t know I&#39;m just thinking out loud).</p>
<p>Oh - and every month I find another Erlang library that hasn&#39;t written their manifest properly so doesn&#39;t work in the releases that we build using relx and we&#39;re relying on dangling forks or commits of quite a few projects because nobody seems to be around to take our call for fixing them or merging our fixes.</p>
<p>It&#39;s not brilliant but...</p>
<h1 id="erlang-does-seem-to-work">Erlang does seem to work</h1>
<p>It doesn&#39;t just work, it excels. Once you&#39;ve fought and made peace with all of the above (and more) and you&#39;re using the bash scripts and makefiles that the rest of your company is using for automating the build/test/release process and you&#39;ve spent the time learning how all of it fits together then you can spend some time looking at supervision trees and process ownership and you realise that it&#39;s pretty hard to crash an Erlang application and leave anything open or dangling or in a weird state if you reasoned about your supervision structure at all.</p>
<p>OTP is pure wonder (gen_server, supervisors, applications etc) and the libraries that ship wth Erlang using the process model and underlying abstractions are battle-tested, stable and well thought out.</p>
<p>Consider that I can write the following code anywhere in any old gen server and if it fails (IE, write doesn&#39;t return &#39;ok&#39;, the entire process tree crashes and subject to the rules in the supervisor either will be restarted, kill siblings or parents or pass the error up automatically to the next supervision level and we&#39;ll have a log about all of this including the current state of the offending process and there won&#39;t be a dangling open handle to the file and a whole bunch of other useful &quot;none-artifacts&quot; that you&#39;d easily overlook if you hadn&#39;t put in the time to avoid them.</p>
<pre><code><span class="setting">ok = <span class="value">file:write(Handle, Bytes).</span></span>
</code></pre><p>Not having to dance around exceptional error cases in most file or networking scenarios and writing your code on top of these built-ins means you can spend more time writing the code you need to write for the feature itself (Okay admittedly if you&#39;ve gotten around the syntax issues). This philosophy and things like it hold true across the various libraries we use from across the ecosystem and mean we don&#39;t tend to get too many support calls at 2am because web servers have disappeared because something is locked, crashed, down permanently, corrupt or whatever.</p>
<p>Easy inter process communication means it is easy to build self-contained little workers around little balls of state and not worry about concurrency (most of the time) because everything is safe if you&#39;re following the happy path. Generally it also means that shifting cpu heavy stuff around our stack is easy because we can always take one of these processes and spin it up somewhere else. I mentioned that in Clojure we ended up with Actors in core.async but without error handling or safe handle management and here is the answer neatly packaged for us in a platform that has been around and battle-tested for 10x as long. Neat.</p>
<h1 id="but-what-about-elixir">But what about Elixir</h1>
<p>If I mention Erlang, this is always the first thing that comes up and it sorta annoys me. I have a few issues with Elixir and they&#39;re not really to do with the language itself because y&#39;know, I couldn&#39;t care less about syntax in general but I do care about philosophy/focus. It&#39;s irrational but here goes:</p>
<p>1) I&#39;ve worked in Ruby, the Ruby community might be friendly but they&#39;re mostly godawful developers and their tendency to overload operators with magic, or monkey patch internals or generally do any sort of meta-programming because ahahaaha lols made me almost quit programming altogether in frustration when I stared into that abyss for the duration of that job</p>
<p>2) Elixir comes from that background, with that sort of developer and now with ADDED MACROS (oh man no don&#39;t give these kids more metaprogramming tools)</p>
<p>You see - Clojure is allowed to have Macros because the rules of Macro club are clearly written down and stated as thus:</p>
<ul>
<li>Don&#39;t use Macros</li>
<li>Don&#39;t use Macros</li>
<li>Don&#39;t use Macros</li>
<li>Okay, re-write those rules - we&#39;re going to use Macros because our name is Rich Hickey</li>
</ul>
<p>This general sensibility means that you don&#39;t generally bring in libraries in Clojure and then have to wonder why everything in your application no longer works because somebody decided to re-define basic mathematical operators (for those not doing Ruby <em>yes this is actually a thing I don&#39;t know what even</em>).</p>
<p>Erlang doesn&#39;t cost us any money because we can&#39;t pretend records/maps are objects, we don&#39;t need that functionality. Erlang doesn&#39;t cost us money because we can&#39;t do meta-programming (actually we sorta can but sssh don&#39;t tell the Ruby devs) - and while the syntax might be ugly it isn&#39;t something that is a fundamental issue beyond the initial learning curve because you should be learning OTP, not the language. Putting the focus on that shiny language takes a lot of focus away from the things in Erlang that are actually <em>useful</em> as in the ode above. This is further chronicled by the sheer number of blog entries of &quot;Ruby vs Elixir&quot;, &quot;Node vs Elixir&quot; etc as if somehow the language is at all anything you should be interested in. I find it incredibly hard to trust Elixir, anything written <em>in</em> Elixir or anything written by the Elixir devs (see Ruby metaprogramming above).</p>
<p>The new and shiny detracts from the old and gnarly without really adding that much in tangible benefits and bringing in the hipster brigade who all totally missed the point when it came to the bit in the chapter &quot;What do you mean you can&#39;t re-assign variables&quot;.</p>
<p>If you&#39;re a great dev then you can probably be more effective in Elixir (probably), but bear in mind they&#39;re re-building all the shitty infrastructure around packaging management, build tools, scaffolding etc that it has been quite a relief to stay away from in this last year of doing Erlang (I&#39;ll cover this in the upcoming series). So thanks but no thanks - you are all incorrect in your thinking and I&#39;ll see you in a couple of years when you work that out for yourself.</p>
<h1 id="lfe">LFE</h1>
<p>An interesting idea, and we&#39;re looking at trialling it in our low value webby bits side by side with the Erlang (because it&#39;s not trying to do anything magic beyond offering a fairly simple syntax change - you know I love a good LISP). At the moment there are a pile of things that we&#39;d want in it (I found some issues the first six hours I jumped in and while Robert Virding is very fast at fixing them we&#39;d need to keep it in low value code while we helped grow the project).</p>
<p>Bonus: It&#39;s not being ran by Ruby script kiddies, so that&#39;s a Good Thing (tm).</p>
<h1 id="state-on-the-disinterest-curve">State on the disinterest curve</h1>
<p>Still not really that interested in Erlang, simply building things in it and enjoying it - this process is pretty mundane and perhaps that&#39;s what I&#39;ve been looking for all this time. I&#39;m going to throw in some more blog entries after this one covering how <em>we</em> build things in Erlang because we do things <em>our</em> way and I&#39;ve been asked about this a few times now. This should be fun.</p>
]]></description><link>http://codeofrob.com/entries/the-ashton-disinterest-curve---erlang.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-ashton-disinterest-curve---erlang.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 09 Mar 2015 10:30:00 GMT</pubDate></item><item><title><![CDATA[The Ashton Disinterest Curve - Clojure]]></title><description><![CDATA[<p>Do you like <em>anything</em> Rob? You said you were going to be nice and all you&#39;ve done is complain about <a href="/entries/the-ashton-disinterest-curve---c.html">.NET</a> and <a href="/entries/the-ashton-disinterest-curve---javascript-and-node.html">JS</a> so far. Point taken - let&#39;s talk about Clojure.</p>
<h1 id="an-ode-to-the-lisp">An ode to the lisp</h1>
<p><em>(parens (love (i)))</em>. I love s-expressions; code written in Clojure tends to be beautifully expressive thanks to the terseness and minimal syntax provided the humble s-expr. When you go on to add easy composition and a rich library of &quot;All the basic things you might want to do to a list or a key-value structure&quot; the magic starts to happen. The focus on data-oriented code that gave birth to that heavily re-usable core library and an emphasis on referential transparency means that things generally do just what you expect them to and you can usually just focus on the functionality that led you to open up an editor in the first place.</p>
<p>Speaking of editors, once you have your editor of choice set up with REPL integration, Paredit (if you want to edit expressions and not lines) and you&#39;ve downloaded the internet with Maven, the low syntastical burden of the language makes it ideal for hacking around in even for people who are new to the language. Spending evenings at the London Clojure Dojo was one of my favouite ways to use time as every week there would be new people to play with in whatever bizarre challenge had been set by the group.</p>
<p>That community was instrumental in keeping me going with the journey as I wrote <a href="http://robashton.github.io/cravendb/">CravenDB</a> and did my best to learn through that action. Over the year I wrote that I entered the top 100 committers on Github and entered the top five committers for Clojure itself. Being able to spend some time at <a href="/entries/the-use-of-clojure-in-the-cdec-open-health-data-platform.html">MastodonC</a> working on some unrelated OSS in Clojure was also an amazing experience and cemented my love of the humble paren and the people who wielded them.</p>
<p>Clojure is therefore a great gateway language in that it makes functional programming accessible to anybody with the JVM installed.</p>
<h1 id="concurrency">Concurrency</h1>
<p>Clojure had a goal of making concurrency on the JVM easy with its built in constructs for utilising STM. Atoms, agents and simple support for transactions meant that managing access to shared data structures was very simple indeed. Then core.async came along and pretty much took over every library and application I tried writing with it. Core.async definitely made the experience of writing Clojurescript more elegant given its hosting environment and the forced asynchronisity of the JavaScript world. Setting up your entire application as a series of communicating sequential processes around managable chunks of state is definitely something to be celebrated in that ecosystem.</p>
<p>This is where the love affair starts to unravel however as there is some amount of pain this world.</p>
<h1 id="the-pain">The pain</h1>
<p><em>Stack traces and errors</em>; Ever seen a Java stack trace? Now add a few more pages of scrolling for all the Java written to make Clojure possible (shudder) - now make those errors occur inside a core.async block and be amazed if anything useful gets  dumped out as your application ceases to work.</p>
<p><em>Start-up time</em>; build a real application, now it takes 30 seconds to start-up on my MBA before hitting any actual code. The ardent Clojurites therefore commit a great deal of time and energy avoiding ever having to bounce the REPL - indeed designing their entire systems around development from a REPL standpoint. That isn&#39;t such an awful thing because I really enjoyed the feedback loop that REPL-first development provides and keeping small parts of your system bootstrappable makes it easy to write tests when needed but having this start-up time on my pet database and having to re-engineer it around not wanting to bounce the REPL just felt awkward.</p>
<p><em>The real world</em>: Occasionally when programming it becomes useful to do things like read and write from files/sockets/etc. In Haskell we talk about Laziness requiring Purity, in most other places we&#39;re Strict and Impure (Unless you count the 100s of gloriously awful things done in the name of LINQ/C#). Clojure is both Lazy and Impure with no real control over where those side effects take place. You can call a seemingly pure function that calls a dozen other pure fuctions and at the bottom somebody is holding onto an atom just to spite you. That&#39;s a made up problem but replace that atom with a file handle and we start to have issues.</p>
<p><em>Types</em>: Or lack of; we&#39;re lazy and impure and we have no type system, combine that with a complete lack of decent error handling constructs and giant stack traces and say hello to wasting hours debugging problems if they&#39;re so cruel as to slip through your REPL driven development process. Yes there is core.typed which is a wonderful project but it makes Erlang&#39;s spec notation looks beautiful and completely ruins the elegance of the original code. A big bucket of nope.</p>
<p><em>JVM</em>: &#39;nuff said.</p>
<p>Rather than just repeat myself, there is a <a href="https://skillsmatter.com/skillscasts/6040-resource-management-in-clojure">10 minute video</a> and <a href="http://slides.com/robashton/resource-management-in-clojure">slides</a> of me trolling a Clojure conference with a talk on this very subject.</p>
<h1 id="the-path-towards-erlang">The path towards Erlang</h1>
<p>So okay; simplifying things a lot - you either need to pass file handles (or something that represents them, so handle handles) up to the users of your library for short lived access or wrap up long lived resources in core.async blocks to manage concurrent access to them.</p>
<p>This ends up looking like this (keeping most of the code out of the core.async block so it can be tested in the REPL easily)</p>
<pre><code><span class="list">(<span class="title">defn</span><span class="body"> go-index-head [_ {<span class="keyword">:keys</span> [command-channel] <span class="keyword">:as</span> engine}]
  <span class="list">(<span class="title">debug</span><span class="body"> <span class="string">"being asked to start"</span>)</span></span>
  <span class="list">(<span class="title">go</span><span class="body">
    <span class="list">(<span class="title">loop</span><span class="body"> [state <span class="list">(<span class="title">initial-state</span><span class="body"> engine)</span></span>]
    <span class="list">(<span class="title">if-let</span><span class="body"> [{<span class="keyword">:keys</span> [cmd data]} <span class="list">(<span class="title">&lt;</span><span class="body">! command-channel)</span></span>]
     <span class="list">(<span class="title">do</span><span class="body">
      <span class="list">(<span class="title">debug</span><span class="body"> <span class="string">"handling index loop command"</span> cmd)</span></span>
       <span class="list">(<span class="title">recur</span><span class="body"> <span class="list">(<span class="title">case</span><span class="body"> cmd
         <span class="keyword">:schedule-indexing</span> <span class="list">(<span class="title">main-indexing-process</span><span class="body"> state)</span></span>
         <span class="keyword">:notify-finished-indexing</span> <span class="list">(<span class="title">main-indexing-process-ended</span><span class="body"> state)</span></span>
         <span class="keyword">:new-index</span> <span class="list">(<span class="title">add-chaser</span><span class="body"> state data)</span></span>
         <span class="keyword">:chaser-finished</span> <span class="list">(<span class="title">finish-chaser</span><span class="body"> state data)</span></span>
         <span class="keyword">:storage-request</span> <span class="list">(<span class="title">storage-request</span><span class="body"> state data)</span></span>)</span></span>)</span></span>)</span></span>
      <span class="list">(<span class="title">do</span><span class="body">
        <span class="list">(<span class="title">debug</span><span class="body"> <span class="string">"being asked to shut down"</span>)</span></span>
        <span class="list">(<span class="title">wait-for-main-indexing</span><span class="body"> state)</span></span>
        <span class="list">(<span class="title">wait-for-chasers</span><span class="body"> state)</span></span>
        <span class="list">(<span class="title">close-open-indexes</span><span class="body"> state)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>
</code></pre><p>Basically re-invent actors but without decent error handling, supervision trees, named processes... So yeah - Clojure, glorious syntax, clever libraries, great data structures, but it&#39;s not Erlang for getting things done in the kind of projects I&#39;m working on at the moment.</p>
<h1 id="where-is-it-then-">Where is it then?</h1>
<p>I can&#39;t see myself using Clojure as a backend language on its own anytime soon. If I&#39;m forced to do something on the JVM (legacy integration, cross my fingers I haven&#39;t got to do that for a while) I can see myself using Clojure to integrate with the legacy syste and export data using the wonderful library Liberator.</p>
<p>I <em>can</em> see myself using Clojurescript rather than the mess that is JS if I have to do any higher value front-end code. (Some of the React wrappers look <em>amazing</em>) and it&#39;s a lot more professional than trying to bodge it together in a broken language. There is a project coming up next year that represents value on the front-end and I suspect it&#39;ll make an appearance there if I can persuade our editors to do sensible CLJS/REPL integration and I can persuade my colleagues to adopt a REPL driven development method on the front-end.</p>
<p><em>Position on the curve:</em> Still interested, I just don&#39;t have use for it at the moment.</p>
]]></description><link>http://codeofrob.com/entries/the-ashton-disinterest-curve---clojure.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-ashton-disinterest-curve---clojure.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 19 Dec 2014 09:30:00 GMT</pubDate></item><item><title><![CDATA[The Ashton Disinterest Curve - Javascript and Node]]></title><description><![CDATA[<p>So far on the &quot;making a point that I&#39;m not all bitterness and hatred&quot; over things tried in the past, I have managed to pretty much write the same <a href="/entries/the-ashton-disinterest-curve---c.html">negative diatribe about .NET</a> that everybody else seems to write after an age of bashing their head against the wall. (Note to naysayers: Maybe there is something to this after all, and no, the decision to OSS a bunch of .NET changes very little about the root problems found in most shops that choose that technology)</p>
<h1 id="i-digress">I digress</h1>
<p>Aaaanyway - when the crippling pain in my wrists got too bad, the first place I sought refuge was a combination of Linux + Vim + JavaScript.</p>
<p>I had always used JS and I had written some pretty cool things in it; It seemed like a natural progression if I wanted to carry on being paid decent money for developing software without having to immediately just drop everything and develop a new career from scratch. Sadly the need to integrate with the Visual Studio users (JS in project files, seriously piss off) eventually put an end to that attempt and I ended up doing node.js at actual node.js based development shops and accidentally ditching Windows forever.</p>
<p>I got a <em>lot</em> done in JS (both on client and server) and for a while really enjoyed writing software in it. A large part of this was because I was used to the type systems in C# and Java style languages and being able to develop software without needless layers of interfaces impeding my progress made feel very warm and fuzzy.</p>
<p>Obviously this came with the price of requiring many more tests, develop everything in self contained modules (not necessarily a bad thing) and dealing with some wildly varying opinions on what constituted &quot;readable JS&quot;.</p>
<p>The saving grace of this language was that it was still pretty untamed and the language had very few features to abuse; maintaining explicitness at the expense of terseness meant that you could fling together some relatively comprehensible systems rather quickly without too much forethought or trouble. Obviously my feelings on steps to &quot;improve&quot; JS are well known, Typescript, Dart and frameworks like Angular trying to treat JS as an actually sensible platform were akin to biblical efforts to build houses on sand or whatever parable you prefer for that purpose here.</p>
<h1 id="where-i-now-stand">Where I now stand</h1>
<p>Since starting to learn languages like Haskell and realising that type systems don&#39;t have to be burdemsone, since developing with Erlang/OTP and seeing first-hand what a sensible networking platform should look like, since learning Clojure and realising terseness doesn&#39;t have to come at the expense of understandability - JS has lost a lot of that initial appeal. Since acknowledging the value of &quot;hammock time&quot; and how certain languages can encourage the use of up-front reasoning I can see that the &quot;<em>just ship some code</em>&quot; mentality  found in the JS world is probably harmful to our long term survival as a professional industry.</p>
<p>It is a language that as an profession we should be pretty ashamed for letting become so popular; it is for cowboy developers writing cowboy systems and anybody setting out to build new applications on top of this (with the intention of longevity) should strongly reconsider. I think that the motivation of using JS to teach programming is understandable because of how accessible it can be to new people but it is also a mistake because it teaches the wrong message about our industry - it is the antithesis to professionalism. If we were ever in a &quot;race to the bottom&quot; then JS can be considered to have won; it has lowered the barrier to entry so far that we&#39;ll be dealing with the consequences of this mistake for decades to come.</p>
<p>For low value UIs, for hackdays, for gamejams, for rapidly building that proof of concept, for that minimal viable product I think that both JS and Node probably have their place. JS is an incredibly fun language to get shit done in providing that you don&#39;t plan on being responsible for that code two <s>years</s> weeks down the line. Every Ludum Dare that I write games for I pick up JS, put on a Stetson and arm myself with a whip and yell YEEHHAAWWW because I&#39;m a cowboy and I like to ride my horse without a saddle.</p>
<p>I <em>love</em> JS for this - despite its contradictions (and mine in this post), I can&#39;t think of any other language or platform where I can simply arm myself with a text editor and see results on my screen immediately in the form of shiny graphics and interactivity. While it is true that more professional languages would aid me in writing something that would be more formal and surviveable - just like writing tests, in the short term it would slow you down and diminish that immediate fun factor.</p>
<p>When we&#39;re are only dealing with the short term or we&#39;re happy that what we are writing is disposable (or just incredibly dull) then JS is a great language because it doesn&#39;t have any of the safeguards that any of the more professional languages or platforms do and as we all know - safeguards are for wusses.</p>
<p>Position on the curve: <em>Shrodingeresque - until directly observed you won&#39;t know if I love it or hate it.</em></p>
]]></description><link>http://codeofrob.com/entries/the-ashton-disinterest-curve---javascript-and-node.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-ashton-disinterest-curve---javascript-and-node.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 17 Nov 2014 09:30:00 GMT</pubDate></item><item><title><![CDATA[The Ashton Disinterest Curve - C#]]></title><description><![CDATA[<p>Kicking off this little series, we enter into the first language/platform I used professionally which is .NET  - I don&#39;t tend to make a secret of this history although I don&#39;t usually admit that I also spent a year writing VB.NET before switching to C# for most things. (This is true, and in some ways VB was actually better at the time)</p>
<h1 id="nothing-new-to-read-here-">Nothing new to read here...</h1>
<p>There is very little I can say negatively about C# and .NET that hasn&#39;t been said before but as I built a lot of software in it I&#39;d be remiss to ignore it in a series like this. The industry built up around it is probably my biggest beef when it comes to being irritated rather than the language and platform itself. The managers who are persuaded by salespeople that what they need is TFS and WCF and other TLAs and then development will be easy. The hordes of developers who blindly just use whatever Microsoft has provided because thinking for yourself is too hard. The tooling and environments that pretty much destroyed my wrists from the crappy mouse-driven UIs (Visual Studio and Windows) and the developers who tried to persuade me every year that &quot;things were changing or different now and it wasn&#39;t like that any more&quot;.</p>
<h1 id="the-software">The software</h1>
<p>Trying to step away from that environment and carry on using C# in a way that wasn&#39;t inside the tooling jail that Microsoft had built for us with esoteric combinations of OmniSharp and ctags and other such things always ended up as a war of attrition and the language itself seemed to be the personal playground for the designers to just stick anything in that people thought was cool two years beforehand. (The inevitable point where Scala and C# are almost the same language draws near...).</p>
<p>Then let&#39;s talk about that; the language started off as a simple Java clone (not starting out brilliantly when you consider the mess of factories and abstract bean providers in that world) and then tacked on layers of complexity solving problems that any real language simply doesn&#39;t have. One thing that moving onto pastures anew has taught me is that the solution to most things is rarely to add more features (and XML rarely solves anything other than data-interchange).</p>
<p>Yet in small projects once you had indeed fought the system and got your mono based development environment up and running C# wasn&#39;t too bad providing you stayed away from the dynamic keyword and frameworks and libraries with their layers of indirection and either over-design based on IOC container magic or lack of it entirely. Compared to other technologies that by default would just work in your choice of environments there just didn&#39;t seem to be enough benefit to justify the effort of getting to this point.</p>
<p>Yes - F# did and does still exist and it is a shining beacon in that world; it is going against the grain much like trying to use alternative environments is and finding a .NET job that <em>actually</em> does F# is like looking for a needle in a haystack. The fervour shown by its many adherents is admirable and I suspect were I forced to do .NET for a project (perhaps integration) this is what I would choose to use and even enjoy but I can&#39;t imagine this happening in the future given the direction my career/life ended up taking.</p>
<h1 id="the-community">The community</h1>
<p>The community and friends that I built up from my time in this pit <em>has</em> stayed with me ever since the beginning; in the same way that being trapped in a broken elevator can bring people together or being held hostage forces people to make connections with those around them - working in the .NET environment forced us to find nearby developers with similar experiences so we could have a few beers at the end of the working day and talk about our shared pains.</p>
<p>The constant aches pains and frustration also led to a lot of conversations about the basic acts of software development (most of it bike-shedding of course) but the constant arguments about tests, SOLID, interface-use and framework adoption and the push to constantly be improving is what pushed me off into different pastures in the first place. This kind of activity going on at community events everywhere even now and these entry level discussions have their use in helping developers to learn to move beyond the status quo and go further than &quot;just enough to make some cash&quot;.</p>
<p>Perhaps this kindergarten has its use, but we all have to grow up and it would be nice if that pain wasn&#39;t even needed.</p>
<p>Current position of .NET on the disinterest curve: <em>Bitter, bitter memories</em>.</p>
<p>Next up is JS/Node, I have nicer things to say about this - promise.</p>
]]></description><link>http://codeofrob.com/entries/the-ashton-disinterest-curve---c.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-ashton-disinterest-curve---c.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Wed, 12 Nov 2014 09:30:00 GMT</pubDate></item><item><title><![CDATA[The Exponential Ashton Disinterest Curve]]></title><description><![CDATA[<h1 id="the-catalyst">The catalyst</h1>
<p>I was lucky enough to be able to attend <a href="http://vimeo.com/111028823">Dan North&#39;s recent closing keynote at Oredev</a> in Sweden (and he was lucky enough to be played on by our last-minute rag-tag ukelele troupe).</p>
<p>It&#39;s worth checking out in its entirety as he&#39;s a wonderfully engaging speaker and there were some great stories told during this hour long closing speech.</p>
<p>At one point in the session when discussing passion and motivating people to try new things he made a few remarks concerning the &quot;Exponential Ashton Interest Curve&quot; or something to that end. The gist being that while he might not agree with the way I do it sometimes (Fair: I&#39;m don&#39;t agree with the way I do it sometimes either!), the passion and energy being expended by myself and others like me are what often fuel other people&#39;s interest to go along and start trying something out.</p>
<h1 id="the-curve">The curve</h1>
<p>Over the years many technologies and opinions have appeared on this blog and on the conference circuit as I discover something and decide they are worth discussing. The flipside of this of course is a general perception that once I stop talking about something the only time I&#39;ll ever mention it is if I want to talk about the things I didn&#39;t like about it.</p>
<p>  <blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/RobAshton">@RobAshton</a> it&#39;s been a few weeks since your talk on React, how much do you hate it now :p</p>&mdash; Chris McKee (@chrismckee) <a href="https://twitter.com/chrismckee/status/531830959596118016">November 10, 2014</a></blockquote>
  <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<p>I had more than a few jokes made at my expense on this subject over the next few days as I hung about at the Cheers Booth (The Jetbrains stand where everybody knows your name).</p>
<h1 id="-is-there-anything-you-ve-used-and-actually-like-rob-">&quot;Is there anything you&#39;ve used and actually like Rob?&quot;</h1>
<p>One of the big problems with launching yourself wholeheartedly into learning something deeply enough to do more than simply make a Pluralsight video about it (oof), is that you end up covering a <em>lot</em> of ground with the chosen technology. You internalise a lot of the good things and start storing up a list of the reasons that the technology wasn&#39;t such a good fit for the project you embarked on.</p>
<p>A good example of this is is the database I wrote in Clojure two years ago; shuffling binary data from the public endpoints into an unmanaged storage engine, the concurrency issues over the top of unmanaged resources and the event loops that ended up solving those problems led me to the conclusion that Erlang would have been a better fit for the task at hand. I say that freely when I give talks on Clojure because I think it&#39;s a good example of where Erlang would have shined. What I don&#39;t often mention in these talks is that I really liked working with the REPL (and I miss this every day in Erlang), I miss the polymorphism (Erlang&#39;s built in data structures and modules are a mess) and I miss the terseness of expressions written designed to perform logic around data.</p>
<p>Possibly because I&#39;m British, I tend to focus on the negative aspects of things that I&#39;ve used rather than the positive ones. I also find that in an industry where people constantly wave flags for whatever they&#39;re selling that being loud about the problems I&#39;ve had personally with those technologies helps keep beginners grounded in their expectations. If you&#39;ve ever talked to the Erlang crowd you&#39;ll have encountered the kool-aid addicts and know what I&#39;m talking about.</p>
<p>This tends to give the outward impression that I only like the things I&#39;m currently using and dislike everything else I&#39;ve ever used. In a break from my usual &quot;Urgh, all of this is crap&quot; spiel, let&#39;s have a look at an obvious example: How I currently feel about each language I&#39;ve used over the last decade and whether I actually do indeed hate my past decisions. (I&#39;ll ignore my brief Ruby phase, I couldn&#39;t find it in my heart to say anything nice about it).</p>
<p>First off will be C# (coming tomorrow). Originally I was going to write this as a single blog post but on hitting 3000 words I have decided to split it up into a single technology per entry... If anybody wants anything in particular covered that I&#39;ve gone off about over the last decade feel free to ask how I currently feel and I&#39;ll squeeze it in too.</p>
]]></description><link>http://codeofrob.com/entries/the-exponential-ashton-disinterest-curve.html</link><guid isPermaLink="true">http://codeofrob.com/entries/the-exponential-ashton-disinterest-curve.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Mon, 10 Nov 2014 09:30:00 GMT</pubDate></item><item><title><![CDATA[I done a keynote on learning dev etc]]></title><description><![CDATA[<p>Not a real blog entry (and I don&#39;t usually post when new videos come on) but it&#39;s such a rarity that I do a soft talk and I&#39;ve been told people like this one so...</p>
<p>I was asked to keynote At The Frontend (a new conference ran the day before Oredev by the organisers of Oredev) and this is what I came up with.</p>
<p><a href="http://vimeo.com/110972838">Learning/dev/etc</a></p>
<p>  <iframe src="//player.vimeo.com/video/110972838" width="500" height="300" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe> <p><a href="http://vimeo.com/110972838">Learning and the state of the web</a> from <a href="http://vimeo.com/user4280938">&Oslash;redev Conference</a> on <a href="https://vimeo.com">Vimeo</a>.</p></p>
<p>If you&#39;ve been drunk with me in the last few months I&#39;ll have talked about this crap anyway, but if you&#39;ve not then this is your chance to hear me waffle on about stuff that I&#39;ve realised in the last few months about how I&#39;ve wasted my last decade.</p>
]]></description><link>http://codeofrob.com/entries/i-done-a-keynote-on-learning-dev-etc.html</link><guid isPermaLink="true">http://codeofrob.com/entries/i-done-a-keynote-on-learning-dev-etc.html</guid><dc:creator><![CDATA[Rob Ashton]]></dc:creator><pubDate>Fri, 07 Nov 2014 09:30:00 GMT</pubDate></item></channel></rss>