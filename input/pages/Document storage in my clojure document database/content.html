<p>With core storage implemented, document storage becomes the trivial matter of a few pure functions</p>
<ul>
<li><a href="/entries/i-wrote-a-document-database-in-clojure.html">I wrote a Clojure document database</a></li>
<li><a href="/entries/the-client-api-for-my-clojure-document-database.html">The Client API for my Clojure document database</a></li>
<li><a href="/entries/the-http-api-for-my-clojure-document-database.html">The HTTP API for my Clojure document database</a></li>
<li><a href="/entries/the-core-storage-protocols-for-my-clojure-document-database.html">The core storage protocols for the Clojure document database</a></li>
<li><a href="/entries/the-leveldb-storage-for-my-clojure-document-database.html">LevelDB storage implementation for the Clojure document database</a></li>
<li><a href="/the-inmemory-storage-for-my-clojure-document-database.html">In-memory storage for the Clojure document database</a></li>
</ul>
<p><strong>What is a document</strong></p>
<p>A document in this database is going to be anything that can be deserialized into a clojure object (so binary edn). This includes</p>
<ul>
<li>Maps</li>
<li>Vectors/Lists/Etc</li>
<li>Primitives</li>
</ul>
<p>Often document databases assume some sort of &quot;id&quot; property as part of the document, but in experience this often ends up to be a hindrance as you end up having to implement conventions/etc deep inside the database for managing the id property. Leaving this to clients to figure out, it&#39;s much easier to simply associate a document with an id and keep the tracking of that id to the user (they&#39;re free to put it on the document however, if the structure supports it).</p>
<p>As part of each document, a version or synctag is kept (a global incremented number) - in the distributed set-up which I never got around to finishing, this would have been generated by the primary node - but regardless, it needs storing with each document.</p>
<p>For indexing, we also need to store a bunch of secondary indexes against each document so we can look them up by other means, without duplicating the data in storage.</p>
<ul>
<li>By Id</li>
<li>By Synctag (write order)</li>
<li>By Conflicts (in an MVCC set-up)</li>
<li>Document metadata</li>
</ul>
<p>Therefore, we keep a few built-in prefixes around to determine how these documents are stored</p>
<pre><code>(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> synctags-to-docs-prefix <span class="hljs-string">"synctags-to-docs-"</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> conflict-prefix <span class="hljs-string">"conflict-"</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> document-prefix <span class="hljs-string">"doc-"</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> last-synctag-key <span class="hljs-string">"last-synctag"</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> docs-to-metadata-prefix <span class="hljs-string">"docs-to-metadata-"</span>)</code></pre><p>Thus, writing is actually the addition of multiple entries to the underlying key-value store. I have a few helper methods for determining whether an entry in the underlying storage is a specific type of key/value pair. Note: I know, these are using reflection and I should be using the built in string methods - I never got around to updating this code :)</p>
<pre><code>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> is-document-key [<span class="hljs-comment">^String</span> k]
  (<span class="hljs-name">.startsWith</span> k document-prefix))
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> is-document-key-prefixed-with [prefix entry]
  (<span class="hljs-name">.startsWith</span> (<span class="hljs-name">entry</span> <span class="hljs-symbol">:k</span>) (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> document-prefix prefix)))
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> is-synctags-to-docs-key [k]
  (<span class="hljs-name">.startsWith</span> k synctags-to-docs-prefix))
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> is-synctag-docs-entry [m]
  (<span class="hljs-name">is-synctags-to-docs-key</span> (<span class="hljs-symbol">:k</span> m)))
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> is-conflict-entry [m]
  (<span class="hljs-name">.startsWith</span> (<span class="hljs-symbol">:k</span> m) conflict-prefix))
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> is-conflict-entry-for [m doc-id]
  (<span class="hljs-name">.startsWith</span> (<span class="hljs-symbol">:k</span> m) (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> conflict-prefix doc-id)))</code></pre><p>Storing a document is just a repeated application of chnages to the underlying transaction as described in previous entries</p>
<pre><code>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> store-document
  [db id document metadata]
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;</span></span> db
    (<span class="hljs-name">s/store</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> document-prefix id) document)
    (<span class="hljs-name">s/store</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> synctags-to-docs-prefix (<span class="hljs-symbol">:synctag</span> metadata)) id)
    (<span class="hljs-name">s/store</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> docs-to-metadata-prefix id) metadata)))</code></pre><p>Likewise, deletion is a similar story</p>
<pre><code>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> delete-document
  [session id metadata]
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;</span></span> session
    (<span class="hljs-name">s/delete</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> document-prefix id))
    (<span class="hljs-name">s/store</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> synctags-to-docs-prefix (<span class="hljs-symbol">:synctag</span> metadata)) id)
    (<span class="hljs-name">s/store</span> (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> docs-to-metadata-prefix id) metadata)))</code></pre><p>Not that while we delete the actual document and data, we associate this operation with metadata and a version regardless, we we can resolve this appropriately if a conflict arises.</p>
<p>Registration of conflicts is managed externally to all of this, and thus there is also a store-conflict function surfaced.</p>
<pre><code>(defn store-<span class="hljs-keyword">conflict</span> [db id document metadata]
  (s/store db (str <span class="hljs-keyword">conflict</span>-prefix id (:synctag metadata))
          {
            :id id
            :data document
            :metadata metadata }))</code></pre><p>Getting all the conflicts from the document storage, is just a matter of opening an appropriate iterator and reading entries until one is not a conflict</p>
<pre><code>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> conflicts
  ([db] (<span class="hljs-name">conflicts</span> db <span class="hljs-string">""</span>))
  ([db prefix]
      (<span class="hljs-name"><span class="hljs-builtin-name">with-open</span></span> [iter (<span class="hljs-name">s/get-iterator</span> db )]
        (<span class="hljs-name">s/seek</span> iter (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> conflict-prefix prefix))
        (<span class="hljs-name"><span class="hljs-builtin-name">doall</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> (<span class="hljs-name">s/as-seq</span> iter)
            (<span class="hljs-name"><span class="hljs-builtin-name">take-while</span></span> #(<span class="hljs-name">is-conflict-entry-for</span> %<span class="hljs-number">1</span> prefix))
            (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> <span class="hljs-symbol">:v</span>))))))</code></pre><p>This is not lazy, we can see a with-open block and a do-all, I guess if I&#39;d fleshed out the MVCC set-up then the iterator control would have been passed up to a higher layer.</p>
<p>For convenience, the documents also surface some convenience methods for reading through documents from a specific key or order. Unlike conflicts, these take in an iterator and it is assumed that the utiliser will take care of evaluation and the closing of that iterator in the appropriate manner.</p>
<pre><code>(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> iterate-documents-prefixed-with [iter prefix]
  (<span class="hljs-name">s/seek</span> iter (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> document-prefix prefix))
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> (<span class="hljs-name">s/as-seq</span> iter)
    (<span class="hljs-name"><span class="hljs-builtin-name">take-while</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> is-document-key-prefixed-with prefix))
    (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">comp</span></span> edn/read-string <span class="hljs-symbol">:v</span>))) )

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> iterate-synctags-after [iter synctag]
  (<span class="hljs-name">s/seek</span> iter (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> synctags-to-docs-prefix (<span class="hljs-name">next-synctag</span> synctag)))
  (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span> (<span class="hljs-name">s/as-seq</span> iter) (<span class="hljs-name"><span class="hljs-builtin-name">take-while</span></span> is-synctag-docs-entry) (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> <span class="hljs-symbol">:v</span>) (<span class="hljs-name">distinct</span>)))</code></pre><p>That&#39;s actually the entire implementation of document storage listed out in this blog entry. Clojure can be very terse at timess due to the data-oriented nature of this code - and in my opinion doesn&#39;t lose legibility in this case for that sake.</p>
<p>Note that all functions in this are actually pure, they take in one map, and return a new map with changes applied to it. (Or as pure as they can be, the underlying storage mechnism can do all sorts of weird things with atoms and we wouldn&#39;t even know.)</p>
<p><strong>Related Files</strong></p>
<ul>
<li>documents.clj</li>
</ul>
