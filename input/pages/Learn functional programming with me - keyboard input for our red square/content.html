<p>Now we have some enemies, let's add our player and see how we might achieve the handling of keyboard events to move him.</p>

<ul>
<li><a href="/entries/learn-functional-programming-with-me---a-mission-statement.html">Missing statement</a></li>
<li><a href="/entries/learn-functional-programming-with-me---drawing-a-square.html">Drawing a square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---moving-the-square.html">Moving the square</a></li>
<li><a href="/entries/learn-functional-programming-with-me---attributes-and-vectors.html">Attributes and vectors</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-my-workflow.html">Improving my workflow</a></li>
<li><a href="/entries/learn-functional-programming-with-me---adding-lots-more-state.html">Creating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---mutating-lots-of-state.html">Mutating lots of state</a></li>
<li><a href="/entries/learn-functional-programming-with-me---improving-our-data-structure-with-maps.html">Improving our data structure with maps</a></li>
</ul>

<p>Well, first off let's create the player</p>

<pre><code> :player (initPlayer 0 430 20 20)
</code></pre>

<p>Where</p>

<pre><code>(defn initPlayer [x y w h]
 {
  :x x
  :y y
  :w w
  :h h
 }
)
</code></pre>

<p>There are some similarities here between the player and the enemy, and perhaps I'll address that when I'm a position to tell how.</p>

<p>Now, I'll want to render that player, and I'm actually going to take the bold step of pulling out a render function so my main loop now looks like this:</p>

<pre><code>(defn tick [ctx state]
  (clearScreen ctx) 
  (renderScene ctx state)
  (js/setTimeout (fn []
    (tick ctx (doLogic state))
  ) 33  )
)
</code></pre>

<p>Just keeping things tidy!</p>

<pre><code>(defn renderScene [ctx state]
  (enemiesRender ctx state)
)

(defn enemiesRender [ctx state]
  (let [enemies (:enemies state)]
    (doseq [enemy enemies] 
      (let [{:keys [x y w h]} enemy]
        (drawSquare ctx x y w h)
      )
    )
  )
)
</code></pre>

<p>Right, so now I have a player, I may as well render it</p>

<pre><code>(defn renderScene [ctx state]
  (enemiesRender ctx state)
  (playerRender ctx state)
)

(defn playerRender [ctx state]
  (let [player (:player state)]
    (let [{:keys [x y w h]} player]
      (drawSquare ctx x y w h)
    )
  )
)
</code></pre>

<p>And I'll need to copy it across to the new state each iteration</p>

<pre><code>(defn doLogic [state]
  {
    :direction (directionLogic state)
    :enemies (enemiesLogic state)
    :player (:player state)
  }
)
</code></pre>

<p>Nothing new here, this'll just give me an additional yellow square on my canvas...</p>

<p><img src="/img/player_added.png" alt="An additional yellow square on a canvas" title="The player has been added"></p>

<p><strong>Handling those input events</strong></p>

<p>Now I want to move it though, and this is where things are going to get fun, from what I can <em>imagine</em> off the top of my head (I'm currently sat on a plane at 10,000ft with no internet so I can't look anything up), my options are:</p>

<ul>
<li>Attempt to mutate player state directly as input events happen</li>
<li>Keep some mutable state around to indicate whether certain keys are currently down, and apply these modifiers as part of logic</li>
</ul>

<p>I think I'm going to opt for the second one and see how that plays out. It kinda makes sense to me in ignorant-land that isolating areas of mutable state from my (currently quite) clean program will be helpful.</p>

<p>This is pretty much what the structure will look like:</p>

<pre><code>tick (state) =&gt;
  inputs = getCurrentInputs()
  tick applyLogic(state, inputs)
</code></pre>

<p>I don't have to care that behind that getCurrentInputs is some horrible interop with the browser and piles of mutability.</p>