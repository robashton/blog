[{"author":{"name":"Olle","avatar":"/images/IdenticonHandler.ashx?code=-1867858854"},"date":"(9/29/2011 7:13 AM)","text":"\r\n\t\t\t\t\tVery nice written Rob. You've managed to simplified the idea perfectly. Read it twice, now I'll push it to my co workers.\r\n\t\t\t\t"},{"author":{"name":"Kristof Claes","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=cdf5324ec8ff7cf76083192b64d1402c&size=50&default=identicon"},"date":"(9/29/2011 7:23 AM)","text":"\r\n\t\t\t\t\tThanks for the explanation Rob.There's one little thing that isn't really clear to me. The queries to generate view models, do you put them right where you need them? I'm hearing some people (like ayende) say \"Just put the read code in your controller\" but that seems to conflict with the SRP and the concept of thin controllers.What would be the typical way of doing something in an ASP.NET MVC application?\r\n\t\t\t\t"},{"author":{"name":"Paul Cowan","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=5b9872f3076db04cb2ffb516091d80d0&size=50&default=identicon"},"date":"(9/29/2011 9:13 AM)","text":"\r\n\t\t\t\t\tI think the main problem with DDD and CQRS is that they are misappropriately used.The vast majority of systems do not need this level of sophistication.  What is more worrying is that .NET has adopted CQRS as their new and shinny.  I shudder at people using either for CRUD but I suspect it does happen.These are specific situations for big distributed scenarios and not something to be shoe horned into most apps.The rule for full blown DDD and CQRS should be:If you don't have more than one bounded context then don't f'ing use it.What I am working on right now uses messaging and I have a domain model mapped to NHibernate with acompanying view models but I am by no means to CQRS or full blown DDD because what I am working on does not warrant the level of complexity of DDD or CQRS and would only add months onto completion.\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(9/29/2011 9:18 AM)","text":"\r\n\t\t\t\t\tPaul :: I couldn't agree more about the new and shiny and your problem with people  deciding they're \"going to do DDD or going to do CQRS\" without either understanding what those things are or why they might want them.However, I'm not sure that you actually read the article, because I'm sure that codeofrob.com/images/internal_codeofrob_com/2.png is too far away from the most basic thing you can do (even if you're just doing CRUD), and I'd classify that as CQRS (although Udi would disagree)  \r\n\t\t\t\t"},{"author":{"name":"Paul Cowan","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=5b9872f3076db04cb2ffb516091d80d0&size=50&default=identicon"},"date":"(9/29/2011 10:27 AM)","text":"\r\n\t\t\t\t\t@rob I read the article but I disagree that the architecture image is CQRS.  CQRS as explained by Udi and Greg young is about messaging and eventing across bounded contexts with long running sagas.The architecture in the image could all exist in the same box.  You do have a point though, maybe this architecture is way too complicated for CRUD.  You could also say maybe datasets are ideal for CRUD but I'm not sure I would go that far but you should question the logic behind every decision.I use messaging in my current scenario because the services are used by more than one product or website.  I feel I have the right justification for using messaging.  If this was one website or product using messaging then I still could argue that I have some long running tasks that outlive a basic web response and basic messaging might be justified as a way of facilitating long running tasks.As I said earlier, I am by no means doing CQRS or DDD.\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(9/29/2011 11:33 AM)","text":"\r\n\t\t\t\t\tOkay Paul,  I see where you are coming from - but disagree that CQRS is about messaging and eventing across bounding contexts although I know this is a point of discussion if you read the the e-mails between Greg/Udi here: groups.google.com/.../rasTHHmnzpoJMessaging and eventing across bounding contexts is a form of responsibility segregation certainly, but aren't necessarily the C and the Q being talked about here.HOWEVER, if we're going to get in a pickle over definitions rather than just doing the Right Thing and Building Software which is what your overriding desire seems to be anyway then we're in trouble anyway - I agree with everything you say apart from the definitions so um - that's pretty much all I can say :-)\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(9/29/2011 11:50 AM)","text":"\r\n\t\t\t\t\tKristof :: it's a rich man's problem that isn't really all that important, there is no \"do it this way\" answer. All that matters is that your code is readable, maintainable enough by other developers and testable/tested enough to meet the quality requirements set by the customer. This is a bullshit answer but it's kinda the way it is.In my ideal world the controllers wouldn't really exist and I'd have a pipeline that would end up with a command being handled or a query being returned,  I guess ala Fubu/OR.\r\n\t\t\t\t"},{"author":{"name":"Quooston","avatar":"/images/IdenticonHandler.ashx?code=-1041338090"},"date":"(9/29/2011 2:27 PM)","text":"\r\n\t\t\t\t\tI'm tired of propeller heads and their shiny toys. It's about DELIVERY FFS; leave the shiny toys at the door. The reality is that the very \"best\" developers are only enjoying themselves when they're playing with the toys, so this is what you get... complexity a-la hoopla for no bloody apparent reason. Drives me absolutely insane. I will see your \"oh so clever\" shite and raise you half the dev time and a happy customer any day. 99% of the time you don't need any of this, just be absolutely pragmatic and focus on delivery. If you can't deliver because you need to evolve, then evolve... pragmatically. And continue like so until you're out the door.D E L I V E R Y. \r\n\t\t\t\t"},{"author":{"name":"Simon Timms","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=932a90d841204bed64a5165e591c5332&size=50&default=identicon"},"date":"(9/29/2011 2:30 PM)","text":"\r\n\t\t\t\t\tI have to agree with Rob's assessment of messaging being largely unnecessary, at least when we define messaging as an out of process activity. It is perfectly possible, even desirable, to implement CQRS as a single process and even set it up to be synchronous. Just as there are maturity models for REST I see there being maturity models for CQRS with the lowest level being synchronous processing of requests. As we move up the maturity model we add things like message queues, message distribution and subscription technologies like NServicebus, snapshotting and event storage. One certainly needs to pick and choose where to apply CQRS as not everything is a nail. However I find myself at odds with some people's argument that CQRS should only be used in collaborative domains as I think there are other advantages which make it applicable in other situations. For instance having a dedicated read model allows for some nifty data-warehouse updating tricks. \r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(9/29/2011 7:29 PM)","text":"\r\n\t\t\t\t\tQoosten - did you even read the blog entry?\r\n\t\t\t\t"},{"author":{"name":"John[no] Nolan","avatar":"/images/IdenticonHandler.ashx?code=-1546346485"},"date":"(9/29/2011 8:24 PM)","text":"\r\n\t\t\t\t\tFinally had time to digest this. The 'heavyweight' comments I made on twitter were exactly all that eventing, messaging over BCs. The reason why the normal BOL /BLL/DAL/DAO/ OCKS seems less complex is because it is a nice linear power point slide (which is less scary for everyone). AS soon as you get into a dual set of models, it is adding complexity (which is more scary).What I think you describe is just a good design. When I've read about CQRS (with DDD) it is normally Enterprise grade and I've never seen the point in using it.\r\n\t\t\t\t"},{"author":{"name":"Alex Hoffman","avatar":"/images/IdenticonHandler.ashx?code=934556682"},"date":"(9/29/2011 9:38 PM)","text":"\r\n\t\t\t\t\tI also think it's too complex. Part of the issue in my opinion is that CQRS suffers from a \"high pattern dependency\" smell - http://bit.ly/riHX4v\r\n\t\t\t\t"},{"author":{"name":"David","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=aab1c1ea88105b195b5ca80a6b98caf0&size=50&default=identicon"},"date":"(9/30/2011 12:44 AM)","text":"\r\n\t\t\t\t\tThanks, I think this is a helpful way of looking at an inconsistently defined term.I don't really get the \"shiny toy\" responses, or the blanket \"too complex\" responses, and I wonder if they're written in response to the title rather than the article.CQRS can get complex but the first level described here essentially involves using sql or some intentionally simple mechanism to drive some of your views.  What exactly is shiny or complicated about that?\r\n\t\t\t\t"},{"author":{"name":"Dennis Doomen","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=c75b18c04d16ab75f92a876d186cbc44&size=50&default=identicon"},"date":"(9/30/2011 7:20 AM)","text":"\r\n\t\t\t\t\tAre you suggesting that Udi's excellent depiction of how a fullblown CQRS/ES architecture should look like is crap?\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(9/30/2011 7:24 AM)","text":"\r\n\t\t\t\t\tNo - where do you get that impression?\r\n\t\t\t\t"},{"author":{"name":"Quooston","avatar":"/images/IdenticonHandler.ashx?code=-1041338090"},"date":"(10/1/2011 4:05 AM)","text":"\r\n\t\t\t\t\t@robashton I'm all for CQRS and event sourcing, but I think you need justification before applying that layer of inherent complexity. I don't like people knee-jerking to every pattern they've read just because it exists instead of focusing on providing value to the paying customer... which is what I was trying to say.Came across a bit strong perhaps... it had been a tough day after dealing with a pattern obsessed, self proclaimed \"legend\"...\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(10/4/2011 10:31 AM)","text":"\r\n\t\t\t\t\tAnd I'm asking where you think the inherent complexity is in any of the examples (in the context in they're presented) - most of my entry talks  the lack of complexity, and how each progression towards having more technological complexity seeks to address the accidental complexity that occurs in the level below once you reach a certain threshold.I either think you didn't read my blog entry and just decided to rant because of the title, or you've misunderstood everything in it - the latter I can fix if you tell me how exactly ;-)\r\n\t\t\t\t"},{"author":{"name":"Alexander","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=51a1a1af759c9075f2dd2bdac618cfed&size=50&default=identicon"},"date":"(10/13/2011 6:28 PM)","text":"\r\n\t\t\t\t\tThat is super information! Thanks for sharing! I’m going to Tweet about your blog.\r\n\t\t\t\t"},{"author":{"name":"Tim Van Wassenhove","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=28480231d273cc0b69eb8b664b52b4cc&size=50&default=identicon"},"date":"(10/29/2011 7:36 PM)","text":"\r\n\t\t\t\t\tI think CQRS is all about simplification instead of sophistication..It is a lot easier to apply divide and conquer on a code base. One part is responsible for the reads (Q) and another part is responsible for the writes (C).In 'traditional' architectures you end up with one model that has to cater both read AND write, which usually leads to a model that is at least suboptimal for one  of both tasks (in my experience, usually the read side).In the spirit of the GNU text utilities, I prefer a lot of tools that each do one thing (and one thing only) very well, than one big tool that tried to do all things.. \r\n\t\t\t\t"},{"author":{"name":"Mike McG","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=271a3b15fe64293d1d1047b64cfdaa09&size=50&default=identicon"},"date":"(11/1/2011 4:04 PM)","text":"\r\n\t\t\t\t\tThis is a much-needed article that should help to combat the latest round of cargo cult programming in .NET. Dahan/Young have cultivated a particular, highly-complex definition of CQRS (DDD + event sourcing + messaging) which the .NET masses have met with either unbridled adoration and awe, or with complete rejection, neither of which is appropriate. The conclusion of this article (as I read it) is very subtle to them. To emphasize, * CQRS itself does not directly require DDD patterns, event sourcing, asynchronous messaging, message buses, eventual consistency, multiple data stores, field-based notifications, compensating events, SQL+ORM, NoSQL, etc etc etc; * relative to a single domain model, in it's simplest form CQRS is *no more complex*.These nuances are difficult to accept for those who believe they already understand (i.e. have been indoctrinated). This is clearly demonstrated by several commenters of your carefully presented article, who seem to directly refute that CQRS can be as simple as you've described. This is bothersome, as is the general historical tendency for .NET developers to exhibit a cult-like lack of critical analysis, *both in terms of SOLID and design fundamentals, as well as in more holistic terms such as maintainability, business value, learning curve, etc.*To very briefly speculate, the economic ecosystem of the .NET stack invites a different developer community than that of, say, Java or Haskell. Deploying .NET requires significant fiscal outlay, so the primary audience is business (whose needs are typically shorter-termed). Many other stacks do not have this barrier, and therefore permit a larger proportion of academics within the community. *Crucially, this leads to a more skeptical overall developer culture,* in which formulations of CQRS like Dahan's would be more thoroughly scrutinized and appropriately contextualized. Instead, the lower degree of skepticism in the .NET community permits such voices of confidence and novelty to be accepted widely, regardless of their accuracy.Well-written and rational article; thank you.\r\n\t\t\t\t"},{"author":{"name":"Psyllos","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=d4c43a6959e90c1dfe2cda7178b7d94f&size=50&default=identicon"},"date":"(11/3/2011 4:04 PM)","text":"\r\n\t\t\t\t\tI have some difficulty to imagine how to deal with some information in a CQRS architecture. Typically, if I want store information about a Portable Contact. There is a lot of description into this type of document. What are commands that are involved and especially their parameters? In other words, should I create as many commands as properties of this contact? How about the creation command?I can not understand the granularity of commands to create, and I can found a more complex example in the CQRS resources.\r\n\t\t\t\t"},{"author":{"name":"Ryan","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=71509c133412b51803153871a8de560b&size=50&default=identicon"},"date":"(11/3/2011 6:49 PM)","text":"\r\n\t\t\t\t\tCQRS solves the problem of data over time.  Because you're implicitly logging all mutations/actions across your domain, you always have a full audit trail and the ability to restore the system to an earlier state.For some domains that alone is reason enough to apply the pattern.\r\n\t\t\t\t"}]