[{"author":{"name":"David Padbury","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=95e2b8ef6039d2668114cfb20cf45ae2&size=50&default=identicon"},"date":"(3/17/2011 12:09 PM)","text":"\r\n\t\t\t\t\tpaulirish.com/... ?\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(3/17/2011 12:20 PM)","text":"\r\n\t\t\t\t\tThanks Dave, I haven't seen that.For plain ol' animations that looks useful, but if you were in a multi-player environment (which is what I'm focusing on here), it wouldn't give you your ticks - and tabbing away would leave you in an invalid state on returning. (You'd have to rapidly run all the ticks and logic, or do a big state re-sync on returning to the tab).It could feasibly be used *alongside* a logic loop like this, and you could de-couple rendering and logic ticks even more by having completely separate timers for them both. Then you'd still be running some logic behind the scenes when tabbing away, but not rendering.\r\n\t\t\t\t"},{"author":{"name":"Patrik Potocki","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=4a6ae4c1b1752bfc78cb06d3ae4f774b&size=50&default=identicon"},"date":"(3/17/2011 2:43 PM)","text":"\r\n\t\t\t\t\tNothing about this post , but your code doesnt show up in ex. google reader\r\n\t\t\t\t"},{"author":{"name":"Rob Ashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(3/17/2011 3:34 PM)","text":"\r\n\t\t\t\t\tYeah - I've switched to using Gists from Github, and that'll unfortunately be a side effect of that. They're much nicer though.\r\n\t\t\t\t"},{"author":{"name":"Frank Quednau","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=2dfe31131d62b675b10d7b02284d5303&size=50&default=identicon"},"date":"(3/18/2011 8:56 AM)","text":"\r\n\t\t\t\t\twww.shacknews.com/.../quake-3-132-source-codeAddmittedly, it's a long stretch from a javascript engine to Quake3, but if somebody knows one or two things about writing decent network code for games it should be idsoftware. As far as I know you are no complete stranger to C++..? :)\r\n\t\t\t\t"},{"author":{"name":"Rob Ashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(3/18/2011 9:08 AM)","text":"\r\n\t\t\t\t\tHah, I think by the time that kind of system gets to release, there is so much micro-optimisation that learning the fundamentals via the code might be a tad difficult.But yeah, I've got the code and I've even looked through it once or twice in the past :-)\r\n\t\t\t\t"},{"author":{"name":"Drew Petersen","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=4b138a56fa1e625a8b59a128519c7b64&size=50&default=identicon"},"date":"(3/21/2011 5:21 PM)","text":"\r\n\t\t\t\t\tRob, I'm glad to see someone else trying to tackle this extremely complex issue in JS!A few things:1) It might just be because it's a gist and out of context, but you've got some scoping issues in your less naive approach. The \"this\" inside of the tick method will point at the global scope, and thus this._leftover is really pointing at window._leftover, which is... bad. You're probably aware of this, but it might help others to be more clear, even if the only step is to put everything into a namespace.2) I am dying to know if this solves your problem. It seems to me, as an inexperienced network game-programmer, that this can't solve the synchronization problem on its own. For that, you have to rely on a central server broadcasting state changes, and only rely on the client for input and rendering (and effectively detach rendering from the world state). Otherwise, there's really no way to keep a much slower machine in sync. For example, a computer that can only do 20fps will always be behind in terms of the game's state. Think of that computer trying to shoot another player: it reports, \"I shot him!\" but when the server attempts to double check the result, the actual state of the world at that moment was further in time than what the slow client saw. You have to deal with computational lag as well at network lag!I've attempted my own version of a game loop (I call it the CGLM), which is in this gist: https://gist.github.com/879814. Maybe it will help, maybe it won't. One thing, my loop is geared towards use with a physics engine. I plan to integrate Paul Irish's snippet into the CGLM when I have some time.\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(3/21/2011 5:27 PM)","text":"\r\n\t\t\t\t\tOh yeah - I stole it from a properly name-spaced version in one of my other projects and didn't think that the code might not match up ;-) - I'll fix it when I get back.Your other question - of course it doesn't answer the whole question, you can't expect all game clients to magically \"keep up\", and you're going to have to sync the observables from time to time - but what you want is a common language of time from which they can communicate, so you can replay events at the right tick, and talk in terms of both state and actions :-)On the client that only does 20FPS, the logic above will ensure that the actual 'ticks' are still running at 30 ticks per second (catch-up frames), if of course you can't do the actual _logic_ at the desired 30 ticks per second then you can't play the game, at which point there is nothing you can do. That's why games have requirements after all :-)In reality, you'll have all the clients running their logic at 30 ticks per second, and the server running its logic at 30 ticks per second, and the server will distribute the state of observables, overriding the state of the clients (but allowing the clients to then add on any other events since the sync point (measured in ticks).TL;DR - ticks give you a common language for 'time elapsed', it's only half the story.\r\n\t\t\t\t"},{"author":{"name":"Drew Petersen","avatar":"/images/IdenticonHandler.ashx?code=-1517229333"},"date":"(3/22/2011 3:55 PM)","text":"\r\n\t\t\t\t\tBut if the logic is too much for the client to handle at 30fps, then it will just spiral out of control for a 20fps client, trying to catch up. Each tick will require more and more catch up ticks and will just beachball the client for longer and longer periods until the browser's limit is reached.I look at a game like world of warcraft. On my old laptop, it would only get 20fps, but was still playable because the rendering and logic were disconnected.Like I said before, my experience has been in physics simulations that are pretty intense for the client, so this might not apply to most games.\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(3/24/2011 9:37 AM)","text":"\r\n\t\t\t\t\tThat's the point, rendering and logic ARE disconnected this with scenario - if your logic CAN'T be ran at the desired number of ticks per second, then your computer is not good enough.The bottleneck in your WoW game is most likely the rendering, and the logic is being ran using fixed time steps as above so everything remains sane when it does render.\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(3/24/2011 9:42 AM)","text":"\r\n\t\t\t\t\tYou only have one thread in Javascript, even if you put Rendering in a separate setInterval, you'd still potentially be taking longer than a 30th of a second before your logic was run.When it comes to the physics, and logic - some systems will only run those intensive operations say, 5-10 times a second, and then tween between the positions/logic results - stop talking about frames per second, and think about* The time it takes for a frame to render* The time it takes to run a single step of logicI hope this is clearer.\r\n\t\t\t\t"}]