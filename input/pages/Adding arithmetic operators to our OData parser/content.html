<p>I&#39;m finally reaching the point where I can parse most of the OData conventions for Uris, which is nice!</p>
<p>A re-cap of where we are so far.</p>
<ul>
<li><a href="/entries/building-a-basic-json-parser-in-ometa.html">Learning OMeta through JSON</a></li>
<li><a href="/entries/building-an-odata-parser-in-ometa.html">Introduction to the OData Parser</a></li>
<li><a href="/entries/writing-an-odata-parser---starting-at-the-beginning.html">First steps in writing the OData Parser</a></li>
<li><a href="/entries/parsing-odata---nested-resource-paths.html">Nested resource paths in OData</a></li>
<li><a href="/entries/parsing-odata---service-operations.html">Service operations in OData</a></li>
<li><a href="/entries/the-odata-parser---applying-modifiers-to-our-query.html">Query options in OData</a></li>
<li><a href="/entries/paging-support-in-our-odata-parser.html">Paging support in OData</a></li>
<li><a href="/entries/our-odata-parser---looking-at-filterby.html">Filtering support in OData</a></li>
<li><a href="/entries/recursive-expression-parsing-in-our-odata-filter-parser.html">Recursive query support in OData</a></li>
<li><a href="/entries/these-are-not-the-results-you-are-looking-for---odata-parser.html">&#39;Not&#39; support for OData</a></li>
</ul>
<p>Wowsers, talk about an accidental blog series...</p>
<p><strong>Arithmetic operators</strong></p>
<p>What were they again?</p>
<pre><code>Add        Addition                /Products?<span class="variable">$filter</span>=Price add <span class="number">5</span> <span class="keyword">gt</span> <span class="number">10</span>
Sub        Subtraction             /Products?<span class="variable">$filter</span>=Price <span class="sub"><span class="keyword">sub</span> 5 gt 10
Mul        Multiplication          /Products?$filter=Price mul 2 gt 2000
Div        Division                /Products?$filter=Price div 2 gt 4
Mod        Modulo                  /Products?$filter=Price mod 2 eq 0</code></pre>
<p>Ah yes,</p>
<p>Now, these are all the same, but operator precedence is important so the order in which we want to go through them is:</p>
<ul>
<li>Add/Sub</li>
<li>Mul/Div/Mod</li>
</ul>
<p>This is very similar to how we implemented And/Or although I&#39;ll write a few tests to make sure I get it right.</p>
<pre><code>test(<span class="string">"/some/resource?$filterby=Price add 5 gt 10"</span>, <span class="string">"OData"</span>, function(<span class="constant">result</span>) {

  <span class="keyword">it</span>(<span class="string">"A filter should be present"</span>, function() {
     assert.notEqual(<span class="constant">result</span>.options.$filterby, null)
  })
  <span class="keyword">it</span>(<span class="string">"Filter should be an instance of 'gt'"</span>, function() {
     assert.<span class="keyword">equal</span>(<span class="constant">result</span>.options.$filterby[<span class="number">0</span>], <span class="string">"gt"</span>)
  })
  <span class="keyword">it</span>(<span class="string">"lhr should be Price add 5"</span>, function() {
     var rhs = <span class="constant">result</span>.options.$filterby[<span class="number">1</span>] 
     assert.<span class="keyword">equal</span>(rhs[<span class="number">0</span>], <span class="string">"add"</span>)
     assert.<span class="keyword">equal</span>(rhs[<span class="number">1</span>].<span class="property">name</span>, <span class="string">"Price"</span>)
     assert.<span class="keyword">equal</span>(rhs[<span class="number">2</span>], <span class="number">5</span>)
  })
  <span class="keyword">it</span>(<span class="string">"rhr should be 10"</span>, function() {
     assert.<span class="keyword">equal</span>(<span class="constant">result</span>.options.$filterby[<span class="number">2</span>], <span class="number">10</span>)
  })
})</code></pre>
<p>This tells us that our &#39;add&#39; operator has higher precedence than the comparisons (which makes sense). This&#39;ll mean we want to sneak it in somewhere after those comparisons. (Assuming in this scheme that And/Or have a higher precedence than add, and it seems to be that way)</p>
<pre><code>FilterLogicalExpression =
  FilterLogicalExpression:lhs
  FilterByOperand:op
  FilterAddExpression:rhs -&gt; [op, lhs, rhs ]
| FilterAddExpression
,

FilterAddExpression =
  FilterAddExpression:lhs
  FilterAddOperand:op
  FilterByValue:rhs -&gt; [ op, lhs, rhs ]
| FilterByValue
,
FilterAddOperand =
  spaces
  (
    se<span class="string">q("add")</span>
  | se<span class="string">q("sub")</span>
  ):op 
  spaces -&gt; op
,</code></pre>
<p>Simples, we insert it in the pipeline between &quot;LogicalExpression&quot; and &quot;Checking the value&quot; (Literal values have the highest precedence because they don&#39;t require any work)</p>
<p>And because Mul/etc have a higher precedence than Add, this exactly the same</p>
<pre><code>test(<span class="string">"/some/resource?$filterby=Price mul 5 gt 10"</span>, <span class="string">"OData"</span>, function(<span class="constant">result</span>) {

  <span class="keyword">it</span>(<span class="string">"A filter should be present"</span>, function() {
     assert.notEqual(<span class="constant">result</span>.options.$filterby, null)
  })
  <span class="keyword">it</span>(<span class="string">"Filter should be an instance of 'gt'"</span>, function() {
     assert.<span class="keyword">equal</span>(<span class="constant">result</span>.options.$filterby[<span class="number">0</span>], <span class="string">"gt"</span>)
  })
  <span class="keyword">it</span>(<span class="string">"lhr should be Price add 5"</span>, function() {
     var lhs = <span class="constant">result</span>.options.$filterby[<span class="number">1</span>] 
     assert.<span class="keyword">equal</span>(lhs[<span class="number">0</span>], <span class="string">"mul"</span>)
     assert.<span class="keyword">equal</span>(lhs[<span class="number">1</span>].<span class="property">name</span>, <span class="string">"Price"</span>)
     assert.<span class="keyword">equal</span>(lhs[<span class="number">2</span>], <span class="number">5</span>)
  })
  <span class="keyword">it</span>(<span class="string">"rhr should be 10"</span>, function() {
     assert.<span class="keyword">equal</span>(<span class="constant">result</span>.options.$filterby[<span class="number">2</span>], <span class="number">10</span>)
  })
})</code></pre>
<p>Like so</p>
<pre><code><span class="constant">FilterAddExpression</span> =
  <span class="constant">FilterAddExpression</span><span class="symbol">:lhs</span>
  <span class="constant">FilterAddOperand</span><span class="symbol">:op</span>
  <span class="constant">FilterMulExpression</span><span class="symbol">:rhs</span> -&gt; [ op, lhs, rhs ]
| <span class="constant">FilterMulExpression</span>
,

<span class="constant">FilterMulExpression</span> =
  <span class="constant">FilterMulExpression</span><span class="symbol">:lhs</span>
  <span class="constant">FilterMulOperand</span><span class="symbol">:op</span>
  <span class="constant">FilterByValue</span><span class="symbol">:rhs</span> -&gt; [ op, lhs, rhs ]
| <span class="constant">FilterByValue</span>
,</code></pre>
<p>Now what I actually have to do is define operator precedence for mul/div etc independently. So I can&#39;t actually cheat and do</p>
<pre><code>FilterMulOperand =
  spaces
  (
    se<span class="string">q("mul")</span>
  | se<span class="string">q("div")</span>
  | se<span class="string">q("mod")</span>
  ):op 
  spaces -&gt; op
,</code></pre>
<p>Like I have been doing, or when I write the following test, it will fail.</p>
<pre><code>test(<span class="string">"/some/resource?$filterby=Price div Price mul 5 gt 10"</span>, <span class="string">"OData"</span>, function(<span class="constant">result</span>) {
    console.<span class="command">log</span>(JSON.stringify(<span class="constant">result</span>))

  <span class="keyword">it</span>(<span class="string">"A filter should be present"</span>, function() {
     assert.notEqual(<span class="constant">result</span>.options.$filterby, null)
  })
  <span class="keyword">it</span>(<span class="string">"Filter should be an instance of 'gt'"</span>, function() {
     assert.<span class="keyword">equal</span>(<span class="constant">result</span>.options.$filterby[<span class="number">0</span>], <span class="string">"gt"</span>)
  })
  var lexpr = <span class="constant">result</span>.options.$filterby[<span class="number">1</span>] 

  <span class="keyword">it</span>(<span class="string">"should be Price div {expr}"</span>, function() {
    assert.<span class="keyword">equal</span>(lexpr[<span class="number">0</span>], <span class="string">"div"</span>)
    assert.<span class="keyword">equal</span>(lexpr[<span class="number">1</span>].<span class="property">name</span>, <span class="string">"Price"</span>)
  })

  <span class="keyword">it</span>(<span class="string">"should be Price mul 5"</span>, function() {
    assert.<span class="keyword">equal</span>(lexpr[<span class="number">2</span>][<span class="number">0</span>], <span class="string">"mul"</span>)
    assert.<span class="keyword">equal</span>(lexpr[<span class="number">2</span>][<span class="number">1</span>].<span class="property">name</span>, <span class="string">"Price"</span>)
    assert.<span class="keyword">equal</span>(lexpr[<span class="number">2</span>][<span class="number">2</span>], <span class="number">5</span>)
  })

  <span class="keyword">it</span>(<span class="string">"rhr should be 10"</span>, function() {
     assert.<span class="keyword">equal</span>(<span class="constant">result</span>.options.$filterby[<span class="number">2</span>], <span class="number">10</span>)
  })
})</code></pre>
<p>What will happen here is we&#39;ll get</p>
<pre><code>[
  'gt',
  [
    'mul',
    [
      'div', 'Price', 'Price'
    ],
    <span class="number">5</span>
  ],
  <span class="number">10</span>
]</code></pre>
<p>When what we clearly want is</p>
<pre><code>[
  'gt',
  [
    'div',
    'Price',
    [
      'mul', 'Price', '<span class="number">5</span>'
    ]
  ],
  <span class="number">10</span>
]</code></pre>
<p>Or if you like</p>
<pre><code><span class="list">(<span class="body"> <span class="list">(<span class="title">price</span><span class="body"> / price)</span></span> <span class="variable">* 5 ) &gt; 10</code></pre>
<p>Instead of</p>
<pre><code><span class="list">(<span class="body"> Price / <span class="list">(<span class="title">price</span><span class="body"> <span class="variable">* 5)  ) &gt; 10</code></pre>
<p>Which is a little bit different to say the least!</p>
<p>So, explicit operation order is what we want, and here is how get it:</p>
<p><strong>One massively explicit set of operator precedences...</strong></p>
<pre><code>FilterByOption = 
  se<span class="string">q("<span class="variable">$filterby</span>=")</span>
  FilterByExpression:expr -&gt; { name: <span class="string">"<span class="variable">$filterby</span>"</span>, value: expr }
,

FilterByExpression =
  FilterAndExpression
,</code></pre>
<p><em>And is the least important in our hierarchy</em></p>
<pre><code><span class="constant">FilterAndExpression</span> =
  <span class="constant">FilterAndExpression</span><span class="symbol">:lhs</span>
  <span class="constant">FilterAndOperand</span><span class="symbol">:op</span>
  <span class="constant">FilterLogicalExpression</span><span class="symbol">:rhs</span> -&gt; [ op, lhs, rhs ]
| <span class="constant">FilterLogicalExpression</span>
,</code></pre>
<p><em>Followed by any logical expression</em></p>
<pre><code><span class="constant">FilterLogicalExpression</span> =
  <span class="constant">FilterLogicalExpression</span><span class="symbol">:lhs</span>
  <span class="constant">FilterByOperand</span><span class="symbol">:op</span>
  <span class="constant">FilterAddExpression</span><span class="symbol">:rhs</span> -&gt; [op, lhs, rhs ]
| <span class="constant">FilterAddExpression</span>
,</code></pre>
<p><em>Then we descend through our mathematical operators in reverse precedence order</em></p>
<pre><code>FilterSubExpression =
  FilterSubExpression:lhs
  spaces se<span class="string">q("sub")</span> spaces
  FilterAddExpression:rhs -&gt; [ <span class="string">"sub"</span>, lhs, rhs ]
| FilterAddExpression
,

FilterAddExpression =
  FilterAddExpression:lhs
  spaces se<span class="string">q("add")</span> spaces
  FilterModExpression:rhs -&gt; [ <span class="string">"add"</span>, lhs, rhs ]
| FilterModExpression
,

FilterModExpression =
  FilterModExpression:lhs
  spaces se<span class="string">q("mod")</span> spaces
  FilterDivExpression:rhs -&gt; [ <span class="string">"mod"</span>, lhs, rhs ]
| FilterDivExpression
,
FilterDivExpression =
  FilterDivExpression:lhs
  spaces se<span class="string">q("div")</span> spaces
  FilterMulExpression:rhs -&gt; [ <span class="string">"div"</span>, lhs, rhs ]
| FilterMulExpression
,

FilterMulExpression =
  FilterMulExpression:lhs
  spaces se<span class="string">q("mul")</span> spaces
  FilterByValue:rhs -&gt; [ <span class="string">"mul"</span>, lhs, rhs ]
| FilterByValue
,

FilterByValue = 
  FilterNegateExpression
| Number
| QuotedText
| PropertyPath
,

FilterNegateExpression = 
  spaces
  se<span class="string">q("not")</span>
  spaces
  (
    FilterByValue
  | <span class="string">'('</span> spaces FilterByExpression:expr spaces <span class="string">')'</span> -&gt; expr
  ):value -&gt;  [ <span class="string">"not"</span>, value ]
,</code></pre>
<p>How cool is that??!!? That&#39;s pretty much the whole shebang wrapped up as far as expressing parsing goes, and now I can go trigger mad with nested and/or/sub/mul/etc - with the exception of the precedence operators which I&#39;ll add next!</p>
