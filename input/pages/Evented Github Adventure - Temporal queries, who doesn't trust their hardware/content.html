<p>Carrying on in the EventStore series...</p>

<ul>
<li><a href="/entries/playing-with-the-eventstore.html">Introduction to the EventStore</a></li>
<li><a href="/entries/pushing-data-into-streams-in-the-eventstore.html">Pushing data into the EventStore</a></li>
<li><a href="/entries/basic-projections-in-the-eventstore.html">Projections in the EventStore</a></li>
<li><a href="/entries/re-partitioning-streams-in-the-event-store-for-better-projections.html">Re-partitioning streams in the EventStore</a></li>
<li><a href="/entries/creating-a-projection-per-stream-in-the-eventstore.html">Creating a projection per stream</a></li>
<li><a href="/entries/less-abstract,-pumping-data-from-github-into-the-eventstore.html">Pumping data from Github into the EventStore</a></li>
<li><a href="/entries/evented-github-adventure---emitting-commits-as-their-own-events.html">Emitting new events from a projection</a></li>
<li><a href="/entries/evented-github-adventure---who-writes-the-sweariest-commit-messages.html">Who is the sweariest of them all?</a></li>
<li>Temporal queries in the event store</li>
</ul>

<p>Doing <a href="/entries/evented-github-adventure---who-writes-the-sweariest-commit-messages.html">basic aggregations</a> is fairly easy, but actually one of the great selling points of the projections system inside the EventStore is how easy it is to do temporal queries.</p>

<p>What is a temporal query? Well the example that <a href="http://twitter.com/gregyoung">Greg Young</a> always uses is "look for all the events in Twitter where somebody mentions starbucks, coffee, and happy within five minutes of each other"</p>

<p>The clue there is "look for all the events", and we'll see why that is with this example.</p>

<p><strong>Git</strong></p>

<p>Git is great, it's great because it's a DCVS and we can do everything locally and push to a remote repo when we feel we're ready.</p>

<p>That said, some people don't do this, every commit is a push - maybe it's because they're not used to using a system where they can work offline, or maybe they're just paranoid because they're working on a laptop they don't trust.</p>

<p>Either way, this is a great example of a temporal query we could write.</p>

<p><strong>A query on Git</strong></p>

<p><em>"Find the instances of pushes within X minutes of each other from the same user and same repo", is there a trend across different languages for this kind of usage?</em></p>

<p>I would <em>not</em> enjoy doing this in a standard database, but that's neither here nor there, let's see what we have.</p>

<p>First off, the important question is "what is the unique combination we're looking for"</p>

<p>We care about <em>PushEvent</em>s for a unique <em>User</em> and <em>Repo</em>, so it makes sense that what we should do is <em>partition by UserAndRepo</em>  so we can easily keep state around per repo.</p>

<p><strong>Partition by uniqueness</strong></p>

<p>Here is how that might look:</p>

<pre><code>fromStream('github')
  .when({
    "PushEvent": function(state, ev) {
      var repo = ev.body.repo.full_name
      linkTo('pushesbyrepo-' + repo, ev)
    }
  })
</code></pre>

<p>So far so good, I now have a stream per repo called "pushesbyrepo-{reponame}" - now what?</p>

<p>Well, the key thing I mentioned above was that we're "looking for all the events where", this suggests that perhaps the thing we are looking for should be considered an event in its own right.</p>

<p>We can do this, we can for each of thse streams keep a note of when the last push was, and if we encounter another push within a certain time-frame, emit an event for this find of ours.</p>

<p><strong>Running a projection per generated stream</strong></p>

<p>How to run this for each stream? Enter fromCategory</p>

<pre><code>fromCategory('pushesbyrepo')
  foreachStream()
  .when({
    $init: // etc
  })
</code></pre>

<p>There is a built in projection in the EventStore that will automatically use the character '-' to sort a collection of streams into categories, and if we have</p>

<ul>
<li>pushesbyrepo-bob</li>
<li>pushesbyrepo-alice</li>
<li>pushesbyrepo-derpy</li>
</ul>

<p>We'll get three categories to iterate through (bob, alice, and derpy)</p>

<p><strong>Emit the events we're looking for</strong></p>

<pre><code>fromCategory('pushesbyrepo')
  foreachStream()
  .when({
    $init: function(state, ev) {
      return {}
    },
    "PushEvent": function(state, ev) {
      if(state.lastPush) {
        var newDate = new Date(ev.body.created_at)
          , lastDate = new Date(state.lastPush.body.created_at)
          , difference = (newDate.getTime() - lastDate.getTime()) / 1000

        if(difference &lt; 120) {
          emit('paranoidpushes', "ParanoidPush", {
            first: state.lastPush,
            next: ev
          })
        }
      }
      state.lastPush = ev
      return state
    }
  })
</code></pre>

<p>Seems legit, simply keep the last PushEvent around at all times, when we get a new one, check the difference and emit an event if it's less than X minutes. NICE</p>

<p>Running this, I now have a stream at </p>

<p><em>/streams/paranoidpushes</em> </p>

<p>So, how many paranoid pushes have I had in the time period I've been sampling over? (roughly three hours at time of writing)</p>

<pre><code>fromStream('paranoidpushes')
  .when({
    "$init": function(state, ev) {
      state.count = 0
    },
    "ParanoidPush": function(state, ev) {
      state.count++
    }
  })
</code></pre>

<p>And the result?</p>

<pre><code>{ count: 1504 }
</code></pre>

<p>Voila, that's a temporal query that just works - and it's pretty easy too. Now we have this, perhaps we can look at combining this data we have to work out how this strange use of git plays out across different language developers.</p>