<p>We now have a <a href="/entries/evented-github-adventure---emitting-commits-as-their-own-events.html">stream for the commits</a> inside Github, and we have information about the repos associated with those commits, now how about asking a question about those commits.</p>

<p><em>"Oh Github Github, in the cloud, who is the sweariest developer out loud?"</em></p>

<p>Well, this is the kind of thing we might do outside the store (after re-partitioning per-language inside the store), but I haven't got a secondary store so I'm just going to build up a view model for my charting library directly inside the event store (using the commit events I made)</p>

<pre><code>var swearwords = [ "poop", "arse", "sugarlumps" ] // Changed to protect the innocent

fromStream('github-commits')
  .when({
    "$init": function(state, ev) {
      return { }
    },
    "Commit": function(state, ev) {
      var language = ev.body.repo.language

      if(!state[language])
        state[language] = { count: 0, total: 0 }

      var languageState = state[language]
      languageState.total += 1

      for(var i = 0 ; i &lt; swearwords.length; i++) {
        var curse = swearwords[i]
        if(ev.body.commit.message.indexOf(curse) &gt;= 0)
          languageState.count += 1
      }
      return state
    }
  })
</code></pre>

<p>And the results?</p>

<p>Well, I can go to </p>

<p><em>/projection/curses/state</em></p>

<p>And get a big pile of JSON, which looks a bit like this</p>

<pre><code>{
  "ASP": { total: 1, curses: 200 },
  "OpenEdge ABL": { total: 2, curses: 0 },
  "Julia": { total: 11, curses: 0 }
}
</code></pre>

<p>Plugging this into d3, and filtering out the items without enough entries, we get </p>

<div id="graph"></div>

<script type="text/javascript" src="/d3.v2.js"></script>

<script type="text/javascript">

  var svg = d3.select("#graph").append("svg")
          .attr("width", 640)
          .attr("height", 480)


  var data = 
  {"undefined":{"count":1,"total":361},"Matlab":{"count":0,"total":1},"C":{"count":0,"total":14},"JavaScript":{"count":0,"total":56},"Processing":{"count":0,"total":2},"Python":{"count":0,"total":41},"R":{"count":0,"total":2},"C++":{"count":0,"total":11},"null":{"count":0,"total":36},"Java":{"count":0,"total":29},"Ruby":{"count":1,"total":23},"PHP":{"count":0,"total":18},"Shell":{"count":0,"total":12},"Rust":{"count":0,"total":3},"VimL":{"count":0,"total":2},"Scheme":{"count":0,"total":1},"CoffeeScript":{"count":0,"total":4},"Emacs Lisp":{"count":0,"total":3},"Dart":{"count":0,"total":1},"Clojure":{"count":0,"total":1},"Scala":{"count":0,"total":3},"Perl":{"count":0,"total":1},"Erlang":{"count":0,"total":12},"Factor":{"count":0,"total":1},"Visual Basic":{"count":0,"total":1},"C#":{"count":0,"total":3},"AutoHotkey":{"count":0,"total":1},"ASP":{"count":0,"total":1},"Objective-C":{"count":0,"total":3},"Lua":{"count":0,"total":1},"ActionScript":{"count":0,"total":1}}

   </script>

   <script type="text/javascript">

   var filteredData = []
   for(var i in data) {
     if(data[i].total >= 50) {
       var datum = data[i]
       datum.percentage = Math.floor((datum.swears / datum.total) * 10000) / 100
       datum.language = i
       filteredData.push(datum)
     }
   }

   var scale = d3.scale.linear()
     .domain([0, d3.max(filteredData, function(d) { return d.total })])
     .range([0, 280]);

   svg.selectAll("text")
      .data(filteredData)
      .enter()
        .append("text")
        .attr("transform", function(d, i) { 
          var transform = "translate(" + i * (640 / filteredData.length) + "," + 380 + ") "
          transform += "rotate(75) "
          return transform
        })
        .attr("x", 0)
        .attr("y", 0)
        .text(function(d) { return d.language })

   svg.selectAll(".total")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "total")
         .attr("fill", '#00A')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - scale(d.total); })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return scale(d.total) })

    svg.selectAll(".curse")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "curse")
         .attr("fill", '#AAF')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - scale(d.swears); })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return scale(d.swears) })

</script>

<p>Actually, let's normalise this for the lols and see who is actually the sweariest, normalised from about 0% to 7% (the majority of developers are quite clean about things ;) )</p>

<div id="normalised"></div>

<script type="text/javascript">

  var svg = d3.select("#normalised").append("svg")
          .attr("width", 800)
          .attr("height", 480)

   var scale = d3.scale.linear()
     .domain([0, d3.max(filteredData, function(d) { return d.percentage })])
     .range([0, 1]);

   var maxPercentage = d3.max(filteredData, function(d) { return d.percentage });

   svg.append("text")
      .attr("fill", '#000')
      .attr("x", 710)
      .attr("y", 60)
      .text(maxPercentage + "%")

   svg.append("text")
      .attr("fill", '#000')
      .attr("x", 710)
      .attr("y", 350)
      .text(0 + "%")

   svg.selectAll(".label")
      .data(filteredData)
      .enter()
        .append("text")
        .attr("class", "label")
        .attr("transform", function(d, i) { 
          var transform = "translate(" + i * (640 / filteredData.length) + "," + 380 + ") "
          transform += "rotate(75) "
          return transform
        })
        .attr("x", 0)
        .attr("y", 0)
        .text(function(d) { return d.language })

    svg.selectAll(".curse")
     .data(filteredData)
     .enter()
       .append("rect")
         .attr("class", "curse")
         .attr("fill", '#AAF')
         .attr("x", function(d, i) { return i * (640 / filteredData.length)})
         .attr("y", function(d, i) { return 370 - (280 * scale(d.percentage)) })
         .attr("width", 640 / (filteredData.length + 1))
         .attr("height", function(d, i) { return 280 * scale(d.percentage) })

</script>

<p>So... turns out that C# developers are quite mild-mannered and PHP/Scala developers are fucking angry - and who can blame them?</p>

<p><em>note: There isn't really enough data to draw this sort of result, but let's not let that stop us making outrageous statements</em></p>

<p>Projections are a great way to analyse streams to generate knowledge about what is going on, of course simply doing aggregations over data over time is something we can achieve in most systems, in the next entry we'll look at something more interesting.</p>