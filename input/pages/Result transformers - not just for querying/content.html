<p>In the <a href="/entries/ravendb-resulttransformers---a-new-way-of-looking-at-things.html">last entry</a> I demonstrated a new artifact in RavenDB for transforming results from queries into view models with all the information attached you could think of.</p>
<p>Well, the primary use case (in my mind) for this, is the creation of view models for web clients without having to de-normalise data or perform multiple remote calls.</p>
<p>Well, actually - if we&#39;re viewing say, a single item by id, it doesn&#39;t make a lot of sense to have to do a query to get that single item by id. It doesn&#39;t make a lot of sense to have to create an index for this.</p>
<p>In the past, that&#39;s the best we could hope for, unless perhaps you used the &#39;include&#39; functionality to load related documents and then created the view model in the client out of those related documents. This looks something like this:</p>
<pre><code>var order = session.Include("CustomerId")
                        .<span class="operator"><span class="keyword">Load</span>&lt;<span class="keyword">Order</span>&gt;(<span class="string">"orders/1"</span>)

var customer = <span class="keyword">session</span>.<span class="keyword">Load</span>&lt;Customer&gt;(<span class="keyword">order</span>.CustomerId)

// Build <span class="keyword">view</span> model here</code></pre><p>This is okay and everything, but requires a bit of mental leg-work on the part of the client.</p>
<p>What you really want to do is just ask for the view model, sort of like making a single query in SQL to get all the information you want with one go.</p>
<p>Well, how about this?</p>
<pre><code>  var orderViewModel = session.Load<span class="tag">&lt;<span class="title">OrderWithCustomerTransform,</span> <span class="attribute">OrderWithCustomer</span>&gt;</span>("orders/1")</code></pre><p>That&#39;s a lot nicer, the code for this is as thus</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderWithCustomer</span> 
{</span>
   <span class="keyword">public</span> <span class="keyword">string</span> OrderId { <span class="keyword">get</span>; <span class="keyword">set</span>; }
   <span class="keyword">public</span> <span class="keyword">string</span> OrderDate { <span class="keyword">get</span>; <span class="keyword">set</span>; }
   <span class="keyword">public</span> <span class="keyword">string</span> CustomerId { <span class="keyword">get</span>; <span class="keyword">set</span>; }
   <span class="keyword">public</span> stirng CustomerName { <span class="keyword">get</span>; <span class="keyword">set</span>; }
}

    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderWithCustomerTransform</span> : <span class="title">AbstractIndexCreationTask</span>&lt;<span class="title">Order</span>&gt;
    {</span>
         <span class="keyword">public</span> OrderWithCustomerTransform()
         {
                TransformResults = (database, orders) =&gt;
                        from order in orders
                        let customer = database.Load&lt;Pet&gt;(order.CustomerId)
                        select <span class="keyword">new</span> {
             OrderId = order.Id,
             OrderDate = order.Date,
             CustomerId = customer.Id,
             CustomerName = customer.Name
                        }
         }
    }</code></pre><p>Being able to compose view models on the server as part of the load process by pulling in related documents and only pull out the fields you need is awesome.</p>
<p>Being able to re-use these transforms across different indexes or load operations and get a consistent return shape is even awesomer.</p>
<p>Tomorrow I&#39;ll show a really cool edge case around this, and how we got rid of a lot of he confusion around transforms.</p>
