[{"author":{"name":"Olle","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=7a1ec7b0fe2032dcdec98955465ad960&size=50&default=identicon"},"date":"(4/7/2011 7:25 AM)","text":"\r\n\t\t\t\t\tHi Rob. Great article and your RavenGallery project has been a really good introduction and inspiration for me and my Raven CQRS laboratory.I have one implementation question though that I hope you can give your point of view on.Lets say I have a command that I want to do a patch against Raven instead of the standard Execute (see below, taken from RavenGallery) behavior. public void Execute<T>(T command)        {            var handler = _container.GetInstance<ICommandHandler<T>>();            handler.Handle(command);            _documentSession.SaveChanges();        }I quess I could set a \"bool IsPatch\" on the ICommandHandler, and just skip the \"_documentSession.SaveChanges();\" if it's a patch. But I would really appreciate to hear your approach on this matter.\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(4/7/2011 12:07 PM)","text":"\r\n\t\t\t\t\tYou'll always run into problems if you try to constrain your functionality to an elaborate \"framework\" or way of thinking. The command/etc approach works for the way I do things in this app, but if you want to do patches outside of Unit of Work then I'd probably just create a different handler/wrapper for this type of thing.Rather than forcing your commands to all suddenly implement a bool IsPatch consider the following perhaps[PatchCommand]public PatchHandler : ICommandHandler { }You can either check for this in the Execute method, or have something more elaborate evolve as you discover other items of meta-data that command handlers might wish to expose.Another option would be to just push the SaveChanges into the command handler itself, the russian doll model would work quite well hereTransactionalCommandHandler[T] : ICommandHandler[T]{        public TransactionalCommandHandler(IDocumentSession session, ICommandHandler[T] innerHandler){         }          public Handle(T command) {                   innerHandler.Handle(command)                   session.SaveChanges();          }Then the container we use to find the handlers can be set up to wrap up any command handler that doesn't have [NotUnitOfWork] with a transactional command handler.This is a nice way of adding functionality anyway, for example LoggingCommandHandler and TimingCommandHandlerThere is no right or wrong, this example I just gave might be an example of over-engineering if you weren't going to use any of it, if a simple IsPatch property will work for you then you should just do it. You can always refactor further down the line if you so choose.\r\n\t\t\t\t"}]