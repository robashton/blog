<p>After all the work on indexes, things started getting downright <em>dirty</em> at the Hibernating Rhinos offices as we looked at re-vamping TransformResults in RavenDB.</p>
<p>First, a re-cap on what TransformResults actually is; consider we have a couple of documents that look something like this:</p>
<p><em>A pony</em></p>
<pre><code>    {
        <span class="method">id:</span> <span class="comment">"ponies/rainbowdash"</span>,
        <span class="method">name:</span> <span class="comment">"Rainbow Dash"</span>,
        <span class="method">colour:</span> <span class="string">'#9EDBF9'</span>,      // <span class="class">I</span> actually looked this up
        <span class="method">trampstamp:</span> <span class="string">'rainbow-lightning'</span>,
        <span class="method">petid:</span> <span class="string">'pets/tank'</span>
    }</code></pre><p><em>a pet</em></p>
<pre><code>    {
        <span class="property">id</span>: <span class="string">"pets/tank"</span>,
        <span class="property">name</span>: <span class="string">"Tank"</span>,
        species: <span class="string">"Tortoise"</span>,
        colour: '<span class="comment">#0F0'          // I didn't look this up</span>
    }</code></pre><p>Let&#39;s say we have an index that looks like this</p>
<pre><code>    public <span class="class"><span class="keyword">class</span> <span class="title">Ponies</span> :</span> AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
            <span class="keyword">from</span> pony <span class="keyword">in</span> ponies
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp
                            }
         }
    }</code></pre><p>When querying for a list of blue ponies, we might actually decide we want to know what species their pets are, we have the following options</p>
<ul>
<li>Include them from the client (This brings back a lot of information that we don&#39;t need)</li>
<li>Add a results transformer to the index</li>
</ul>
<p>We mostly end up doing the last one and so we do that and it looks like this:</p>
<pre><code>    public <span class="class"><span class="keyword">class</span> <span class="title">Ponies</span> :</span> AbstractIndexCreationTask&lt;Pony&gt;
    {
         public Ponies()
         {
              Map = ponies =&gt;
            <span class="keyword">from</span> pony <span class="keyword">in</span> ponies
                            select new {
                                pony.Name,
                                pony.Colour,
                                pony.Trampstamp
                            }
                TransformResults = (database, results) =&gt;
                        <span class="keyword">from</span> result <span class="keyword">in</span> results
                        let pet = database.Load&lt;Pet&gt;(result.PetId)
                        select new {
                            PonyId = pony.Id
                            Name = pony.Name,
                            PetName = pet.Name,
                            PetSpecies = pet.Species
                        }
         }
    }</code></pre><p>This gives us the ability to send only the information we want to the client as well as pull in information from other documents, that&#39;s pretty neat, but now it&#39;s in need of a bit of TLC, as some of its functionality has been <a href="http://ayende.com/blog/160545/feature-intersection-is-killing-me-referenced-document-indexing">superceded by Referenced Documents in Map</a> and it&#39;s a bit awkward as it is.</p>
<p>I&#39;ll talk more about that tomorrow when I go into some of the issues that we&#39;re experiencing with this feature.</p>
