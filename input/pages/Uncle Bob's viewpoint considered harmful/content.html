<p><strong>oof</strong></p>
<p>I just felt a disturbance in the force, it&#39;s as if a thousand angry geeks just vented their nerdrage on Twitter because of a <a href="http://blog.8thlight.com/uncle-bob/2013/03/05/TheStartUpTrap.html">blog post by Uncle Bob</a> and a response by <a href="http://news.ycombinator.com/item?id=5328721">@Nate Kohari</a>.</p>
<blockquote class="twitter-tweet"><p>It looks like I've pissed off everyone at 8th Light. Fortunately I can't hear the whining over the sound of me shipping code.</p>&mdash; Nate Kohari (@nkohari) <a href="https://twitter.com/nkohari/status/309028034755825665">March 5, 2013</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Ouch.</p>
<p><strong>So what kind of tests do you write Rob?</strong></p>
<p>Meh</p>
<p><strong>When do you write tests Rob?</strong></p>
<p>Meh</p>
<p><strong>Do you write tests Rob?</strong></p>
<p>Meh</p>
<p><strong>What</strong></p>
<p>Ok, so I write tests - I usually can&#39;t be bothered having this conversation though, because years of having &quot;TDD&quot; forced down everybody&#39;s throats has left a bitter divide between developers who crave tests with every ounce of their being, and developers who really don&#39;t like tests and wading between them is opening myself up for another few hours of argument when I&#39;d prefer to just be building stuff.</p>
<p><em>I&#39;m currently wandering around though, and have the time for this sort of thing.</em></p>
<p>Classic &quot;<em>make no assumptions</em>&quot; TDD is dead, that ship has sailed - it is over.  The stance it put forth however had the desired effect; which was to get everybody thinking about the code they wrote before they wrote it and write some tests around that code at some point in that code&#39;s lifetime so that iterating on that code in the future wouldn&#39;t be painful.</p>
<p><em>painful</em></p>
<p>That&#39;s the word. <strong>pain</strong>, let&#39;s say it again - <strong>pain</strong>, if it hurts - do something about it. </p>
<ul>
<li><p>Do you have too many tests that you are regularly throwing away with the failed feature? Stop writing so many tests around your product - you&#39;re likely experimenting and you&#39;re best off adopting a &quot;spike and stabilise&quot; approach to development.</p>
</li>
<li><p>Do you find it hard to make changes because lots of things break due to harmful coupling? Write some more tests around that part of the system, practise a test-first approach on new code and feel your way around those coupling issues.</p>
</li>
<li><p>Are you performing a song and dance around a feature because you want to do fine-grained unit testing and it means putting reams of code where your direct controller CRUD would suffice? Stop, stick with the end-to-end tests and perhaps use an in-memory repo to keep them fast enough.</p>
</li>
</ul>
<p>Listening to the pain is the only sane way to do software development, blindly listening to far-right viewpoints like Uncle Bobs will get you so far, and listening to far-left viewpoints which advocate throwing caution to the wind will probably lead you to failure. The idea that tests are a waste of time is a dangerous one if given time to grow in an echo chamber, but the idea that TDD is the absolute is just as dangerous.</p>
<p>Most of the time going with <em>make no assumptions</em> TDD is a waste of your client&#39;s money, and most of the time writing no tests at all will come back to bite you in the future - <em>got it</em>.</p>
<p>TDD as you mean it is a great academic exercise for your free time or weekends, TDD as you mean it is a great marketing term if you&#39;re one of those consultants who consult on TDD, and recruiters definitely love to see it on your CV but TDD is not usually how we build great software on time.</p>
<p><strong>So what kind of tests <em>do</em> you write Rob?</strong></p>
<ul>
<li>I usually spike and stabilise on new features which are likely to be canned, this means not making undue effort early on on code likely to be thrown away but allows the feature to get out as quickly as possible for feedback</li>
<li>I usually start off with end-to-end tests with an in-memory representation of anything that is slow (the database is an implementation detail etc)</li>
<li>I drop down to unit tests if I have complicated logic (surprisingly, most systems just have crud, so this is not necessary)</li>
<li>Workflows are usually tested from the UI as part of the end-to-end suite as it&#39;s what the user sees</li>
<li>Any combination of the above</li>
</ul>
<p><strong>Summary</strong></p>
<p>There are two types of pragmatist in this world when it comes to testing, those that use pragmatism as an excuse not to do the right thing, and me.</p>
