[{"author":{"name":"Frank Quednau","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=2dfe31131d62b675b10d7b02284d5303&size=50&default=identicon"},"date":"(2/2/2011 6:32 PM)","text":"\r\n\t\t\t\t\tEspecially in infrastructure cruft there shouldn't be much of an issue to look up a service in some container. I once introduced a more crude but maybe similar infrastructure piece over here: http://realfiction.net/go/137 . Looking at its age I don't know if I'd still do that. Looking at what happens in your code, I'd probably call the Command a message and define a message handler. Then I'm in the lingo of MemBus, which also has schemes to find handlers but which may delegate finding a handler to a container ;)But hey, as long as one can justify and put decisions in context, I'm fine.\r\n\t\t\t\t"},{"author":{"name":"Mikael Östberg","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=423b7858839335841e5b7c7640f2bec1&size=50&default=identicon"},"date":"(2/2/2011 6:57 PM)","text":"\r\n\t\t\t\t\tI actually think it's pretty smelly to inject the container. The main reason is, as you stated yourself; \"we can’t know from looking at the class from the outside what it needs from the container\".Wouldn't be better to stick with the constructor injection pattern which clearly shows what the dependencies are? Just inject the handlers as a IEnumerable and lookup the one you need based on T.\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(2/2/2011 7:01 PM)","text":"\r\n\t\t\t\t\tWhat does that actually give me other than more code to write?\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(2/2/2011 7:26 PM)","text":"\r\n\t\t\t\t\tFrank :: The above is just a very rudimentary example where it was the easiest way to get commands + handlers into that project - there are other times when we might wish to do this, finding validators, model binders, etc etc\r\n\t\t\t\t"},{"author":{"name":"Mike McG","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=271a3b15fe64293d1d1047b64cfdaa09&size=50&default=identicon"},"date":"(2/5/2011 7:38 PM)","text":"\r\n\t\t\t\t\tInteresting article and I share the concern about instantiating the entire application per request. But regarding injection of your dependency injection mechanism, IMHO, blech... Sure, like all smells, this can be justified away. But let's explore that smell. You've thrown away a significant defensive-coding mechanism (a junior developer can now grab any service he knows about, without expressing this in the constructor) and cohesion-encouraging mechanism (having all that accessibility without the smell of constructor parameter bloat leads to responsibility-creep), and it makes it even more difficult to understand the dependencies than \"traditional\" usage of a container.  In terms of project management, this technique carries the significant implication that only trusted, experienced, expensive  developers should work on this code.Also, I think you've overstated the cost in creating a ICommandRegistry abstraction, that has a simple implementation around the container in the application package (where all knowledge of the container should be isolated).\r\n\t\t\t\t"},{"author":{"name":"Yoann","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=f7de4a8c6161ccab99a72c3f9f4080e6&size=50&default=identicon"},"date":"(2/23/2011 3:26 PM)","text":"\r\n\t\t\t\t\tNow, that's spooky I was just about to write something similar to this. ServiceLocator injected by DI which in turns uses the container to get the components your need. I am not sure if I understand McG's point about defensive code; what's to stop any developer to bloat the constructor anyway? I think this pattern could be useful in facade type objects where it would need to access several other sub components. As for understanding the dependencies of a class by just looking at it, sure, I guess that makes sense, but then again looking at a constructor set of arguments won't tell you how those are used. \r\n\t\t\t\t"},{"author":{"name":"WishCow","avatar":"/images/IdenticonHandler.ashx?code=-1509327508"},"date":"(3/22/2011 2:06 PM)","text":"\r\n\t\t\t\t\tI'm confused. One of the main selling points of using a DIC is, that you will produce (it will help you produce) code that is easier to debug and understand by making classes more decoupled.Now, if there are objects, that need to create other objects, based on runtime parameters, you will haveto pass the DIC around, which means, you have now introduced coupling to the DIC, invalidating the point above.Or is this the whole point, that is better to be coupled to a DIC, instead of \"random\" objects?I honestly don't get it :s\r\n\t\t\t\t"},{"author":{"name":"robashton","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=b6a6693f03003f7ab0f9b0882e9c2dde&size=50&default=identicon"},"date":"(3/24/2011 9:52 AM)","text":"\r\n\t\t\t\t\tWishCow - If you have objects that need to be created dynamically based on some variable in the application, then you need to create those objects.Those objects are going to have dependencies, and those dependencies are going to have dependencies - it makes sense to call into the container to construct those objects.There are other ways of achieving this, but this is the simplest and this is the only point I am making here.Using an IOC container as a service location in_general is wrong, but for this kind of thing it can generally be accepted.\r\n\t\t\t\t"},{"author":{"name":"canada goose dame jakke","avatar":"http://www.gravatar.com/avatar.php?gravatar_id=9340d9c80d857ff8f4f28bae53a607a7&size=50&default=identicon"},"date":"(10/28/2011 9:44 AM)","text":"\r\n\t\t\t\t\tthe article is very nice and an eye opener.\r\n\t\t\t\t"}]