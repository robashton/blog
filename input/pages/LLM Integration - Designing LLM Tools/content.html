<p>Continuing on</p>
<ul>
<li><a href="/entries/an-adventure-in-llm+agent-development.html">Intro + Basics</a></li>
</ul>
<p>A bit of chat then, what can go wrong?</p>
<p>To re-iterate, we&#39;ve got</p>
<ul>
<li>A dynamic library of available components</li>
<li>Well defined subscription model (what produces what media, and what accepts it)</li>
<li>Fully defined schemas for all component configurations</li>
<li>Validation that can run across a workflow and tell you exactly what is wrong (and sometimes how to fix it)</li>
</ul>
<p>I&#39;ve set up ambient LLM integration in <a href="https://norsk.video/norsk-studio-live-media-workflow-server/">Norsk Studio</a>, and any code on the server can easily start a session against whatever is currently configured.</p>
<h2 id="the-basics">The basics</h2>
<ul>
<li>Chat lives in the web browser</li>
<li>The <em>model</em> effectively lives in the web browser too (the thing being edited, and the library it is using to do it)</li>
<li>LLM integration lives on the server (it has to use tokens to talk to the APIs, you don&#39;t want them on the client)</li>
</ul>
<p>The obvious thing to do is</p>
<ul>
<li>Set up a websocket which sets up a LLM session for this browser instance, it can tear it down when the WS goes away</li>
<li>Store chat history in local storage so a refresh of the page doesn&#39;t lose context</li>
<li>Create and supply tools to the LLM session that can query the workflow/library in the browser</li>
</ul>
<h2 id="a-naive-implementation">A naive implementation</h2>
<ul>
<li><em>get_current_workflow</em>: Serialise the document and send it back</li>
<li><em>list_available_components</em>: Serialise the library and send it back</li>
<li><em>add_component</em>: Take an id/type/config and add a component to the workspace</li>
<li><em>remove_component</em>: Self explanatory</li>
<li><em>subscribe</em>: Take a source id and destination id, and configuration for a subscription and set up/replace a sub</li>
</ul>
<p>Yeah... no. </p>
<p>Context bloat is a real thing and presenting all of the information in the app to the LLM is one of the first mistakes I assume everybody makes because I certainly did on my first pass.</p>
<ul>
<li>the current workflow contains configuration for every component (that&#39;s a lot of data)</li>
<li>components each have schemas attached (that&#39;s even more data)</li>
<li>add_component.. takes config, meaning the LLM needs to generate the config</li>
<li>subscribe - far too much context required potentially</li>
</ul>
<p>With a library of potentially a hundred or so components, and documents containing upwards of a dozen or two components, we&#39;d quickly exceed token limits with completely irrelevant information.
Worst case, the LLM API just throws rate limit errors at you, best case, the LLM does completely wacko operations because you&#39;ve filled its context window with garbage.</p>
<h2 id="surgical-precision">Surgical precision</h2>
<ul>
<li><em>get_workflow_components</em>: Return just the ids, the type, and a brief summary of what the component does from the library </li>
<li><em>get_workflow_graph</em>: Return the ids, subscriptions between them and basic configuration of each sub</li>
<li><em>search_components</em>: Given keywords, return just the types and summaries of matching components </li>
<li><em>add_component</em>: Given a display name, location and type, add the component with default configuration, return any validation issues</li>
<li><em>get_component_schema</em>: Given a specific component type, return the schema for the configuration of that component</li>
<li><em>update_component_config</em>: Given a component id, and a <em>partial</em> config, update just the provided rows of the component, return any validation issues</li>
<li><em>add_subscription</em>: Given two component ids (target/source), create a default widest-possible subscription between them, return validation issues</li>
<li><em>get_subscription_options</em>: Given two component ids, detail what is actually possible (the UI already does this with dropdowns and different UIs depending on what is selected)</li>
<li><em>update_subscription</em>: Supplying a subset of the options and the two ids, update the subscription (return validation issues)</li>
</ul>
<p>This is a key learning for anybody implementing LLM integration with custom tools, it&#39;s not too much of a shift.
If you have a good user experience (defaults, minimal interaction to perform happy path by default, etc), then that same experience can easily be provided to the LLM by tools and context bloat can be avoided.</p>
<ul>
<li><p><em>Do this thing</em>: Do the thing with minimal information, set up defaults for everything, tell the LLM/user about anything that might be wrong</p>
</li>
<li><p><em>get some information</em>: What is the least amount of information that the user/LLM needs to perform a task?</p>
</li>
<li><p>A user simply drags on components and for the most part can just hit &#39;save&#39; immediately because defaults are always provided</p>
</li>
<li><p>A user simply drags connections between components and the UI automatically creates a subscription that takes the most data allowed</p>
</li>
<li><p>Validation is ran constantly, with instructions on how to fix things, common examples</p>
<ul>
<li>Clashing ports on inputs/oututs</li>
<li>Clashing source names on inputs/outputs</li>
<li>Subscribing to video multiple times on outputs from different upstream sources when trying to subscribe to audio</li>
</ul>
</li>
</ul>
<p>There is no reason the LLM should have a different experience to the user, in fact the implementation of these tools in this case ends up using most of the same code. </p>
